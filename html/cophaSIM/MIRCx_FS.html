<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cophaSIM.MIRCx_FS API documentation</title>
<meta name="description" content="Created on Wed Sep 15 17:19:42 2021 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cophaSIM.MIRCx_FS</code></h1>
</header>
<section id="section-intro">
<p>Created on Wed Sep 15 17:19:42 2021</p>
<p>The MIRCx fringe sensor measures the coherent flux after simulating the image
given by the real oversampled coherence flux and adding noises on it.</p>
<p>INPUT: oversampled true coherent flux [NW,NB]</p>
<p>OUTPUT: macrosampled measured coherent flux [MW,NB]</p>
<p>Calculated and stored observables:
- Photometries: simu.PhotometryEstimated [MW,NA]
- Visibilities: simu.Visibility [MW,NIN]</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Wed Sep 15 17:19:42 2021

The MIRCx fringe sensor measures the coherent flux after simulating the image
given by the real oversampled coherence flux and adding noises on it.

INPUT: oversampled true coherent flux [NW,NB]

OUTPUT: macrosampled measured coherent flux [MW,NB]

Calculated and stored observables:
    - Photometries: simu.PhotometryEstimated [MW,NA]
    - Visibilities: simu.Visibility [MW,NIN]

&#34;&#34;&#34;

import numpy as np
from astropy.io import fits
from scipy.special import binom

from . import coh_tools as ct
from . import config
from .FS_DEFAULT import ABCDmod, realisticABCDmod

def MIRCxFS(*args,init=False, T=1, spectra=[], spectraM=[], posi=[], MFD=0.254,
            posi_center=4.68, posp=[],F=250, p=0.024, Dsize=(320,256), Dc=3, 
            PSDwindow=3, Tphot=0.2, Tint=0.8):
    &#34;&#34;&#34;
    From the oversampled coherent fluxes, simulates the noisy image on the detector 
    and estimates the macrosampled coherent fluxes.
    
    INPUT:
        - If init: all the below parameters.
        - If not init: currCfTrue - Oversampled True Coherent Flux   [NW,NB]

    OUTPUT: 
        - currCfEstimated - Macrosampled measured coherent flux [MW,NB]

    USED OBSERVABLES/PARAMETERS:
        - config.FS
    UPDATED OBSERVABLES/PARAMETERS:
        - simu.MacroImages: [NT,MW,NIN] Estimated PD before subtraction of the reference
        
    SUBROUTINES:
        - skeleton.add_camera_noise

    Parameters
    ----------
    *args : ARRAY [NW,NB]
        Expect oversampled coherent flux currCfTrue.
    init : BOOLEAN, optional
        If True, initialize the parameters of the fringe sensor.
        Needs spectra, spectraM
        All this parameters are stored in the dictionnary config.FS.
        Needs to be called before starting the simulation.
        The default is False.
    spectra : ARRAY [NW], necessary if INIT
        Spectral microsampling. The default is [].
    spectraM : ARRAY [MW], necessary if INIT
        Spectral macrosampling. The default is [].
    posi : LIST [NA], optional
        Positions [mm] of the fibers output on the V-groove 
        (it defines the spatial frequencies)
    MFD : FLOAT, optional
        Mode-field diameter in the microlenses plane of the V-groove.
    posi_center : FLOAT, optional
        Position of the center of the interferogram.
    posp : LIST [NA], optional
        Positions [mm] of the photometric beams on the detector.
        It has an impact on the SNR of the photometric signal if no field stop 
        is used (Dc=0)
    F : FLOAT, optional
        Focal length [mm] of the imaging lens
    p : FLOAT, optional
        Pixel size [mm] of the camera
    Dsize : TUPLE, optional
        Size [H,L] in number of pixels of the detector.
    Dc : FLOAT, optional
        Semi-Diameter [mm] of field stop. If zero, no field stop.
    PSDwindow : FLOAT, optional
        Semi-diameter [mm] of the window used for the calculation of the
        interferogram PSD.
    Tphot : FLOAT, optional
        Transmission in the photometric channel.
    Tint : FLOAT, optional
        Transmission in the interferometric channel.
    
    
    Returns
    -------
    currCfEstimated : ARRAY [MW,NB]
        Macrosampled measured coherent flux.

    &#34;&#34;&#34;

    if init:
        
        if not posi:    # Positions of the fibers on the V-groove.
            posi = [-2.75,-2.25,-0.5,0.75,2.25,3.25]
        
        if not posp:    # Positions of the photometric beams on the detector.
            # posp = [3.84,3.74,3.52,3.41,3.19,3.12]
            posp = [0.84,0.94, 1.16, 1.27, 1.49, 1.56]
        
        if not PSDwindow:
            if Dc:
                PSDwindow = Dc
            else:   # Minimum between the detector available space and the minimal separation between the 2 channels.
                PSDwindow = np.min([posi_center - np.max(posp), Dsize[0]*24-posi_center]) 
        
        NA=len(posp)
        NIN = int(NA*(NA-1)/2) ; NB=NA**2 ; NC = int(binom(NA,3))
        NW = len(spectra) ; MW = len(spectraM)
        NP = int(NA + 2*PSDwindow//p)  # 6 photometric beams + the interferogram
        
        Baselines = np.zeros(NIN)
        pixel_positions = np.linspace(-PSDwindow,PSDwindow,NP-NA)
        
        # The FWHM on the detector is given in Anugu et al: 2.1 (certainly
        # at lmbda=1.55).
        # I calculate the MFD by the formula MFD = FWHM/0.59
        detectorMFD = 3.56
        
        ich = np.array([[1,2], [1,3], [1,4], [1,5], [1,6], [2,3],
                        [2,4], [2,5], [2,6], [3,4],[3,5],[3,6],
                        [4,5],[4,6],[5,6]])
        ich = [&#39;12&#39;,&#39;13&#39;,&#39;14&#39;,&#39;15&#39;,&#39;16&#39;,&#39;23&#39;,&#39;24&#39;,&#39;25&#39;,&#39;26&#39;,&#39;34&#39;,&#39;35&#39;,&#39;36&#39;,&#39;45&#39;,&#39;46&#39;,&#39;56&#39;]
        
        ichorder = np.arange(NIN)
        active_ich = list(np.arange(NIN))
        
        config.FS[&#39;name&#39;] = &#39;MIRCxFS&#39;
        config.FS[&#39;func&#39;] = MIRCxFS
        config.FS[&#39;ich&#39;] = ich
        config.FS[&#39;ichorder&#39;] = ichorder
        config.FS[&#39;active_ich&#39;] = active_ich
        config.FS[&#39;NINmes&#39;] = NIN
        config.FS[&#39;NBmes&#39;] = NB
        config.FS[&#39;NCmes&#39;] = NC
        config.FS[&#39;PhotometricBalance&#39;] = np.ones(NIN)
        config.FS[&#39;NP&#39;] = NP
        config.FS[&#39;MW&#39;] = MW
        config.FS[&#39;posi&#39;] = posi
        config.FS[&#39;posi_center&#39;] = posi_center
        config.FS[&#39;MFD&#39;] = MFD
        config.FS[&#39;detectorMFD&#39;] = detectorMFD
        config.FS[&#39;posp&#39;] = posp
        config.FS[&#39;F&#39;] = F
        config.FS[&#39;p&#39;] = p
        config.FS[&#39;Dc&#39;] = Dc
        config.FS[&#39;PSDwindow&#39;] = PSDwindow
        config.FS[&#39;Tphot&#39;] = Tphot ; config.FS[&#39;Tint&#39;] = Tint
        
        
        # Noise maps
        config.FS[&#39;imsky&#39;]=np.zeros([MW,NP])                # Sky background (bias)
        config.FS[&#39;sigmap&#39;]=np.zeros([MW,NP])               # Dark noise
        
        # Resolution of the fringe sensor
        midlmbda = np.mean(spectra)
        deltalmbda = (np.max(spectra) - np.min(spectra))/MW
        config.FS[&#39;R&#39;] = midlmbda/deltalmbda        
        
        # Hard coding of the P2VM
        V2PM = np.zeros([NW,NP,NB])*1j; MacroV2PM = np.zeros([MW,NP,NB])*1j
        
        GaussianEnvelop = np.exp(-2*(2*pixel_positions/3.56)**2)
        EnergyDistribution = GaussianEnvelop/np.sum(GaussianEnvelop)*Tint
        
        # Creation of the oversampled V2PM
        iow=0 ; imw=0; OW = NW/MW
        for iw in range(NW):
            wl = spectra[iw]
            for ia in range(NA):
                V2PM[iw,ia,ia*(NA+1)] = Tphot*T                                 # Photometric beams
                V2PM[iw,NA:,ia*(NA+1)] = np.ones(NP-NA)*EnergyDistribution*T    # Interferometric beams
                for iap in range(ia+1,NA):
                    ib = ct.posk(ia,iap,NA)
                    Baselines[ib] = np.abs(posi[iap]-posi[ia])
                
                    OPD = Baselines[ib]/F * pixel_positions*1e3
                    PhaseDelays = 2*np.pi/spectra[iw] * OPD
                    PhaseDelaysM = 2*np.pi/spectra[imw] * OPD
                    
                    V2PM[iw,NA:,ia*NA+iap] = np.exp(PhaseDelays*1j)*EnergyDistribution*T
                    V2PM[iw,NA:,iap*NA+ia] = np.exp(-PhaseDelays*1j)*EnergyDistribution*T
            
            MacroV2PM[imw] += V2PM[iw]/OW
                    
            iow+=1
            if iow==OW:
                imw+=1
                iow=0
        
        # Oversampled Pixel-to-Visibility matrix
        P2VM = np.linalg.pinv(V2PM)
        
        # Undersampled Pixel-to-Visibility matrix
        MacroP2VM = np.linalg.pinv(MacroV2PM)
        
        config.FS[&#39;V2PM&#39;] = V2PM
        config.FS[&#39;P2VM&#39;] = P2VM
        config.FS[&#39;MacroP2VM&#39;] = MacroP2VM
        
        # The matrix of the elements norm only for the calculation of the bias of |Cf|Â².
        # /!\ To save time, it&#39;s in [NIN,NP]
        config.FS[&#39;ElementsNormDemod&#39;] = np.zeros([MW,NIN,NP])
        for imw in range(MW):
            ElementsNorm = config.FS[&#39;MacroP2VM&#39;][imw]*np.conj(config.FS[&#39;MacroP2VM&#39;][imw])
            config.FS[&#39;ElementsNormDemod&#39;][imw] = np.real(ct.NB2NIN(ElementsNorm.T).T)
            
        config.FS[&#39;V2PMgrav&#39;] = ct.simu2GRAV(config.FS[&#39;V2PM&#39;])
        config.FS[&#39;P2VMgrav&#39;] = ct.simu2GRAV(config.FS[&#39;P2VM&#39;], direction=&#39;p2vm&#39;)
        config.FS[&#39;MacroP2VMgrav&#39;] = ct.simu2GRAV(config.FS[&#39;MacroP2VM&#39;], direction=&#39;p2vm&#39;)
        
        config.FS[&#39;V2PM_r&#39;] = config.FS[&#39;V2PMgrav&#39;]
        config.FS[&#39;P2VM_r&#39;] = config.FS[&#39;P2VMgrav&#39;]
        config.FS[&#39;MacroP2VM_r&#39;] = config.FS[&#39;MacroP2VMgrav&#39;]
        
        
        config.FS[&#39;Piston2OPD&#39;] = np.zeros([NIN,NA])    # Piston to OPD matrix
        config.FS[&#39;OPD2Piston&#39;] = np.zeros([NA,NIN])    # OPD to Pistons matrix
        Piston2OPD_forInv = np.zeros([NIN,NA])
        
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = ct.posk(ia,iap,NA)
                config.FS[&#39;Piston2OPD&#39;][ib,ia] = 1
                config.FS[&#39;Piston2OPD&#39;][ib,iap] = -1
                if active_ich[ib]&gt;=0:
                    Piston2OPD_forInv[ib,ia] = 1
                    Piston2OPD_forInv[ib,iap] = -1
            
        config.FS[&#39;OPD2Piston&#39;] = np.linalg.pinv(Piston2OPD_forInv)   # OPD to pistons matrix
        config.FS[&#39;OPD2Piston&#39;][np.abs(config.FS[&#39;OPD2Piston&#39;])&lt;1e-8]=0
        
        config.FS[&#39;OPD2Piston_moy&#39;] = np.copy(config.FS[&#39;OPD2Piston&#39;])
        if config.TELref:
            iTELref = config.TELref - 1
            L_ref = config.FS[&#39;OPD2Piston&#39;][iTELref,:]
            config.FS[&#39;OPD2Piston&#39;] = config.FS[&#39;OPD2Piston&#39;] - L_ref
        
        config.FS[&#39;Piston2OPD_r&#39;] = config.FS[&#39;Piston2OPD&#39;]
        config.FS[&#39;OPD2Piston_r&#39;] = config.FS[&#39;OPD2Piston&#39;]
        config.FS[&#39;OPD2Piston_moy_r&#39;] = config.FS[&#39;OPD2Piston_moy&#39;]
        
        
        
        
        return
    
    from .config import NA, NB
    from . import simu
    
    it = simu.it
    
    iow = 0
    imw=0
    image_iw = np.zeros(config.FS[&#39;NP&#39;])
    
    currCfTrue = args[0]
               
    for iw in range(config.NW):
        
        Modulation = config.FS[&#39;V2PM&#39;][iw,:,:]
        image_iw = np.real(np.dot(Modulation,currCfTrue[iw,:]))
        
        simu.MacroImages[it,imw,:] += image_iw
        
        iow += 1
        if iow == config.OW:
            imw+=1
            iow = 0      

    
    if config.noise:
        from .skeleton import addnoise
        
        if np.min(simu.MacroImages[it,:,:])&lt;0:
            print(f&#34;Negative value on image at t={it}, before noise.\nI take absolue value.&#34;)
            simu.MacroImages[it,:,:] = np.abs(simu.MacroImages[it,:,:])
        
        simu.MacroImages[it,:,:] = addnoise(simu.MacroImages[it,:,:])
    
    # estimates coherences
    currCfEstimated = np.zeros([config.FS[&#39;MW&#39;],NB])*1j
    for imw in range(config.FS[&#39;MW&#39;]):
        Demodulation = config.FS[&#39;MacroP2VM&#39;][imw,:,:]
        currCfEstimated[imw,:] = np.dot(Demodulation,simu.MacroImages[it,imw,:])
    
    return currCfEstimated</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cophaSIM.MIRCx_FS.MIRCxFS"><code class="name flex">
<span>def <span class="ident">MIRCxFS</span></span>(<span>*args, init=False, T=1, spectra=[], spectraM=[], posi=[], MFD=0.254, posi_center=4.68, posp=[], F=250, p=0.024, Dsize=(320, 256), Dc=3, PSDwindow=3, Tphot=0.2, Tint=0.8)</span>
</code></dt>
<dd>
<div class="desc"><p>From the oversampled coherent fluxes, simulates the noisy image on the detector
and estimates the macrosampled coherent fluxes.</p>
<h2 id="input">Input</h2>
<ul>
<li>If init: all the below parameters.</li>
<li>If not init: currCfTrue - Oversampled True Coherent Flux
[NW,NB]</li>
</ul>
<p>OUTPUT:
- currCfEstimated - Macrosampled measured coherent flux [MW,NB]</p>
<p>USED OBSERVABLES/PARAMETERS:
- config.FS
UPDATED OBSERVABLES/PARAMETERS:
- simu.MacroImages: [NT,MW,NIN] Estimated PD before subtraction of the reference</p>
<h2 id="subroutines">Subroutines</h2>
<ul>
<li>skeleton.add_camera_noise</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>ARRAY [NW,NB]</code></dt>
<dd>Expect oversampled coherent flux currCfTrue.</dd>
<dt><strong><code>init</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If True, initialize the parameters of the fringe sensor.
Needs spectra, spectraM
All this parameters are stored in the dictionnary config.FS.
Needs to be called before starting the simulation.
The default is False.</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>ARRAY [NW], necessary if INIT</code></dt>
<dd>Spectral microsampling. The default is [].</dd>
<dt><strong><code>spectraM</code></strong> :&ensp;<code>ARRAY [MW], necessary if INIT</code></dt>
<dd>Spectral macrosampling. The default is [].</dd>
<dt><strong><code>posi</code></strong> :&ensp;<code>LIST [NA]</code>, optional</dt>
<dd>Positions [mm] of the fibers output on the V-groove
(it defines the spatial frequencies)</dd>
<dt><strong><code>MFD</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Mode-field diameter in the microlenses plane of the V-groove.</dd>
<dt><strong><code>posi_center</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Position of the center of the interferogram.</dd>
<dt><strong><code>posp</code></strong> :&ensp;<code>LIST [NA]</code>, optional</dt>
<dd>Positions [mm] of the photometric beams on the detector.
It has an impact on the SNR of the photometric signal if no field stop
is used (Dc=0)</dd>
<dt><strong><code>F</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Focal length [mm] of the imaging lens</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Pixel size [mm] of the camera</dd>
<dt><strong><code>Dsize</code></strong> :&ensp;<code>TUPLE</code>, optional</dt>
<dd>Size [H,L] in number of pixels of the detector.</dd>
<dt><strong><code>Dc</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Semi-Diameter [mm] of field stop. If zero, no field stop.</dd>
<dt><strong><code>PSDwindow</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Semi-diameter [mm] of the window used for the calculation of the
interferogram PSD.</dd>
<dt><strong><code>Tphot</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Transmission in the photometric channel.</dd>
<dt><strong><code>Tint</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Transmission in the interferometric channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>currCfEstimated</code></strong> :&ensp;<code>ARRAY [MW,NB]</code></dt>
<dd>Macrosampled measured coherent flux.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MIRCxFS(*args,init=False, T=1, spectra=[], spectraM=[], posi=[], MFD=0.254,
            posi_center=4.68, posp=[],F=250, p=0.024, Dsize=(320,256), Dc=3, 
            PSDwindow=3, Tphot=0.2, Tint=0.8):
    &#34;&#34;&#34;
    From the oversampled coherent fluxes, simulates the noisy image on the detector 
    and estimates the macrosampled coherent fluxes.
    
    INPUT:
        - If init: all the below parameters.
        - If not init: currCfTrue - Oversampled True Coherent Flux   [NW,NB]

    OUTPUT: 
        - currCfEstimated - Macrosampled measured coherent flux [MW,NB]

    USED OBSERVABLES/PARAMETERS:
        - config.FS
    UPDATED OBSERVABLES/PARAMETERS:
        - simu.MacroImages: [NT,MW,NIN] Estimated PD before subtraction of the reference
        
    SUBROUTINES:
        - skeleton.add_camera_noise

    Parameters
    ----------
    *args : ARRAY [NW,NB]
        Expect oversampled coherent flux currCfTrue.
    init : BOOLEAN, optional
        If True, initialize the parameters of the fringe sensor.
        Needs spectra, spectraM
        All this parameters are stored in the dictionnary config.FS.
        Needs to be called before starting the simulation.
        The default is False.
    spectra : ARRAY [NW], necessary if INIT
        Spectral microsampling. The default is [].
    spectraM : ARRAY [MW], necessary if INIT
        Spectral macrosampling. The default is [].
    posi : LIST [NA], optional
        Positions [mm] of the fibers output on the V-groove 
        (it defines the spatial frequencies)
    MFD : FLOAT, optional
        Mode-field diameter in the microlenses plane of the V-groove.
    posi_center : FLOAT, optional
        Position of the center of the interferogram.
    posp : LIST [NA], optional
        Positions [mm] of the photometric beams on the detector.
        It has an impact on the SNR of the photometric signal if no field stop 
        is used (Dc=0)
    F : FLOAT, optional
        Focal length [mm] of the imaging lens
    p : FLOAT, optional
        Pixel size [mm] of the camera
    Dsize : TUPLE, optional
        Size [H,L] in number of pixels of the detector.
    Dc : FLOAT, optional
        Semi-Diameter [mm] of field stop. If zero, no field stop.
    PSDwindow : FLOAT, optional
        Semi-diameter [mm] of the window used for the calculation of the
        interferogram PSD.
    Tphot : FLOAT, optional
        Transmission in the photometric channel.
    Tint : FLOAT, optional
        Transmission in the interferometric channel.
    
    
    Returns
    -------
    currCfEstimated : ARRAY [MW,NB]
        Macrosampled measured coherent flux.

    &#34;&#34;&#34;

    if init:
        
        if not posi:    # Positions of the fibers on the V-groove.
            posi = [-2.75,-2.25,-0.5,0.75,2.25,3.25]
        
        if not posp:    # Positions of the photometric beams on the detector.
            # posp = [3.84,3.74,3.52,3.41,3.19,3.12]
            posp = [0.84,0.94, 1.16, 1.27, 1.49, 1.56]
        
        if not PSDwindow:
            if Dc:
                PSDwindow = Dc
            else:   # Minimum between the detector available space and the minimal separation between the 2 channels.
                PSDwindow = np.min([posi_center - np.max(posp), Dsize[0]*24-posi_center]) 
        
        NA=len(posp)
        NIN = int(NA*(NA-1)/2) ; NB=NA**2 ; NC = int(binom(NA,3))
        NW = len(spectra) ; MW = len(spectraM)
        NP = int(NA + 2*PSDwindow//p)  # 6 photometric beams + the interferogram
        
        Baselines = np.zeros(NIN)
        pixel_positions = np.linspace(-PSDwindow,PSDwindow,NP-NA)
        
        # The FWHM on the detector is given in Anugu et al: 2.1 (certainly
        # at lmbda=1.55).
        # I calculate the MFD by the formula MFD = FWHM/0.59
        detectorMFD = 3.56
        
        ich = np.array([[1,2], [1,3], [1,4], [1,5], [1,6], [2,3],
                        [2,4], [2,5], [2,6], [3,4],[3,5],[3,6],
                        [4,5],[4,6],[5,6]])
        ich = [&#39;12&#39;,&#39;13&#39;,&#39;14&#39;,&#39;15&#39;,&#39;16&#39;,&#39;23&#39;,&#39;24&#39;,&#39;25&#39;,&#39;26&#39;,&#39;34&#39;,&#39;35&#39;,&#39;36&#39;,&#39;45&#39;,&#39;46&#39;,&#39;56&#39;]
        
        ichorder = np.arange(NIN)
        active_ich = list(np.arange(NIN))
        
        config.FS[&#39;name&#39;] = &#39;MIRCxFS&#39;
        config.FS[&#39;func&#39;] = MIRCxFS
        config.FS[&#39;ich&#39;] = ich
        config.FS[&#39;ichorder&#39;] = ichorder
        config.FS[&#39;active_ich&#39;] = active_ich
        config.FS[&#39;NINmes&#39;] = NIN
        config.FS[&#39;NBmes&#39;] = NB
        config.FS[&#39;NCmes&#39;] = NC
        config.FS[&#39;PhotometricBalance&#39;] = np.ones(NIN)
        config.FS[&#39;NP&#39;] = NP
        config.FS[&#39;MW&#39;] = MW
        config.FS[&#39;posi&#39;] = posi
        config.FS[&#39;posi_center&#39;] = posi_center
        config.FS[&#39;MFD&#39;] = MFD
        config.FS[&#39;detectorMFD&#39;] = detectorMFD
        config.FS[&#39;posp&#39;] = posp
        config.FS[&#39;F&#39;] = F
        config.FS[&#39;p&#39;] = p
        config.FS[&#39;Dc&#39;] = Dc
        config.FS[&#39;PSDwindow&#39;] = PSDwindow
        config.FS[&#39;Tphot&#39;] = Tphot ; config.FS[&#39;Tint&#39;] = Tint
        
        
        # Noise maps
        config.FS[&#39;imsky&#39;]=np.zeros([MW,NP])                # Sky background (bias)
        config.FS[&#39;sigmap&#39;]=np.zeros([MW,NP])               # Dark noise
        
        # Resolution of the fringe sensor
        midlmbda = np.mean(spectra)
        deltalmbda = (np.max(spectra) - np.min(spectra))/MW
        config.FS[&#39;R&#39;] = midlmbda/deltalmbda        
        
        # Hard coding of the P2VM
        V2PM = np.zeros([NW,NP,NB])*1j; MacroV2PM = np.zeros([MW,NP,NB])*1j
        
        GaussianEnvelop = np.exp(-2*(2*pixel_positions/3.56)**2)
        EnergyDistribution = GaussianEnvelop/np.sum(GaussianEnvelop)*Tint
        
        # Creation of the oversampled V2PM
        iow=0 ; imw=0; OW = NW/MW
        for iw in range(NW):
            wl = spectra[iw]
            for ia in range(NA):
                V2PM[iw,ia,ia*(NA+1)] = Tphot*T                                 # Photometric beams
                V2PM[iw,NA:,ia*(NA+1)] = np.ones(NP-NA)*EnergyDistribution*T    # Interferometric beams
                for iap in range(ia+1,NA):
                    ib = ct.posk(ia,iap,NA)
                    Baselines[ib] = np.abs(posi[iap]-posi[ia])
                
                    OPD = Baselines[ib]/F * pixel_positions*1e3
                    PhaseDelays = 2*np.pi/spectra[iw] * OPD
                    PhaseDelaysM = 2*np.pi/spectra[imw] * OPD
                    
                    V2PM[iw,NA:,ia*NA+iap] = np.exp(PhaseDelays*1j)*EnergyDistribution*T
                    V2PM[iw,NA:,iap*NA+ia] = np.exp(-PhaseDelays*1j)*EnergyDistribution*T
            
            MacroV2PM[imw] += V2PM[iw]/OW
                    
            iow+=1
            if iow==OW:
                imw+=1
                iow=0
        
        # Oversampled Pixel-to-Visibility matrix
        P2VM = np.linalg.pinv(V2PM)
        
        # Undersampled Pixel-to-Visibility matrix
        MacroP2VM = np.linalg.pinv(MacroV2PM)
        
        config.FS[&#39;V2PM&#39;] = V2PM
        config.FS[&#39;P2VM&#39;] = P2VM
        config.FS[&#39;MacroP2VM&#39;] = MacroP2VM
        
        # The matrix of the elements norm only for the calculation of the bias of |Cf|Â².
        # /!\ To save time, it&#39;s in [NIN,NP]
        config.FS[&#39;ElementsNormDemod&#39;] = np.zeros([MW,NIN,NP])
        for imw in range(MW):
            ElementsNorm = config.FS[&#39;MacroP2VM&#39;][imw]*np.conj(config.FS[&#39;MacroP2VM&#39;][imw])
            config.FS[&#39;ElementsNormDemod&#39;][imw] = np.real(ct.NB2NIN(ElementsNorm.T).T)
            
        config.FS[&#39;V2PMgrav&#39;] = ct.simu2GRAV(config.FS[&#39;V2PM&#39;])
        config.FS[&#39;P2VMgrav&#39;] = ct.simu2GRAV(config.FS[&#39;P2VM&#39;], direction=&#39;p2vm&#39;)
        config.FS[&#39;MacroP2VMgrav&#39;] = ct.simu2GRAV(config.FS[&#39;MacroP2VM&#39;], direction=&#39;p2vm&#39;)
        
        config.FS[&#39;V2PM_r&#39;] = config.FS[&#39;V2PMgrav&#39;]
        config.FS[&#39;P2VM_r&#39;] = config.FS[&#39;P2VMgrav&#39;]
        config.FS[&#39;MacroP2VM_r&#39;] = config.FS[&#39;MacroP2VMgrav&#39;]
        
        
        config.FS[&#39;Piston2OPD&#39;] = np.zeros([NIN,NA])    # Piston to OPD matrix
        config.FS[&#39;OPD2Piston&#39;] = np.zeros([NA,NIN])    # OPD to Pistons matrix
        Piston2OPD_forInv = np.zeros([NIN,NA])
        
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = ct.posk(ia,iap,NA)
                config.FS[&#39;Piston2OPD&#39;][ib,ia] = 1
                config.FS[&#39;Piston2OPD&#39;][ib,iap] = -1
                if active_ich[ib]&gt;=0:
                    Piston2OPD_forInv[ib,ia] = 1
                    Piston2OPD_forInv[ib,iap] = -1
            
        config.FS[&#39;OPD2Piston&#39;] = np.linalg.pinv(Piston2OPD_forInv)   # OPD to pistons matrix
        config.FS[&#39;OPD2Piston&#39;][np.abs(config.FS[&#39;OPD2Piston&#39;])&lt;1e-8]=0
        
        config.FS[&#39;OPD2Piston_moy&#39;] = np.copy(config.FS[&#39;OPD2Piston&#39;])
        if config.TELref:
            iTELref = config.TELref - 1
            L_ref = config.FS[&#39;OPD2Piston&#39;][iTELref,:]
            config.FS[&#39;OPD2Piston&#39;] = config.FS[&#39;OPD2Piston&#39;] - L_ref
        
        config.FS[&#39;Piston2OPD_r&#39;] = config.FS[&#39;Piston2OPD&#39;]
        config.FS[&#39;OPD2Piston_r&#39;] = config.FS[&#39;OPD2Piston&#39;]
        config.FS[&#39;OPD2Piston_moy_r&#39;] = config.FS[&#39;OPD2Piston_moy&#39;]
        
        
        
        
        return
    
    from .config import NA, NB
    from . import simu
    
    it = simu.it
    
    iow = 0
    imw=0
    image_iw = np.zeros(config.FS[&#39;NP&#39;])
    
    currCfTrue = args[0]
               
    for iw in range(config.NW):
        
        Modulation = config.FS[&#39;V2PM&#39;][iw,:,:]
        image_iw = np.real(np.dot(Modulation,currCfTrue[iw,:]))
        
        simu.MacroImages[it,imw,:] += image_iw
        
        iow += 1
        if iow == config.OW:
            imw+=1
            iow = 0      

    
    if config.noise:
        from .skeleton import addnoise
        
        if np.min(simu.MacroImages[it,:,:])&lt;0:
            print(f&#34;Negative value on image at t={it}, before noise.\nI take absolue value.&#34;)
            simu.MacroImages[it,:,:] = np.abs(simu.MacroImages[it,:,:])
        
        simu.MacroImages[it,:,:] = addnoise(simu.MacroImages[it,:,:])
    
    # estimates coherences
    currCfEstimated = np.zeros([config.FS[&#39;MW&#39;],NB])*1j
    for imw in range(config.FS[&#39;MW&#39;]):
        Demodulation = config.FS[&#39;MacroP2VM&#39;][imw,:,:]
        currCfEstimated[imw,:] = np.dot(Demodulation,simu.MacroImages[it,imw,:])
    
    return currCfEstimated</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cophaSIM" href="index.html">cophaSIM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cophaSIM.MIRCx_FS.MIRCxFS" href="#cophaSIM.MIRCx_FS.MIRCxFS">MIRCxFS</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>