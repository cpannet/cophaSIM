<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>coh_lib.SPICA_FS API documentation</title>
<meta name="description" content="The SPICA fringe sensor measures the coherent flux after simulating the image
given by the real oversampled coherence flux and adding noises on it â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coh_lib.SPICA_FS</code></h1>
</header>
<section id="section-intro">
<p>The SPICA fringe sensor measures the coherent flux after simulating the image
given by the real oversampled coherence flux and adding noises on it.</p>
<p>INPUT: oversampled true coherent flux [NW,NB]</p>
<p>OUTPUT: macrosampled measured coherent flux [MW,NB]</p>
<p>Calculated and stored observables:
- Photometries: simu.PhotometryEstimated [MW,NA]
- Visibilities: simu.Visibility [MW,NIN]</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
The SPICA fringe sensor measures the coherent flux after simulating the image
given by the real oversampled coherence flux and adding noises on it.

INPUT: oversampled true coherent flux [NW,NB]

OUTPUT: macrosampled measured coherent flux [MW,NB]

Calculated and stored observables:
    - Photometries: simu.PhotometryEstimated [MW,NA]
    - Visibilities: simu.Visibility [MW,NIN]

&#34;&#34;&#34;

import numpy as np
from astropy.io import fits

# coh_lib subpackages
from . import coh_tools as ct
from . import config
from .FS_DEFAULT import ABCDmod

def SPICAFS_PERFECT(*args,T=1, init=False, spectra=[], spectraM=[]):
    &#34;&#34;&#34;
    Measures the coherent flux after simulating the image given by the real 
    oversampled coherence flux and adding noises on it.
    
    INPUT:
        - If init: all the below parameters.
        - If not init: currCfTrue - Oversampled True Coherent Flux   [NW,NB]

    OUTPUT: 
        - currCfEstimated - Macrosampled measured coherent flux [MW,NB]

    USED OBSERVABLES/PARAMETERS:
        - config.FS
    UPDATED OBSERVABLES/PARAMETERS:
        - simu.MacroImages: [NT,MW,NIN] Estimated PD before subtraction of the reference
        - simu.GD_: [NT,MW,NIN] Estimated GD before subtraction of the reference
        - simu.CommandODL: Piston Command to send       [NT,NA]
        
    SUBROUTINES:
        - coh_lib.add_camera_noise

    Parameters
    ----------
    *args : ARRAY [NW,NB]
        Expect oversampled coherent flux currCfTrue.
    init : BOOLEAN, optional
        If True, initialize the parameters of the fringe sensor. 
        Needs spectra, spectraM
        All this parameters are stored in the dictionnary config.FS.
        Needs to be called before starting the simulation.
        The default is False.
    spectra : ARRAY [NW], necessary if INIT
        Spectral microsampling. The default is [].
    spectraM : ARRAY [MW], necessary if INIT
        Spectral macrosampling. The default is [].
        
    Returns
    -------
    currCfEstimated : ARRAY [MW,NB]
        Macrosampled measured coherent flux.

    &#34;&#34;&#34;


    from . import config
    
    if init:
        
        from .config import NA,NB
        
        # Created by the user here
        ich = np.array([[1,2], [1,3], [2,3], [2,4], [1,4], [1,5], [2,5], [1,6],[2,6],\
                  [3,6],[3,4],[3,5],[4,5],[4,6],[5,6]])
        
        config.FS[&#39;func&#39;] = SPICAFS_PERFECT
        config.FS[&#39;ich&#39;] = ich
        NG = np.shape(ich)[0]       # should always be equal to NIN
        
        # Classic balanced ABCD modulation of each baseline
        
        M_ABCD = ABCDmod()          # A2P ABCD modulation
        NMod = len(M_ABCD)          # Number of modulations for each baseline
        config.FS[&#39;Modulations&#39;] = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]
        NP = NMod*NG
        
        config.FS[&#39;NMod&#39;] = NMod
        config.FS[&#39;NP&#39;] = NP
        config.FS[&#39;T&#39;] = T
        
        # Build the A2P of SPICA
        
        M_spica = np.zeros([NP,NA])*1j
        for ig in range(NG):
            for ia in range(2):
                M_spica[NMod*ig:NMod*(ig+1),ich[ig,ia]-1] = M_ABCD[:,ia]
        
        # Build the V2P and P2V matrices
        
        V2PM = np.zeros([NP,NB])*1j
        for ip in range(NP):
            for ia in range(NA):
                for iap in range(NA):
                    k = ia*NA+iap
                    V2PM[ip, k] = M_spica[ip,ia]*np.transpose(np.conjugate(M_spica[ip,iap]))
        
        P2VM = np.linalg.pinv(V2PM)    
        
        NW, MW = len(spectra), len(spectraM)
        
        # Noise maps
        config.FS[&#39;imsky&#39;]=np.zeros([MW,NP])                # Sky background (bias)
        config.FS[&#39;sigsky&#39;]=np.random.randn(MW,NP)        # Dark noise (1rms)
        
        # Resolution of the fringe sensor
        midlmbda = np.mean(spectra)
        deltalmbda = (np.max(spectra) - np.min(spectra))/MW
        config.FS[&#39;R&#39;] = midlmbda/deltalmbda
        
        config.FS[&#39;V2PM&#39;] = np.repeat(V2PM[np.newaxis,:,:],NW,0)
        config.FS[&#39;P2VM&#39;] = np.repeat(P2VM[np.newaxis,:,:],NW,0)
        config.FS[&#39;MacroP2VM&#39;] = np.repeat(P2VM[np.newaxis,:,:],MW,0)
    
        return
    
    from .config import NA, NB, NW, MW, OW
    from . import simu
    
    it = simu.it
    
    iow = 0
    imw=0
    image_iw = np.zeros(config.FS[&#39;NP&#39;])
    
    currCfTrue = args[0]     # declared in argument
    currCfTrue *= config.FS[&#39;T&#39;]
                      
        
    for iw in range(config.NW):
        
        Modulation = config.FS[&#39;V2PM&#39;][iw,:,:]
        image_iw = np.abs(np.dot(Modulation,currCfTrue[iw,:]))
        
        simu.MacroImages[it,imw,:] += image_iw/OW
        
        iow += 1
        if iow == OW:
            imw+=1
            iow = 0      

    
    if config.noise:
        from .skeleton import addnoiseADU
        simu.MacroImages[it,:,:] = addnoiseADU(simu.MacroImages[it,:,:])
    
    # if np.min(simu.MacroImages[it]) &lt; 0:
    #     print(f&#39;Negative image value at t={it}&#39;)
    
    # estimates coherences
    currCfEstimated = np.zeros([MW,NB])*1j
    for imw in range(MW):
        Demodulation = config.FS[&#39;MacroP2VM&#39;][imw,:,:]
        currCfEstimated[imw,:] = np.dot(Demodulation,simu.MacroImages[it,imw,:])
    
    return currCfEstimated



def SPICAFS_TRUE(*args, init=False, T=0.5, wlinfo=False, **kwargs):
    &#34;&#34;&#34;
    Init: Reads the fitsfile and load the different parameters NP, ich, T, 
    Modulations, spectra into the config module.
    Run: Takes true current Coherent Flux, calculates the image, add noise 
    and estimates noisy Coherent Flux.

    Parameters
    ----------
    *args : TYPE
        - if init: expect fitsfile: string
        FITS file of the SPICA&#39;s fringe sensor V2PM
        - if run: expect currCfTrue: ARRAY [NW,NB]
        
    init : BOOLEAN, optional
        If True, initialising mode. The default is False.
        If False, running mode.
    T : float, optional
        Transmission of the CHIP. The default is 1.
    wlinfo : float, optional
        If True, returns the extremal wavelength. The default is False.
    **kwargs : TYPE
        if OS given: oversample the macro spectra with the OS factor.

    Raises
    ------
    Exception
        The oversampling must be integer. Given: {OS}.

    Returns
    -------
    If Init: empty
    If wlinfo: TUPLE
        Extremal wavelengths.
    If Run: ARRAY [MW,NB]
        Estimated macro coherent flux.

    &#34;&#34;&#34;

    # print(config.FS)
    # config?
    
    if wlinfo:
        
        fitsfile = kwargs[&#39;fitsfile&#39;]
        
        hdul = fits.open(fitsfile)
        
        # detectordico=hdul[1].data       # Base and ABCD positions information
        wldico = hdul[2].data           # Wavelength information
    
        # We pick up the calibrated wavelengths and corresponding wavebands
        spectraM = wldico[&#39;EFF_WAVE&#39;]*1e6       # Convert to [Âµm]
        wavebandv2pm = np.abs(wldico[&#39;EFF_BAND&#39;])*1e6   # Convert to [Âµm]
    
        minspectra = spectraM[0]-wavebandv2pm[0]/2
        maxspectra = spectraM[-1]+wavebandv2pm[-1]/2
        
        print(f&#39;The sensor passband is from {minspectra}Âµm to {maxspectra}Âµm.&#39;)
        
        return minspectra, maxspectra
    
    if init:
        
        from .config import NW,MW,spectra
        fitsfile = kwargs[&#39;fitsfile&#39;]
        
        hdul = fits.open(fitsfile)
        
        detectordico=hdul[1].data       # Base and ABCD positions information
        wldico = hdul[2].data           # Wavelength information
        v2pmdico = hdul[3].data         # contains the V2PM
            
        # hdul.close()
        config.FS[&#39;func&#39;] = SPICAFS_TRUE
        # We read the interferometric channels indices and modulation patterns
        ichraw = detectordico[&#39;BEAM_INDEX&#39;]
        Modulations = list(detectordico[&#39;ABCD_INDEX&#39;][:4])
        NMod = len(Modulations)
        NP = len(ichraw)
        
        config.FS[&#39;Modulations&#39;] = Modulations
        config.FS[&#39;NMod&#39;] = NMod
        config.FS[&#39;NP&#39;] = NP
        config.FS[&#39;ich&#39;] = np.array([(ichraw[i]) for i in range(0,NP,NMod)])
        config.FS[&#39;T&#39;] = T
        
        # We pick up the calibrated wavelengths and corresponding wavebands
        spectraM = wldico[&#39;EFF_WAVE&#39;]*1e6       # Convert to [Âµm]
        wavebandv2pm = np.abs(wldico[&#39;EFF_BAND&#39;])*1e6   # Convert to [Âµm]
            
        # Spectral resolution of the first spectral channel
        config.FS[&#39;R&#39;] = spectraM[0]/wavebandv2pm[0]
        
        # Number of wavelengths in V2PM and in the reference spectra
        MW = len(spectraM)

        # Noise maps
        config.FS[&#39;imsky&#39;]=np.zeros([MW,NP])             # Sky background (bias)
        config.FS[&#39;sigsky&#39;]=np.random.randn([MW,NP])       # Dark Noise [ron=1rms]

        # Now we pike up the P2VM and sort it according to wavelengths
        V2PM = v2pmdico[&#39;V2PM&#39;]
        
        if spectraM[0] &gt; spectraM[-1]:      # First wavelength higher than last wl
            V2PM = np.flip(V2PM,0)
            spectraM = np.flip(spectraM)
            
        
        # NP = np.shape(V2PM)[1]
        NB = np.shape(V2PM)[2]
        
        # print(config.FS)
        # ich=[]
        # NQ = 2
        # NIN = 2*NQ      
        # for ip in range(NP//4):      # We assume ABCD are logically sorted (ABCD)
        #     ich.append(list(detectordico[&#39;BEAM_INDEX&#39;][4*ip]-1))
        # ich = np.array(ich)+1
        
        # From the undersampled V2PM we calculates the corresponding P2VM and build 
        # the oversampled V2PM and P2VM
        
        if &#39;OS&#39; in kwargs.keys():
            OS = kwargs[&#39;OS&#39;]
            if not isinstance(kwargs[&#39;OS&#39;],int):
                raise Exception(f&#39;The oversampling must be integer. Given: {OS}&#39;)
            MacroV2PM = V2PM
            # for imw in range(MW):
                
            spectra,spectraM = ct.oversample_wv(spectraM,OS,
                                             spectraband=wavebandv2pm,
                                             mode=&#39;linear_wl&#39;)
            NW = len(spectra)
            MicroV2PM = np.zeros([NW,NP,NB])*1j
            # MicroP2VM = np.zeros([NW,NB,NP])*1j
            iot,imw = 0,0
            for iw in range(NW):
                if iot==OS:
                    imw+=1
                    iot=0
                MicroV2PM[iw] = MacroV2PM[imw]
            
            MicroV2PM, MicroP2VM = ct.coh__GRAV2simu(MicroV2PM)
            
            config.MW = len(spectraM)

            config.FS[&#39;V2PM&#39;] = MicroV2PM
            config.FS[&#39;P2VM&#39;] = MicroP2VM
            
            MacroP2VM = np.ones([MW,NB,NP])*1j
            for imw in range(MW):
                MacroP2VM[imw] = MicroP2VM[imw*OS]
            
            config.FS[&#39;MacroP2VM&#39;] = MacroP2VM
            
            # Changes the oversampled spectra and initializes the macro spectra
            config.spectra = spectra
            config.NW = NW
            config.spectraM = spectraM
            config.MW = MW

            return spectra, spectraM
            
        else:
            MicroV2PM = np.zeros([NW,NP,NB])*1j
            MicroP2VM = np.zeros([NW,NB,NP])*1j
            newspectra=np.zeros(NW)
            bands=[[]]                  # will stock the wavelength of each band
            for imw in range(1,MW):
                bands.append([])
            
            k=0    
            for iw in range(NW):
                # Test if the reference wavelength is in one of the FS spectral channels
                for imw in range(MW):
                    is_between = spectraM[imw]-wavebandv2pm[imw]/2 &lt;= spectra[iw] &lt;= \
                        spectraM[imw]+wavebandv2pm[imw]/2
                    if is_between:      # If it is, we add it to the new p2vm
                        MicroV2PM[k] = V2PM[imw]
                        newspectra[k] = spectra[iw]          # The wavelength is added to the final spectra
                        bands[imw].append(k)
                        k+=1
                        break
            
            # We adapt it to the simulation formalism and generate pseudo-inverse matrix
            MicroV2PM, MicroP2VM = ct.coh__GRAV2simu(MicroV2PM[:k])
            
            newspectra = newspectra[:k]
            NW = k
            MicroV2PM = MicroV2PM[:k]
            MicroP2VM = MicroP2VM[:k]
            
            r = NW%MW
            if r!=0:       # in order to have an integer oversampling
                to_delete = []          # Stock the indices of elements to remove
                for i in range(r):
                    bandwidths = [len(band) for band in bands]
                    maxband=np.argmax(bandwidths)
                    to_delete.append(bands[maxband].pop(-1))
                    
                newspectra = np.delete(newspectra,to_delete)
                MicroV2PM = np.delete(MicroV2PM, to_delete,axis=0)
                MicroP2VM = np.delete(MicroP2VM, to_delete,axis=0)
                
                NW = len(newspectra)
                spectra = newspectra
                
            MacroP2VM = np.zeros([MW,NB,NP])*1j
            for imw in range(MW):
                iw = bands[imw][0]
                MacroP2VM[imw] = MicroP2VM[iw]
    
    
            config.FS[&#39;V2PM&#39;] = MicroV2PM
            config.FS[&#39;P2VM&#39;] = MicroP2VM
            config.FS[&#39;MacroP2VM&#39;] = MacroP2VM
            
            # Changes the oversampled spectra and initializes the macro spectra
            config.spectra = newspectra
            config.NW = NW
            config.spectraM = spectraM
            config.MW = MW
        
            return
    
    from .config import NB, NW, MW, OW
    from . import simu
    
    it = simu.it
    
    iow = 0
    imw=0
    image_iw = np.zeros(config.FS[&#39;NP&#39;])
    
    currCfTrue = args[0]     # declared in argument
    currCfTrue *= config.FS[&#39;T&#39;]**2             # Transmission of the CHIP                      
    for iw in range(config.NW):
        
        Modulation = config.FS[&#39;V2PM&#39;][iw,:,:]
        image_iw = np.abs(np.dot(Modulation,currCfTrue[iw,:]))
        
        simu.MacroImages[it,imw,:] += image_iw/OW
        
        iow += 1
        if iow == OW:
            imw+=1
            iow = 0
            
    if config.noise:
        from .skeleton import addnoiseADU
        simu.MacroImages[it,:,:] = addnoiseADU(simu.MacroImages[it,:,:])
    
    # if np.min(simu.MacroImages[it]) &lt; 0:
    #         print(f&#39;Negative image value at t={it}&#39;)
            
    # estimates coherences
    currCfEstimated = np.zeros([MW,NB])*1j
    for imw in range(MW):
        Demodulation = config.FS[&#39;MacroP2VM&#39;][imw,:,:]
        currCfEstimated[imw,:] = np.dot(Demodulation,simu.MacroImages[it,imw,:])
    
    
    return currCfEstimated


def SPICAFS_TRUE2(*args, init=False, OS=10, wlinfo=False, **kwargs):
    
    &#34;&#34;&#34;
    Read the fits file of SPICA&#39;s fringe sensor and returns its V2PM, P2VM and 
    interferometric channels.

    Parameters
    ----------
    fitsfile: string
        FITS file of the SPICA&#39;s fringe sensor V2PM

    Returns
    -------
    V2PM : [NW,NP,NB] floats
        Visibility to Pixels matrix
    P2VM : [NW, NB, NP] floats
        Pixel to Visibility matrix
    ich : [NP, 2] int  (it might change later for ABCD sorting info -&gt; [NP,3])
        Interferometric channel sorting
    &#34;&#34;&#34;
    
    if wlinfo:
        
        fitsfile = kwargs[&#39;fitsfile&#39;]
        
        hdul = fits.open(fitsfile)
        
        # detectordico=hdul[1].data       # Base and ABCD positions information
        wldico = hdul[2].data           # Wavelength information
    
        # We pick up the calibrated wavelengths and corresponding wavebands
        spectraM = wldico[&#39;EFF_WAVE&#39;]*1e6       # Convert to [Âµm]
        wavebandv2pm = np.abs(wldico[&#39;EFF_BAND&#39;])*1e6   # Convert to [Âµm]
    
        minspectra = spectraM[0]-wavebandv2pm[0]/2
        maxspectra = spectraM[-1]+wavebandv2pm[-1]/2
        
        print(f&#39;The sensor passband is from {minspectra}Âµm to {maxspectra}Âµm.&#39;)
        
        return minspectra, maxspectra
    
    if init:
        
        # from .config import NW,spectra
        fitsfile = kwargs[&#39;fitsfile&#39;]
        
        hdul = fits.open(fitsfile)
        
        detectordico=hdul[1].data       # Base and ABCD positions information
        wldico = hdul[2].data           # Wavelength information
        v2pmdico = hdul[3].data         # contains the V2PM
            
        # hdul.close()
        
        # We read the interferometric channels indices and modulation patterns
        ichraw = detectordico[&#39;BEAM_INDEX&#39;]
        Modulations = list(detectordico[&#39;ABCD_INDEX&#39;][:4])
        NMod = len(Modulations)
        NP = len(ichraw)
        
        config.FS[&#39;Modulations&#39;] = Modulations
        config.FS[&#39;NMod&#39;] = NMod
        config.FS[&#39;NP&#39;] = NP
        config.FS[&#39;ich&#39;] = np.array([(ichraw[i]) for i in range(0,NP,NMod)])
        
        # We pick up the calibrated wavelengths and corresponding wavebands
        spectraM = wldico[&#39;EFF_WAVE&#39;]*1e6               # Convert to [Âµm]
        wavebandv2pm = np.abs(wldico[&#39;EFF_BAND&#39;])*1e6   # Convert to [Âµm]
            
        # Spectral resolution of the first spectral channel
        config.FS[&#39;R&#39;] = spectraM[0]/wavebandv2pm[0]
        
        # Number of wavelengths in V2PM and in the reference spectra
        MW = len(spectraM)

        # Now we pike up the P2VM and sort it according to wavelengths
        V2PM = v2pmdico[&#39;V2PM&#39;]
        
        if spectraM[0] &gt; spectraM[-1]:      # First wavelength higher than last wl
            V2PM = np.flip(V2PM,0)
            spectraM = np.flip(spectraM)
            
        
        # NP = np.shape(V2PM)[1]
        NB = np.shape(V2PM)[2]
        
        
        # ich=[]
        # NQ = 2
        # NIN = 2*NQ      
        # for ip in range(NP//4):      # We assume ABCD are logically sorted (ABCD)
        #     ich.append(list(detectordico[&#39;BEAM_INDEX&#39;][4*ip]-1))
        # ich = np.array(ich)+1
        
        # From the undersampled V2PM we calculates the corresponding P2VM and build 
        # the oversampled V2PM and P2VM
        
        
        if not isinstance(OS,int):
            raise f&#39;The oversampling must be integer. Given: {OS}&#39;
        
        MacroV2PM = V2PM
        spectra,spectraM = ct.oversample_wv(spectraM,OS,
                                             spectraband=wavebandv2pm,
                                             mode=&#39;linear_wl&#39;)
        
        NW = len(spectra)

        MicroV2PM = np.zeros([NW,NP,NB])*1j
        iot,imw = 0,0
        for iw in range(NW):
            if iot==OS:
                imw+=1
                iot=0
            MicroV2PM[iw] = MacroV2PM[imw]
        
        MicroV2PM, MicroP2VM = ct.coh__GRAV2simu(MicroV2PM)
        
        config.FS[&#39;V2PM&#39;] = MicroV2PM
        config.FS[&#39;P2VM&#39;] = MicroP2VM 
        config.spectra = spectra
        config.NW = NW
        config.spectraM = spectraM
        config.MW = MW
        config.OS = OS
        
        return
    
    
    from .config import NB, NW, MW, OW
    from . import simu
    
    it = simu.it
    
    iow = 0
    imw=0
    image_iw = np.zeros(config.FS[&#39;NP&#39;])
    
    currCfTrue = args[0]     # declared in argument
                          
    for iw in range(config.NW):
        
        Modulation = config.FS[&#39;V2PM&#39;][iw,:,:]
        image_iw = np.abs(np.dot(Modulation,currCfTrue[iw,:]))
        
        simu.MacroImages[it,imw,:] += image_iw/OW
        
        iow += 1
        if iow == OW:
            imw+=1
            iow = 0
            
    if config.noise:
        from . import add_camera_noise
        simu.MacroImages[it,:,:] = add_camera_noise(simu.MacroImages[it,:,:])
    
    # if np.min(simu.MacroImages[it]) &lt; 0:
    #         print(f&#39;Negative image value at t={it}&#39;)
            
    # estimates coherences
    currCfEstimated = np.zeros([MW,NB])*1j
    for imw in range(MW):
        Demodulation = config.FS[&#39;MacroP2VM&#39;][imw,:,:]
        currCfEstimated[imw,:] = np.dot(Demodulation,simu.MacroImages[it,imw,:])
    
    
    return currCfEstimated





if __name__ == &#34;__main__&#34;:
    
    SPICAFS_PERFECT(init=True)
    
    import matplotlib.pyplot as plt
    import config
    plt.figure()
    plt.imshow(np.angle(config.FS[&#39;P2VM&#39;][0]))
    plt.show()
    
    directory = &#39;C:/Users/cpannetier/Documents/These/FringeTracking/SPICA-FT/V2PM_SPICA/&#39;
    V2PMfilename = &#39;MIRCX_ABCD_H_PRISM22_V2PM.fits&#39;
    fitsfile = directory+V2PMfilename
    SPICAFS_TRUE2(fitsfile=fitsfile,init=True,OS=10)
    import matplotlib.pyplot as plt
    import config
    plt.figure()
    plt.imshow(np.angle(config.FS[&#39;P2VM&#39;][0]))
    plt.show()
    
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="coh_lib.SPICA_FS.SPICAFS_PERFECT"><code class="name flex">
<span>def <span class="ident">SPICAFS_PERFECT</span></span>(<span>*args, T=1, init=False, spectra=[], spectraM=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Measures the coherent flux after simulating the image given by the real
oversampled coherence flux and adding noises on it.</p>
<h2 id="input">Input</h2>
<ul>
<li>If init: all the below parameters.</li>
<li>If not init: currCfTrue - Oversampled True Coherent Flux
[NW,NB]</li>
</ul>
<p>OUTPUT:
- currCfEstimated - Macrosampled measured coherent flux [MW,NB]</p>
<p>USED OBSERVABLES/PARAMETERS:
- config.FS
UPDATED OBSERVABLES/PARAMETERS:
- simu.MacroImages: [NT,MW,NIN] Estimated PD before subtraction of the reference
- simu.GD_: [NT,MW,NIN] Estimated GD before subtraction of the reference
- simu.CommandODL: Piston Command to send
[NT,NA]</p>
<h2 id="subroutines">Subroutines</h2>
<ul>
<li>coh_lib.add_camera_noise</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>ARRAY [NW,NB]</code></dt>
<dd>Expect oversampled coherent flux currCfTrue.</dd>
<dt><strong><code>init</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If True, initialize the parameters of the fringe sensor.
Needs spectra, spectraM
All this parameters are stored in the dictionnary config.FS.
Needs to be called before starting the simulation.
The default is False.</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>ARRAY [NW], necessary if INIT</code></dt>
<dd>Spectral microsampling. The default is [].</dd>
<dt><strong><code>spectraM</code></strong> :&ensp;<code>ARRAY [MW], necessary if INIT</code></dt>
<dd>Spectral macrosampling. The default is [].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>currCfEstimated</code></strong> :&ensp;<code>ARRAY [MW,NB]</code></dt>
<dd>Macrosampled measured coherent flux.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SPICAFS_PERFECT(*args,T=1, init=False, spectra=[], spectraM=[]):
    &#34;&#34;&#34;
    Measures the coherent flux after simulating the image given by the real 
    oversampled coherence flux and adding noises on it.
    
    INPUT:
        - If init: all the below parameters.
        - If not init: currCfTrue - Oversampled True Coherent Flux   [NW,NB]

    OUTPUT: 
        - currCfEstimated - Macrosampled measured coherent flux [MW,NB]

    USED OBSERVABLES/PARAMETERS:
        - config.FS
    UPDATED OBSERVABLES/PARAMETERS:
        - simu.MacroImages: [NT,MW,NIN] Estimated PD before subtraction of the reference
        - simu.GD_: [NT,MW,NIN] Estimated GD before subtraction of the reference
        - simu.CommandODL: Piston Command to send       [NT,NA]
        
    SUBROUTINES:
        - coh_lib.add_camera_noise

    Parameters
    ----------
    *args : ARRAY [NW,NB]
        Expect oversampled coherent flux currCfTrue.
    init : BOOLEAN, optional
        If True, initialize the parameters of the fringe sensor. 
        Needs spectra, spectraM
        All this parameters are stored in the dictionnary config.FS.
        Needs to be called before starting the simulation.
        The default is False.
    spectra : ARRAY [NW], necessary if INIT
        Spectral microsampling. The default is [].
    spectraM : ARRAY [MW], necessary if INIT
        Spectral macrosampling. The default is [].
        
    Returns
    -------
    currCfEstimated : ARRAY [MW,NB]
        Macrosampled measured coherent flux.

    &#34;&#34;&#34;


    from . import config
    
    if init:
        
        from .config import NA,NB
        
        # Created by the user here
        ich = np.array([[1,2], [1,3], [2,3], [2,4], [1,4], [1,5], [2,5], [1,6],[2,6],\
                  [3,6],[3,4],[3,5],[4,5],[4,6],[5,6]])
        
        config.FS[&#39;func&#39;] = SPICAFS_PERFECT
        config.FS[&#39;ich&#39;] = ich
        NG = np.shape(ich)[0]       # should always be equal to NIN
        
        # Classic balanced ABCD modulation of each baseline
        
        M_ABCD = ABCDmod()          # A2P ABCD modulation
        NMod = len(M_ABCD)          # Number of modulations for each baseline
        config.FS[&#39;Modulations&#39;] = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]
        NP = NMod*NG
        
        config.FS[&#39;NMod&#39;] = NMod
        config.FS[&#39;NP&#39;] = NP
        config.FS[&#39;T&#39;] = T
        
        # Build the A2P of SPICA
        
        M_spica = np.zeros([NP,NA])*1j
        for ig in range(NG):
            for ia in range(2):
                M_spica[NMod*ig:NMod*(ig+1),ich[ig,ia]-1] = M_ABCD[:,ia]
        
        # Build the V2P and P2V matrices
        
        V2PM = np.zeros([NP,NB])*1j
        for ip in range(NP):
            for ia in range(NA):
                for iap in range(NA):
                    k = ia*NA+iap
                    V2PM[ip, k] = M_spica[ip,ia]*np.transpose(np.conjugate(M_spica[ip,iap]))
        
        P2VM = np.linalg.pinv(V2PM)    
        
        NW, MW = len(spectra), len(spectraM)
        
        # Noise maps
        config.FS[&#39;imsky&#39;]=np.zeros([MW,NP])                # Sky background (bias)
        config.FS[&#39;sigsky&#39;]=np.random.randn(MW,NP)        # Dark noise (1rms)
        
        # Resolution of the fringe sensor
        midlmbda = np.mean(spectra)
        deltalmbda = (np.max(spectra) - np.min(spectra))/MW
        config.FS[&#39;R&#39;] = midlmbda/deltalmbda
        
        config.FS[&#39;V2PM&#39;] = np.repeat(V2PM[np.newaxis,:,:],NW,0)
        config.FS[&#39;P2VM&#39;] = np.repeat(P2VM[np.newaxis,:,:],NW,0)
        config.FS[&#39;MacroP2VM&#39;] = np.repeat(P2VM[np.newaxis,:,:],MW,0)
    
        return
    
    from .config import NA, NB, NW, MW, OW
    from . import simu
    
    it = simu.it
    
    iow = 0
    imw=0
    image_iw = np.zeros(config.FS[&#39;NP&#39;])
    
    currCfTrue = args[0]     # declared in argument
    currCfTrue *= config.FS[&#39;T&#39;]
                      
        
    for iw in range(config.NW):
        
        Modulation = config.FS[&#39;V2PM&#39;][iw,:,:]
        image_iw = np.abs(np.dot(Modulation,currCfTrue[iw,:]))
        
        simu.MacroImages[it,imw,:] += image_iw/OW
        
        iow += 1
        if iow == OW:
            imw+=1
            iow = 0      

    
    if config.noise:
        from .skeleton import addnoiseADU
        simu.MacroImages[it,:,:] = addnoiseADU(simu.MacroImages[it,:,:])
    
    # if np.min(simu.MacroImages[it]) &lt; 0:
    #     print(f&#39;Negative image value at t={it}&#39;)
    
    # estimates coherences
    currCfEstimated = np.zeros([MW,NB])*1j
    for imw in range(MW):
        Demodulation = config.FS[&#39;MacroP2VM&#39;][imw,:,:]
        currCfEstimated[imw,:] = np.dot(Demodulation,simu.MacroImages[it,imw,:])
    
    return currCfEstimated</code></pre>
</details>
</dd>
<dt id="coh_lib.SPICA_FS.SPICAFS_TRUE"><code class="name flex">
<span>def <span class="ident">SPICAFS_TRUE</span></span>(<span>*args, init=False, T=0.5, wlinfo=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Init: Reads the fitsfile and load the different parameters NP, ich, T,
Modulations, spectra into the config module.
Run: Takes true current Coherent Flux, calculates the image, add noise
and estimates noisy Coherent Flux.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>
<ul>
<li>if init: expect fitsfile: string
FITS file of the SPICA's fringe sensor V2PM</li>
<li>if run: expect currCfTrue: ARRAY [NW,NB]</li>
</ul>
</dd>
<dt><strong><code>init</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If True, initialising mode. The default is False.
If False, running mode.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Transmission of the CHIP. The default is 1.</dd>
<dt><strong><code>wlinfo</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>If True, returns the extremal wavelength. The default is False.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>if OS given: oversample the macro spectra with the OS factor.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>The oversampling must be integer. Given: {OS}.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>If Init: empty</code></dt>
<dd>&nbsp;</dd>
<dt><code>If wlinfo: TUPLE</code></dt>
<dd>Extremal wavelengths.</dd>
<dt><code>If Run: ARRAY [MW,NB]</code></dt>
<dd>Estimated macro coherent flux.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SPICAFS_TRUE(*args, init=False, T=0.5, wlinfo=False, **kwargs):
    &#34;&#34;&#34;
    Init: Reads the fitsfile and load the different parameters NP, ich, T, 
    Modulations, spectra into the config module.
    Run: Takes true current Coherent Flux, calculates the image, add noise 
    and estimates noisy Coherent Flux.

    Parameters
    ----------
    *args : TYPE
        - if init: expect fitsfile: string
        FITS file of the SPICA&#39;s fringe sensor V2PM
        - if run: expect currCfTrue: ARRAY [NW,NB]
        
    init : BOOLEAN, optional
        If True, initialising mode. The default is False.
        If False, running mode.
    T : float, optional
        Transmission of the CHIP. The default is 1.
    wlinfo : float, optional
        If True, returns the extremal wavelength. The default is False.
    **kwargs : TYPE
        if OS given: oversample the macro spectra with the OS factor.

    Raises
    ------
    Exception
        The oversampling must be integer. Given: {OS}.

    Returns
    -------
    If Init: empty
    If wlinfo: TUPLE
        Extremal wavelengths.
    If Run: ARRAY [MW,NB]
        Estimated macro coherent flux.

    &#34;&#34;&#34;

    # print(config.FS)
    # config?
    
    if wlinfo:
        
        fitsfile = kwargs[&#39;fitsfile&#39;]
        
        hdul = fits.open(fitsfile)
        
        # detectordico=hdul[1].data       # Base and ABCD positions information
        wldico = hdul[2].data           # Wavelength information
    
        # We pick up the calibrated wavelengths and corresponding wavebands
        spectraM = wldico[&#39;EFF_WAVE&#39;]*1e6       # Convert to [Âµm]
        wavebandv2pm = np.abs(wldico[&#39;EFF_BAND&#39;])*1e6   # Convert to [Âµm]
    
        minspectra = spectraM[0]-wavebandv2pm[0]/2
        maxspectra = spectraM[-1]+wavebandv2pm[-1]/2
        
        print(f&#39;The sensor passband is from {minspectra}Âµm to {maxspectra}Âµm.&#39;)
        
        return minspectra, maxspectra
    
    if init:
        
        from .config import NW,MW,spectra
        fitsfile = kwargs[&#39;fitsfile&#39;]
        
        hdul = fits.open(fitsfile)
        
        detectordico=hdul[1].data       # Base and ABCD positions information
        wldico = hdul[2].data           # Wavelength information
        v2pmdico = hdul[3].data         # contains the V2PM
            
        # hdul.close()
        config.FS[&#39;func&#39;] = SPICAFS_TRUE
        # We read the interferometric channels indices and modulation patterns
        ichraw = detectordico[&#39;BEAM_INDEX&#39;]
        Modulations = list(detectordico[&#39;ABCD_INDEX&#39;][:4])
        NMod = len(Modulations)
        NP = len(ichraw)
        
        config.FS[&#39;Modulations&#39;] = Modulations
        config.FS[&#39;NMod&#39;] = NMod
        config.FS[&#39;NP&#39;] = NP
        config.FS[&#39;ich&#39;] = np.array([(ichraw[i]) for i in range(0,NP,NMod)])
        config.FS[&#39;T&#39;] = T
        
        # We pick up the calibrated wavelengths and corresponding wavebands
        spectraM = wldico[&#39;EFF_WAVE&#39;]*1e6       # Convert to [Âµm]
        wavebandv2pm = np.abs(wldico[&#39;EFF_BAND&#39;])*1e6   # Convert to [Âµm]
            
        # Spectral resolution of the first spectral channel
        config.FS[&#39;R&#39;] = spectraM[0]/wavebandv2pm[0]
        
        # Number of wavelengths in V2PM and in the reference spectra
        MW = len(spectraM)

        # Noise maps
        config.FS[&#39;imsky&#39;]=np.zeros([MW,NP])             # Sky background (bias)
        config.FS[&#39;sigsky&#39;]=np.random.randn([MW,NP])       # Dark Noise [ron=1rms]

        # Now we pike up the P2VM and sort it according to wavelengths
        V2PM = v2pmdico[&#39;V2PM&#39;]
        
        if spectraM[0] &gt; spectraM[-1]:      # First wavelength higher than last wl
            V2PM = np.flip(V2PM,0)
            spectraM = np.flip(spectraM)
            
        
        # NP = np.shape(V2PM)[1]
        NB = np.shape(V2PM)[2]
        
        # print(config.FS)
        # ich=[]
        # NQ = 2
        # NIN = 2*NQ      
        # for ip in range(NP//4):      # We assume ABCD are logically sorted (ABCD)
        #     ich.append(list(detectordico[&#39;BEAM_INDEX&#39;][4*ip]-1))
        # ich = np.array(ich)+1
        
        # From the undersampled V2PM we calculates the corresponding P2VM and build 
        # the oversampled V2PM and P2VM
        
        if &#39;OS&#39; in kwargs.keys():
            OS = kwargs[&#39;OS&#39;]
            if not isinstance(kwargs[&#39;OS&#39;],int):
                raise Exception(f&#39;The oversampling must be integer. Given: {OS}&#39;)
            MacroV2PM = V2PM
            # for imw in range(MW):
                
            spectra,spectraM = ct.oversample_wv(spectraM,OS,
                                             spectraband=wavebandv2pm,
                                             mode=&#39;linear_wl&#39;)
            NW = len(spectra)
            MicroV2PM = np.zeros([NW,NP,NB])*1j
            # MicroP2VM = np.zeros([NW,NB,NP])*1j
            iot,imw = 0,0
            for iw in range(NW):
                if iot==OS:
                    imw+=1
                    iot=0
                MicroV2PM[iw] = MacroV2PM[imw]
            
            MicroV2PM, MicroP2VM = ct.coh__GRAV2simu(MicroV2PM)
            
            config.MW = len(spectraM)

            config.FS[&#39;V2PM&#39;] = MicroV2PM
            config.FS[&#39;P2VM&#39;] = MicroP2VM
            
            MacroP2VM = np.ones([MW,NB,NP])*1j
            for imw in range(MW):
                MacroP2VM[imw] = MicroP2VM[imw*OS]
            
            config.FS[&#39;MacroP2VM&#39;] = MacroP2VM
            
            # Changes the oversampled spectra and initializes the macro spectra
            config.spectra = spectra
            config.NW = NW
            config.spectraM = spectraM
            config.MW = MW

            return spectra, spectraM
            
        else:
            MicroV2PM = np.zeros([NW,NP,NB])*1j
            MicroP2VM = np.zeros([NW,NB,NP])*1j
            newspectra=np.zeros(NW)
            bands=[[]]                  # will stock the wavelength of each band
            for imw in range(1,MW):
                bands.append([])
            
            k=0    
            for iw in range(NW):
                # Test if the reference wavelength is in one of the FS spectral channels
                for imw in range(MW):
                    is_between = spectraM[imw]-wavebandv2pm[imw]/2 &lt;= spectra[iw] &lt;= \
                        spectraM[imw]+wavebandv2pm[imw]/2
                    if is_between:      # If it is, we add it to the new p2vm
                        MicroV2PM[k] = V2PM[imw]
                        newspectra[k] = spectra[iw]          # The wavelength is added to the final spectra
                        bands[imw].append(k)
                        k+=1
                        break
            
            # We adapt it to the simulation formalism and generate pseudo-inverse matrix
            MicroV2PM, MicroP2VM = ct.coh__GRAV2simu(MicroV2PM[:k])
            
            newspectra = newspectra[:k]
            NW = k
            MicroV2PM = MicroV2PM[:k]
            MicroP2VM = MicroP2VM[:k]
            
            r = NW%MW
            if r!=0:       # in order to have an integer oversampling
                to_delete = []          # Stock the indices of elements to remove
                for i in range(r):
                    bandwidths = [len(band) for band in bands]
                    maxband=np.argmax(bandwidths)
                    to_delete.append(bands[maxband].pop(-1))
                    
                newspectra = np.delete(newspectra,to_delete)
                MicroV2PM = np.delete(MicroV2PM, to_delete,axis=0)
                MicroP2VM = np.delete(MicroP2VM, to_delete,axis=0)
                
                NW = len(newspectra)
                spectra = newspectra
                
            MacroP2VM = np.zeros([MW,NB,NP])*1j
            for imw in range(MW):
                iw = bands[imw][0]
                MacroP2VM[imw] = MicroP2VM[iw]
    
    
            config.FS[&#39;V2PM&#39;] = MicroV2PM
            config.FS[&#39;P2VM&#39;] = MicroP2VM
            config.FS[&#39;MacroP2VM&#39;] = MacroP2VM
            
            # Changes the oversampled spectra and initializes the macro spectra
            config.spectra = newspectra
            config.NW = NW
            config.spectraM = spectraM
            config.MW = MW
        
            return
    
    from .config import NB, NW, MW, OW
    from . import simu
    
    it = simu.it
    
    iow = 0
    imw=0
    image_iw = np.zeros(config.FS[&#39;NP&#39;])
    
    currCfTrue = args[0]     # declared in argument
    currCfTrue *= config.FS[&#39;T&#39;]**2             # Transmission of the CHIP                      
    for iw in range(config.NW):
        
        Modulation = config.FS[&#39;V2PM&#39;][iw,:,:]
        image_iw = np.abs(np.dot(Modulation,currCfTrue[iw,:]))
        
        simu.MacroImages[it,imw,:] += image_iw/OW
        
        iow += 1
        if iow == OW:
            imw+=1
            iow = 0
            
    if config.noise:
        from .skeleton import addnoiseADU
        simu.MacroImages[it,:,:] = addnoiseADU(simu.MacroImages[it,:,:])
    
    # if np.min(simu.MacroImages[it]) &lt; 0:
    #         print(f&#39;Negative image value at t={it}&#39;)
            
    # estimates coherences
    currCfEstimated = np.zeros([MW,NB])*1j
    for imw in range(MW):
        Demodulation = config.FS[&#39;MacroP2VM&#39;][imw,:,:]
        currCfEstimated[imw,:] = np.dot(Demodulation,simu.MacroImages[it,imw,:])
    
    
    return currCfEstimated</code></pre>
</details>
</dd>
<dt id="coh_lib.SPICA_FS.SPICAFS_TRUE2"><code class="name flex">
<span>def <span class="ident">SPICAFS_TRUE2</span></span>(<span>*args, init=False, OS=10, wlinfo=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the fits file of SPICA's fringe sensor and returns its V2PM, P2VM and
interferometric channels.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fitsfile</code></strong> :&ensp;<code>string</code></dt>
<dd>FITS file of the SPICA's fringe sensor V2PM</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>V2PM</code></strong> :&ensp;<code>[NW,NP,NB] floats</code></dt>
<dd>Visibility to Pixels matrix</dd>
<dt><strong><code>P2VM</code></strong> :&ensp;<code>[NW, NB, NP] floats</code></dt>
<dd>Pixel to Visibility matrix</dd>
<dt><strong><code>ich</code></strong> :&ensp;<code>[NP, 2] int
(it might change later for ABCD sorting info -&gt; [NP,3])</code></dt>
<dd>Interferometric channel sorting</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SPICAFS_TRUE2(*args, init=False, OS=10, wlinfo=False, **kwargs):
    
    &#34;&#34;&#34;
    Read the fits file of SPICA&#39;s fringe sensor and returns its V2PM, P2VM and 
    interferometric channels.

    Parameters
    ----------
    fitsfile: string
        FITS file of the SPICA&#39;s fringe sensor V2PM

    Returns
    -------
    V2PM : [NW,NP,NB] floats
        Visibility to Pixels matrix
    P2VM : [NW, NB, NP] floats
        Pixel to Visibility matrix
    ich : [NP, 2] int  (it might change later for ABCD sorting info -&gt; [NP,3])
        Interferometric channel sorting
    &#34;&#34;&#34;
    
    if wlinfo:
        
        fitsfile = kwargs[&#39;fitsfile&#39;]
        
        hdul = fits.open(fitsfile)
        
        # detectordico=hdul[1].data       # Base and ABCD positions information
        wldico = hdul[2].data           # Wavelength information
    
        # We pick up the calibrated wavelengths and corresponding wavebands
        spectraM = wldico[&#39;EFF_WAVE&#39;]*1e6       # Convert to [Âµm]
        wavebandv2pm = np.abs(wldico[&#39;EFF_BAND&#39;])*1e6   # Convert to [Âµm]
    
        minspectra = spectraM[0]-wavebandv2pm[0]/2
        maxspectra = spectraM[-1]+wavebandv2pm[-1]/2
        
        print(f&#39;The sensor passband is from {minspectra}Âµm to {maxspectra}Âµm.&#39;)
        
        return minspectra, maxspectra
    
    if init:
        
        # from .config import NW,spectra
        fitsfile = kwargs[&#39;fitsfile&#39;]
        
        hdul = fits.open(fitsfile)
        
        detectordico=hdul[1].data       # Base and ABCD positions information
        wldico = hdul[2].data           # Wavelength information
        v2pmdico = hdul[3].data         # contains the V2PM
            
        # hdul.close()
        
        # We read the interferometric channels indices and modulation patterns
        ichraw = detectordico[&#39;BEAM_INDEX&#39;]
        Modulations = list(detectordico[&#39;ABCD_INDEX&#39;][:4])
        NMod = len(Modulations)
        NP = len(ichraw)
        
        config.FS[&#39;Modulations&#39;] = Modulations
        config.FS[&#39;NMod&#39;] = NMod
        config.FS[&#39;NP&#39;] = NP
        config.FS[&#39;ich&#39;] = np.array([(ichraw[i]) for i in range(0,NP,NMod)])
        
        # We pick up the calibrated wavelengths and corresponding wavebands
        spectraM = wldico[&#39;EFF_WAVE&#39;]*1e6               # Convert to [Âµm]
        wavebandv2pm = np.abs(wldico[&#39;EFF_BAND&#39;])*1e6   # Convert to [Âµm]
            
        # Spectral resolution of the first spectral channel
        config.FS[&#39;R&#39;] = spectraM[0]/wavebandv2pm[0]
        
        # Number of wavelengths in V2PM and in the reference spectra
        MW = len(spectraM)

        # Now we pike up the P2VM and sort it according to wavelengths
        V2PM = v2pmdico[&#39;V2PM&#39;]
        
        if spectraM[0] &gt; spectraM[-1]:      # First wavelength higher than last wl
            V2PM = np.flip(V2PM,0)
            spectraM = np.flip(spectraM)
            
        
        # NP = np.shape(V2PM)[1]
        NB = np.shape(V2PM)[2]
        
        
        # ich=[]
        # NQ = 2
        # NIN = 2*NQ      
        # for ip in range(NP//4):      # We assume ABCD are logically sorted (ABCD)
        #     ich.append(list(detectordico[&#39;BEAM_INDEX&#39;][4*ip]-1))
        # ich = np.array(ich)+1
        
        # From the undersampled V2PM we calculates the corresponding P2VM and build 
        # the oversampled V2PM and P2VM
        
        
        if not isinstance(OS,int):
            raise f&#39;The oversampling must be integer. Given: {OS}&#39;
        
        MacroV2PM = V2PM
        spectra,spectraM = ct.oversample_wv(spectraM,OS,
                                             spectraband=wavebandv2pm,
                                             mode=&#39;linear_wl&#39;)
        
        NW = len(spectra)

        MicroV2PM = np.zeros([NW,NP,NB])*1j
        iot,imw = 0,0
        for iw in range(NW):
            if iot==OS:
                imw+=1
                iot=0
            MicroV2PM[iw] = MacroV2PM[imw]
        
        MicroV2PM, MicroP2VM = ct.coh__GRAV2simu(MicroV2PM)
        
        config.FS[&#39;V2PM&#39;] = MicroV2PM
        config.FS[&#39;P2VM&#39;] = MicroP2VM 
        config.spectra = spectra
        config.NW = NW
        config.spectraM = spectraM
        config.MW = MW
        config.OS = OS
        
        return
    
    
    from .config import NB, NW, MW, OW
    from . import simu
    
    it = simu.it
    
    iow = 0
    imw=0
    image_iw = np.zeros(config.FS[&#39;NP&#39;])
    
    currCfTrue = args[0]     # declared in argument
                          
    for iw in range(config.NW):
        
        Modulation = config.FS[&#39;V2PM&#39;][iw,:,:]
        image_iw = np.abs(np.dot(Modulation,currCfTrue[iw,:]))
        
        simu.MacroImages[it,imw,:] += image_iw/OW
        
        iow += 1
        if iow == OW:
            imw+=1
            iow = 0
            
    if config.noise:
        from . import add_camera_noise
        simu.MacroImages[it,:,:] = add_camera_noise(simu.MacroImages[it,:,:])
    
    # if np.min(simu.MacroImages[it]) &lt; 0:
    #         print(f&#39;Negative image value at t={it}&#39;)
            
    # estimates coherences
    currCfEstimated = np.zeros([MW,NB])*1j
    for imw in range(MW):
        Demodulation = config.FS[&#39;MacroP2VM&#39;][imw,:,:]
        currCfEstimated[imw,:] = np.dot(Demodulation,simu.MacroImages[it,imw,:])
    
    
    return currCfEstimated</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coh_lib" href="index.html">coh_lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="coh_lib.SPICA_FS.SPICAFS_PERFECT" href="#coh_lib.SPICA_FS.SPICAFS_PERFECT">SPICAFS_PERFECT</a></code></li>
<li><code><a title="coh_lib.SPICA_FS.SPICAFS_TRUE" href="#coh_lib.SPICA_FS.SPICAFS_TRUE">SPICAFS_TRUE</a></code></li>
<li><code><a title="coh_lib.SPICA_FS.SPICAFS_TRUE2" href="#coh_lib.SPICA_FS.SPICAFS_TRUE2">SPICAFS_TRUE2</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>