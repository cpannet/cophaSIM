<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>coh_lib.skeleton API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coh_lib.skeleton</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
#        import pdb; pdb.set_trace()

import os
import time

import numpy as np
# import cupy as cp # NumPy-equivalent module accelerated with NVIDIA GPU  

import matplotlib.pyplot as plt
from scipy import interpolate 
import pandas as pd
from importlib import import_module
from importlib import reload  # Python 3.4+ only.
import datetime

from . import coh_tools
from . import config

from astropy.io import fits

from .FS_DEFAULT import *
from .decorators import *

# os.chdir(&#39;C:/Users/cpannetier/Documents/These/FringeTracking/Python/coh_pack/coh_lib/&#39;)

# Change the display font
# plt.rc(&#39;font&#39;, **{&#39;family&#39; : &#39;serif&#39;, &#39;serif&#39; : [&#39;Computer Modern Roman&#39;]})
# plt.rc(&#39;text&#39;, usetex = True)

def initialize(Interferometer, ObsFile, DisturbanceFile, NT=512, OT=1, MW = 5, ND=1, 
             spectra = [], spectraM=[],PDspectra=0,
             spectrum = [], mode = &#39;search&#39;,
             fs=&#39;default&#39;, TELref=0, FSfitsfile=&#39;&#39;, R = 0.5, dt=1,sigsky=[],imsky=[],
             ft = &#39;integrator&#39;, state = 0,
             noise=False,ron=0, qe=0.5, phnoise = 0, G=1, enf=1.5, M=1,
             seedph=100, seedron=100, seeddist=100,
             starttracking=100, latencytime=0,
             **kwargs):
    
    &#34;&#34;&#34;
    NAME: initialize - Initializes a structure to simulate an interferometer by \
    COH_LIB
    
    PURPOSE:
        This procedure creates the coh structure and intializes it with the \
        FS-given information.
        Other user-information are filled with coh_user.
        
    OUTPUT:
        coh: dictionnary which defines the interferometric setup.
        
    INPUTS:
        MANDATORY:
        NA : (integer) Number of input beams
        NW  : (integer) Number of waves in the simulation
        MW  : (integer) Number of macro-waves (detector spectral channels)
        spectra   : (float array) Set of reference wavelengths
        
    OPTIONAL:
        fs : (string) the name of the Fringe Sensor procedure coh_fs_name
        FSfitsfile : (string) the name of the experimental V2PM fitsfile
        mode : the algorithm (pd, gd,...)
        lmbda  : (float array) Value of wavelengths
        spectrum   : ([NB,NW] float array) XX TODO How to weight waveNUMBERS 
        on the corresponding baseline
        filename : (string) Filename for automatic saves
        step_resp: (FLTARR(xT)) ODL response to a Heaviside step
        /openloop : to simulate an openloop with coh_ft_openloop
        [DEFAULT]=closed loop with coh_ft_integrator
        random : random start for the pseudo-random sequence
        version : (optional input) prints version number before execution. 
        help    : (optional input) prints the documentation and exits.
        F : Amplification factor of an EM-CCD camera, by default = 1 
    
EXAMPLE:
    See unitary test at the end of file 
    
RESTRICTIONS:
    This code is copyright (c) ONERA, 2009. 
    
SOURCE:
    This code is born from Choquet and Cassaing&#39;s IDL code developped at ONERA\
    (2009)
    
&#34;&#34;&#34;
        

    &#34;&#34;&#34;
    LOAD INTERFEROMETER INFOS
    &#34;&#34;&#34;

    filepath = Interferometer
    if not os.path.exists(filepath):
        raise Exception(f&#34;{filepath} doesn&#39;t exist.&#34;)
    
    with fits.open(filepath) as hdu:
        ArrayParams = hdu[0].header
        NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
        TelData = hdu[1].data
        BaseData = hdu[2].data
        
        TelNames = TelData[&#39;TelNames&#39;]
        TelCoordinates = TelData[&#39;TelCoordinates&#39;]
        TelTransmissions = TelData[&#39;TelTransmissions&#39;]
        TelSurfaces = TelData[&#39;TelSurfaces&#39;]
        BaseNames = BaseData[&#39;BaseNames&#39;]
        BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
        
        
    # Redundant number of baselines
    NB = NA**2
    
    # Non-redundant number of Closure Phase
    NC = int((NA-2)*(NA-1))
   
    NP = config.FS[&#39;NP&#39;]
    
# TEMPORAL PARAMETERS
    
    MT=int(NT/OT)                        # Total number of temporal samples
    timestamps = np.arange(NT)*dt       # Time sampling in [ms]
    
# SPECTRAL PARAMETERS
    
    if len(spectra) == 0:
        raise ValueError(&#39;Lambda array required&#39;)      # Array which contains our signal&#39;s 
                                            # pseudo wavenumbers (1/lambda)
    
    NW = len(spectra)
    
    OW = int(NW/MW)                         # Oversampling factor
    if len(spectraM) == 0:
        spectraM = np.array([np.mean(spectra[i*OW:(i+1)*OW]) for i in range(MW)])
        
        
    if PDspectra==0:
        PDspectra = np.mean(spectraM) 
        

    if type(qe) == float:
        qe=qe*np.ones(MW)

    # Disturbance Pattern
    
    OW = int(NW/MW)
    if OW != NW/MW:
        raise ValueError(&#39;Oversampling might be integer.&#39;)
    

    # CONFIG PARAMETERS
    
    dyn=0.                                  # to be updtated later by FS (for ex via coh_algo)
      
    if imsky == []:
        imsky = np.zeros([MW,NP])               # Sky background
    if sigsky == []:
        sigsky = np.zeros([MW,NP])              # Darknoise image


    # Observation parameters
    config.ObservationFile = ObsFile
    config.DisturbanceFile = DisturbanceFile
    config.NA=NA
    config.NB=NB
    config.NC=NC
    config.NIN=NIN
    config.MT=MT
    config.NT=NT
    config.OT=OT
    config.timestamps = timestamps
 
    # Fringe Sensor parameters
    config.NW=NW
    config.MW=MW
    config.OW=OW
    config.NX=0
    config.NY=0
    config.ND=ND
    config.dt=dt                    # ms

    # Noises
    config.noise=noise
    config.ron=ron
    config.FS[&#39;sigsky&#39;] = config.FS[&#39;sigsky&#39;]*ron
    config.phnoise=phnoise
    config.G = G
    config.enf=enf
    config.M=M

    if latencytime == 0:
        config.latency = config.dt
    else:
        config.latency = round(latencytime/config.dt)
    
    
    # Random Statemachine seeds
    config.seedph=seedph
    config.seedron=seedron
    config.seeddist=seeddist
    
    # Fringe tracker
    config.starttracking = starttracking
    
    
    # Source description
    config.spectra=spectra
    config.spectraM=spectraM
    config.PDspectra=PDspectra
    config.dyn=dyn
    
    # Simulation parameters
    # config.SimuFilename=SimuFilename        # Where to save the data
    config.TELref=TELref             # For display only: reference delay line
    
    config.ich = np.zeros([NIN,2])
    for ia in range(NA):
        for iap in range(ia+1,NA):
            config.ich[coh_tools.posk(ia,iap,NA)] = [ia,iap]
    
    config.CPindex = np.zeros([NC,3])
    for ia in range(NA):
        for iap in range(ia+1,NA):
            for iapp in range(iap+1,NA):
                config.CPindex[coh_tools.poskfai(ia,iap,iapp,NA)] = [ia,iap,iapp]

    return 


def MakeAtmosphereCoherence(filepath, InterferometerFile, overwrite=False,
                            spectra=[], RefLambda=0, NT=1000,dt=1,
                            ampl=0, seed=100, dist=&#39;step&#39;, startframe = 10, 
                            f_fin=200,
                            r0=0.15,t0=10, L0=25, direction=0, d=1,
                            debug=False, tel=0, highCF=True,**kwargs):
    &#39;&#39;&#39;
    CREATES or LOAD a disturbance scheme INTO or FROM a FITSFILE.
    If filepath is empty, raise error.
    If filepath already exists and overwrite is False: 
        the disturbance pattern is loaded and its Coherent Flux is returned.
    If filepath doesn&#39;t exist or overwrite is True:
        a new disturbance pattern is created and saved to filepath according to
        the parameters.
    
    INPUTS:
        - coh: dictionnary which defines the interferometer: contains NA = number of apertures
        - ampl: amplitude of the piston disturbance
        - dist: disturbance model chosen
            - &#39;scan&#39;: a simple case disturbance to begin
            - &#39;random&#39;: a randomly generated set of pistons with modelisation:
                - if highCF=True: high cutoff frequency 
                - if highCF=False: no high cutoff frequency
        - startframe: disturbance starting frame
    
    FITS STRUCTURE:
        -PRIMARY:
            - HEADER:
                hdr[&#39;TYPE&#39;] =dist
                hdr[&#39;AMPL&#39;] = ampl
                hdr[&#39;TEL&#39;] = tel
        - HDU1: [ImageHDU] RealCf
        - HDU2: [ImageHDU] ImagCf
        - HDU3: [ImageHDU] Piston
        - HDU4: [ImageHDU] Transmission
        - if random:
            -HDU5: [ImageHDU] DisturbancePSD
            -HDU6: [ImageHDU] FreqSampling
        
    OUTPUT:
        - CoherentFlux: [NTxNWxNB] the coherence matrix resulting from all pairs of apertures
        - OPTIONAL PistonDisturbance: [NTxNWxNB] pistons
        - OPTIONAL TransmissionDisturbance: [NTxNWxNB] amplitudes
    &#39;&#39;&#39;
    
    import os
    from astropy.io import fits

    if len(filepath) == 0:
        raise Exception(&#39;No disturbance filepath given.&#39;)
        
    elif os.path.exists(filepath):
        print(f&#39;Disturbance file {filepath} exists.&#39;)
        if overwrite:
            os.remove(filepath)
            print(f&#39;Parameter OVERWRITE is {overwrite}.&#39;)
        else:
            print(f&#39;Parameter OVERWRITE is {overwrite}. Loading the disturbance scheme.&#39;)
            
            with fits.open(filepath) as hdu:
                CoherentFlux = hdu[&#39;RealCf&#39;].data + hdu[&#39;ImagCf&#39;].data*1j
                timestamps = hdu[&#39;TimeSampling&#39;].data[&#39;timestamps&#39;]
                spectra = hdu[&#39;SpectralSampling&#39;].data[&#39;spectra&#39;]
                
            return CoherentFlux, timestamps, spectra
       
    else:
        print(f&#39;Creating the disturbance pattern and saving it in {filepath}&#39;)
        

    if not os.path.exists(InterferometerFile):
        raise Exception(f&#34;{InterferometerFile} doesn&#39;t exist.&#34;)
    
    with fits.open(InterferometerFile) as hdu:
        ArrayParams = hdu[0].header
        NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
        ArrayName = ArrayParams[&#39;NAME&#39;]
        # TelData = hdu[1].data
        BaseData = hdu[2].data
        
        # TelNames = TelData[&#39;TelNames&#39;]
        # TelCoordinates = TelData[&#39;TelCoordinates&#39;]
        # BaseNames = BaseData[&#39;BaseNames&#39;]
        BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
    
    NB = NA**2
    NW = len(spectra)
    Lc = np.abs(1/(spectra[0]-spectra[1]))      # Coherence length
    
    if not RefLambda:
        RefLmbda = np.mean(spectra)
    
    obstime = NT*dt                     # Observation time [ms]
    timestamps = np.arange(NT)*dt        # Time sampling [ms]
    
    PistonDisturbance = np.zeros([NT,NA])
    TransmissionDisturbance = np.ones([NT,NW,NA])
    lmbdamin = 1/np.max(spectra)
    
    # np.random.seed(seed)

    if dist == &#39;coherent&#39;:
        print(&#39;No piston&#39;)
        
    elif dist == &#39;step&#39;:
        if tel &lt;=0:
            itel=0
        else:
            itel = tel-1
        PistonDisturbance[startframe:,itel] = ampl*np.ones(NT-startframe)
        
    elif dist == &#39;pair&#39;:
        PistonDisturbance[startframe:,:2] = ampl*np.ones([NT-startframe,2])
        
    elif dist == &#39;kstep&#39;:
        T = int(0.8*NT/NA)
        t = int(0.5*T)
        for ia in range(NA):
            PistonDisturbance[startframe+T*ia:startframe+T*ia+t,ia] = ampl*np.ones(t)
        
    # elif dist == &#39;scan&#39;:
    #     for ia in range(NA):
    #         PistonDisturbance[:,ia] = ampl*(-1)**(ia+1)*((0.5*ia+np.arange(NT))/NT-0.5)  # pistons in µm
    
    elif dist == &#39;slope&#39;:
        PistonDisturbance[:,1] = 0.2+np.arange(NT)/NT * ampl
        
    # The first telil sees a range of piston from -Lc to Lc
    elif dist == &#39;browse&#39;:
        PistonDisturbance[:,1] = (np.arange(NT)/NT - 1/2) * 2*Lc
    
    elif dist == &#39;random&#39;:
        
        if &#39;old&#39; in kwargs.keys():
            rmsPiston = ampl/np.sqrt(2)
            
            freq = np.fft.fftshift(np.fft.fftfreq(NT,d=dt*1e-3))
            freqfft=freq
            Fc = 100            # Maximal frequency of the atmosphere
            Fmax = np.max(freq)
            Nc = int(Fc*NT/2/Fmax)
            filtre = np.zeros(NT)
    
            # Atmospheric disturbance from Conan et al 1995
            for i in range(NT):
                if freq[i] &lt; 0.02:
                    filtre[i] = 0
                elif freq[i] &gt;= 0.02 or freq[i] &lt; 3:    # Low frequencies regime 
                    filtre[i] = freq[i]**(-4/3)
                else:                                   # High frequencies regime
                    filtre[i] = freq[i]**(-8.5/3)
            print(Fmax,freq[1]-freq[0],dt*1e-3,NT)
            filtre = filtre/np.max(filtre)
    
            if tel:                     # Disturbances on only one pupil
                itel = tel - 1
                dsp = np.fft.fftshift(np.fft.fft(np.random.randn(NT)))
                
                newdsp = dsp*filtre
                motif = np.real(np.fft.ifft(np.fft.ifftshift(newdsp)))
    
                PistonDisturbance[:,itel]= rmsPiston*motif/np.std(motif)/3
            
            else:
                for ia in range(NA):
                    
                    dsp = np.fft.fftshift(np.fft.fft(np.random.randn(NT)))
                    newdsp = dsp*filtre
                    motif = np.real(np.fft.ifft(np.fft.ifftshift(newdsp)))
        
                    PistonDisturbance[:,ia]= rmsPiston*motif/np.std(motif)/3

            # simu.DisturbancePSD = np.abs(newdsp[freqfft&gt;=0])**2    # Save the PSD of the last disturbance for example
            # simu.FreqSampling = freqfft[freqfft&gt;=0]

        else:           # Inspired from Conan but more smooth
            if &#39;baselines&#39; in kwargs.keys():
                baselines = kwargs[&#39;baselines&#39;]
            else:
                _,_,basedist,coords = coh_tools.get_array(config.Name, getcoords=True)
                
                
                
                baselines = np.zeros(NIN)
                for ia in range(NA):
                    for iap in range(ia+1,NA):
                        ib=coh_tools.posk(ia,iap,NA)
                        baselines[ib] = np.abs(basedist[ia*NA+iap])
                
                baselines = np.linalg.norm(BaseCoordinates, axis=1)
            
            V = 0.31*r0/t0*1e3              # Average wind velocity in its direction [m/s]
            L0 = L0                         # Outer scale [m]
            direction = direction           # Orientation from the North [deg] (positive toward East)
            d = d                           # Telescopes diameter [m]
                
            if ampl==0:
                wl_r0 = 0.55                # Wavelength at which r0 is defined
                ampl = np.sqrt(6.88*(L0/r0)**(5/3))*wl_r0/(2*np.pi)    # microns
                rmsPiston = ampl/np.sqrt(2)
                print(f&#39;RMS OPD={ampl}&#39;)
            # if &#39;V&#39; in kwargs.keys():
            #     V = kwargs[&#39;V&#39;]
            # if &#39;direction&#39; in kwargs.keys():
            #     direction = kwargs[&#39;direction&#39;]
            # if &#39;L0&#39; in kwargs.keys():
            #     L0 = kwargs[&#39;L0&#39;]
            # if &#39;d&#39; in kwargs.keys():
            #     d = kwargs[&#39;d&#39;]

            for ia in range(NA):
                if tel:                 # Disturbances on only one pupil
                    itel = tel - 1
                    if ia != itel:
                        continue
    
                tstart=time.perf_counter()
                print(f&#39;Piston on pupil {ia}&#39;)
    
                dfreq = 0.008                           # Minimal sampling wished
                freqmax = 1/(2*dt*1e-3)                  # Maximal frequency derived from given temporal sampling
                
                Npix = int(freqmax/dfreq)*2         # Array length (taking into account aliasing)
                
                dsp = np.fft.fftshift(np.fft.fft(np.random.randn(Npix)))
                freqfft = (np.arange(Npix)-Npix//2)*dfreq
                timefft = (np.arange(Npix)-Npix//2)*dt  #ms
                
    
                nu0 = 0.2*V/L0                 # Low cut-off frequency
                nu1 = 0.3*V/d                  # High cut-off frequency
    
                print(f&#39;Atmospheric cutoff frequencies: {nu0:.2}Hz and {nu1:.2}Hz&#39;)
                
                if highCF:
                    filtre = np.zeros(Npix)
                    # print(&#39;Number of pixels:&#39;,Npix)
                    for i in range(Npix):
                        checkpoint = int(Npix/10)
                        if i%checkpoint == 0:
                            print(f&#39;Filtering....{i/Npix*100}%&#39;)
                        if freqfft[i] == 0:
                            filtre[i] = 0
                        elif np.abs(freqfft[i]) &lt; nu0:
                            filtre[i] = np.abs(freqfft[i])
                        elif np.abs(freqfft[i]) &gt;= nu0 and np.abs(freqfft[i]) &lt; nu1:
                            b0 = nu0**(5/3)
                            filtre[i] = np.abs(freqfft[i])**(-2/3)*b0
                        else:
                            b1 = nu0**(5/3)*nu1**(6.5/3)
                            filtre[i] = np.abs(freqfft[i])**(-8.5/3)*b1
                    
                    
                &#34;&#34;&#34;
                MOST REALISTIC DISTURBANCE SO FAR
                No high frequency cut
                &#34;&#34;&#34;
                if not highFC:
                    filtre = np.zeros(Npix)
                    # print(&#39;Number of pixels:&#39;,Npix)
                    for i in range(Npix):
                        checkpoint = int(Npix/2)
                        if i%checkpoint == 0:
                            print(f&#39;Filtering....{i/Npix*100}%&#39;)
                        if freqfft[i] == 0:
                            filtre[i] = 0
                        elif np.abs(freqfft[i]) &lt; nu0:
                            filtre[i] = np.abs(freqfft[i])
                        elif np.abs(freqfft[i]) &gt;= nu0: #and np.abs(freqfft[i]) &lt; nu1:
                            b0 = nu0**(7/3)
                            filtre[i] = np.abs(freqfft[i])**(-4/3)*b0
                
                
                filtre = filtre/np.max(filtre)
                
                newdsp = dsp*filtre
                
                motif0 = np.real(np.fft.ifft(np.fft.ifftshift(newdsp), norm=&#34;ortho&#34;))
                keeptime = (timefft&gt;=0)*(timefft&lt;obstime)
                stdtime = (timefft&gt;=0)*(timefft&lt;10000)              # We&#39;ll compute the standard deviation on a sample of 10s
                            
                motif = motif0[keeptime]
    
                calibmotif = motif/np.std(motif0[stdtime])
    
                PistonDisturbance[:,ia] = rmsPiston*calibmotif
                
                PistonDisturbance[:,ia] = PistonDisturbance[:,ia] - PistonDisturbance[startframe,ia]
                ElapsedTime = time.perf_counter() - tstart
                print(f&#39;Done. Ellapsed time: {ElapsedTime}s&#39;)
        
    elif dist == &#39;chirp&#39;:
        f_fin = f_fin*1e-3   # Conversion to kHz
        omega_fin = 2*np.pi*f_fin
        t_fin = timestamps[-1]
        a = omega_fin/(2*t_fin)
        chirp = lambda phi0,t : np.sin(phi0 + a*t**2)
        if tel:
            print(f&#39;CHIRP on telescope {tel}&#39;)
            itel = tel-1
            PistonDisturbance[:,itel] = ampl*chirp(0,timestamps)
            newdsp = np.fft.fftshift(np.fft.fft(PistonDisturbance[:,itel], norm=&#39;ortho&#39;))
            freqfft = np.fft.fftshift(np.fft.fftfreq(NT, dt))
        else:
            for ia in range(NA):
                PistonDisturbance[:,ia] = chirp(ia*2*np.pi/NA,timestamps)
            newdsp = np.fft.fftshift(np.fft.fft(PistonDisturbance[:,-1], norm=&#39;ortho&#39;))
            freqfft = np.fft.fftshift(np.fft.fftfreq(NT, dt))
        # Put first time at null-piston for reference closure phase measurement
        # PistonDisturbance[:startframe] = np.zeros([startframe,NA])

    CoherentFlux = np.zeros([NT,NW,NB])*1j             # dynamical coherence matrix with time dimension NT
    for it in range(NT):
        CoherentFlux[it,:] = coh__pis2coh(PistonDisturbance[it,:], 1/spectra, ampl=TransmissionDisturbance[it,:])


    if debug:
        return CoherentFlux, PistonDisturbance, TransmissionDisturbance
    

    hdr = fits.Header()
    hdr[&#39;TYPE&#39;] =dist
    hdr[&#39;AMPL&#39;] = ampl
    hdr[&#39;TEL&#39;] = tel
    
    primary = fits.PrimaryHDU(header=hdr)
    
    col1 = fits.Column(name=&#39;spectra&#39;, format=&#39;1D&#39;, array=spectra)
    hdu1 = fits.BinTableHDU.from_columns([col1], name=&#39;SpectralSampling&#39; )
    col1 = fits.Column(name=&#39;timestamps&#39;, format=&#39;1D&#39;, array=timestamps)
    hdu2 = fits.BinTableHDU.from_columns([col1], name=&#39;TimeSampling&#39;)
    
    im1 = fits.ImageHDU(np.real(CoherentFlux), name=&#39;RealCf&#39;)
    im2 = fits.ImageHDU(np.imag(CoherentFlux), name=&#39;ImagCf&#39;)
    im3 = fits.ImageHDU(PistonDisturbance, name=&#39;Piston&#39;)
    im4 = fits.ImageHDU(TransmissionDisturbance, name=&#39;Transmission&#39;)
    
    hdu = fits.HDUList([primary,hdu1,hdu2,im1,im2,im3,im4])
    
    if dist == &#39;random&#39; or dist == &#39;chirp&#39;:

        DisturbancePSD = np.abs(newdsp[freqfft&gt;=0])**2      # Save the PSD of the last disturbance for example
        FreqSampling = freqfft[freqfft&gt;=0]                  # FreqSampling in Hz        
        im5 = fits.ImageHDU(DisturbancePSD, name=&#39;LAST TEL PSD&#39;)
        im6 = fits.ImageHDU(FreqSampling, name=&#39;FREQUENCY SAMPLING&#39;)
        im7 = fits.ImageHDU(filtre[freqfft&gt;=0], name=&#39;Disturbance Filter&#39;)
        hdu.append(im5)
        hdu.append(im6)
        hdu.append(im7)

    
    print(f&#39;Saving file into {filepath}&#39;)
    hdu.writeto(filepath)

    
    return CoherentFlux

      
# @timer
def loop(*args):
    &#34;&#34;&#34;
    Core of the simulator. This routine calls the different modules according
    to the simulation timeline. 
    At the end, the data must be stored in a file. It has not yet been 
    developped.
    
    Parameters
    ----------
    DisturbanceFitsfile : STRING
        Fits file containing the disturbance data.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    
    from . import simu

    from .config import NT, timestamps, spectra
    
    # Reload simu module for initialising the observables with their shape
    reload(simu)
    
    # Importation of the object 
    CfObj, CPObj = coh_tools.get_CfObj(config.ObservationFile,spectra)
    
    #scaling it to the spectral sampling  and integration time dt
    delta_wav = np.abs(spectra[1]-spectra[2])
    
    CfObj = CfObj * delta_wav
    CfObj = CfObj * config.dt*1e-3
    
    
    simu.ClosurePhaseObject = CPObj
    simu.CoherentFluxObject = CfObj
    
    # Importation of the disturbance
    CfDist, PistonDist, TransmissionDist = coh_tools.get_CfDisturbance(config.DisturbanceFile, spectra, timestamps)
    simu.CfDisturbance = CfDist
    simu.PistonDisturbance = PistonDist
    simu.TransmissionDisturbance = TransmissionDist    
    # simu.PhotometryDisturbance = np.zeros([config.NT,config.NW,config.NA])
    
    for ia in range(config.NA):
        PhotometryObject = np.abs(CfObj[:,ia*(config.NA+1)])
        simu.PhotometryDisturbance[:,:,ia] = simu.TransmissionDisturbance[:,:,ia]*PhotometryObject

    simu.FTmode[:config.starttracking] = np.zeros(config.starttracking)

    print(&#34;Processing simulation ...&#34;)
    
    simu.it = 0
    time0 = time.time()
    for it in range(NT):                        # We browse all the (macro)times
        simu.it = it
        
        # Coherence of the ODL
        CfODL = coh__pis2coh(-simu.CommandODL[it,:],1/config.spectra)
        
        currCfTrue = CfObj * simu.CfDisturbance[it,:,:] * CfODL
        simu.CfTrue[it,:,:] = currCfTrue
        
        &#34;&#34;&#34;
        Fringe Sensor: From oversampled true coherences to macrosampled 
        measured coherences
        &#34;&#34;&#34;
        fringesensor = config.FS[&#39;func&#39;]
        currCfEstimated = fringesensor(currCfTrue)
        simu.CfEstimated[it,:,:] = currCfEstimated

        &#34;&#34;&#34;
        FRINGE TRACKER: From measured coherences to ODL commands
        &#34;&#34;&#34;
        if simu.FTmode[it] == 0:
            GainGD = config.FT[&#39;GainGD&#39;]
            GainPD = config.FT[&#39;GainPD&#39;]
            config.FT[&#39;GainGD&#39;] = 0
            config.FT[&#39;GainPD&#39;] = 0
        fringetracker = config.FT[&#39;func&#39;]
        CmdODL = fringetracker(currCfEstimated)
        config.FT[&#39;GainGD&#39;] = GainGD
        config.FT[&#39;GainPD&#39;] = GainPD
        
        simu.CommandODL[it+config.latency,:] = CmdODL
        
        checkpoint = int(NT/10)
        if (it%checkpoint == 0) and (it!=0):
            processedfraction = it/NT
            LeftProcessingTime = (time.time()-time0)*(1-processedfraction)/processedfraction
            print(f&#39;Processed: {processedfraction*100}%, Elapsed time: {round(time.time()-time0)}s&#39;)

    
    # Process observables for visualisation
    simu.PistonTrue = simu.PistonDisturbance - simu.CommandODL[:-config.latency]

    # Save true OPDs in an observable
    for ia in range(config.NA):
        for iap in range(ia+1,config.NA):
            ib = coh_tools.posk(ia,iap,config.NA)
            simu.OPDTrue[:,ib] = simu.PistonTrue[:,ia] - simu.PistonTrue[:,iap]
            simu.OPDDisturbance[:,ib] = simu.PistonDisturbance[:,ia] - simu.PistonDisturbance[:,iap]
            simu.OPDCommand[:,ib] = simu.CommandODL[:,ia] - simu.CommandODL[:,iap]    
    
    # print(args)
    if len(args):
        print(f&#39;Saving infos in {filepath}&#39;)
        filepath = args[0]
        
        fileexists = os.path.exists(filepath)
        
        if fileexists:
            if &#39;overwrite&#39; in args:
                os.remove(filepath)
            else:
                overwrite = (input(f&#39;{filepath} already exists. Do you want to overwrite it? (y/n)&#39;) == &#39;y&#39;)
                if overwrite:
                    os.remove(filepath)
                else:
                    return
        
        
        hdr = fits.Header()
        hdr[&#39;Date&#39;] = time.strftime(&#34;%a, %d %b %Y %H:%M&#34;, time.localtime())
        hdr[&#39;ObservationFile&#39;] = config.ObservationFile
        hdr[&#39;DisturbanceFile&#39;] = config.DisturbanceFile
        for key in [&#39;NA&#39;, &#39;dt&#39;, &#39;ron&#39;, &#39;enf&#39;]:
            print(key)     
            hdr[key] = getattr(config, key)
            
        primary = fits.PrimaryHDU(header=hdr, data= config.spectra)
        col1 = fits.Column(name=&#39;OPDTrue&#39;, format=&#39;15D&#39;, array=simu.OPDTrue)
        col2 = fits.Column(name=&#39;PistonTrue&#39;, format=&#39;6D&#39;, array=simu.PistonTrue)
        
        coldefs = fits.ColDefs([col1, col2])
        hdu1 = fits.BinTableHDU.from_columns(coldefs, name=&#39;Observables&#39; )

        hdu = fits.HDUList([primary, hdu1])
        
        hdu.writeto(filepath)
    
    return
        

def SaveSimulation():
    
    from . import simu
    
    # infosimu = pd.DataFrame(coh)
    
    observables = pd.DataFrame({&#39;timestamp&#39;:timestamps,&#39;PistonDisturbance&#39;:simu.PistonDisturbance,&#39;pis_res&#39;:simu.PistonTrue,&#39;cmd_odl&#39;:simu.CommandODL,\
                               &#39;PD_res&#39;:simu.PDResidual,&#39;GD_res&#39;:simu.GDResidual,&#39;PDCommand&#39;:simu.PDCommand,&#39;GDCommand&#39;:simu.GDCommand,\
                               &#39;rmsPD&#39;:rmsPD_,&#39;rmsGD&#39;:rmsGD_,\
                                   &#39;phot_per&#39;:simu.TransmissionDisturbance,&#39;phot_est&#39;:simu.PhotometryEstimated,&#39;SquaredCoherenceDegree&#39;:simu.SquaredCoherenceDegree})
    
    t2 = Table.from_pandas(df)
    
    currentDT = datetime.datetime.now()
    suffix=currentDT.strftime(&#34;%Y%m%d%H%M&#34;)
    
    fits.writeto(prefix+suffix,np.array(t2))
    
    
        
def display(*args, wl=1.6,Pistondetails=False,OPDdetails=False,OneTelescope=True):
    
    &#39;&#39;&#39;
    NAME:
    COH__PLOT - Plots different interesting results from the simulation
    
    CALLING SEQUENCE:
        coh__plot(coh, pis_display=True, coher_display=True)
        
    PURPOSE:
        This procedure plots different results from the simulation, like \
        pistons commands and amplitudes of wavefronts function of time. \
        It is called at the end of a coh_turn routine to show these results\
        which have been stored in global variables during the loop.
        
    INPUTS:
        - args: write, as strings, the different observables you want to plot
        among: &#39;disturbance&#39;, phot&#39;, &#39;piston&#39;, &#39;opd&#39;,&#39;vis&#39;,&#39;detector&#39;
        - wl: wavelength 
        
    &#39;&#39;&#39;
          
    import matplotlib.patches as mpatches
    import matplotlib.lines as mlines
    
    from . import simu
    # import config
    
    from .simu import timestamps
    
    ind = np.where(np.abs(config.spectraM-wl) &lt; 0.1)[0]
    ind = ind[0]
    wl = config.spectraM[ind]
    
    from .config import NA,NT
       
    ich = config.FS[&#39;ich&#39;]
    
    dt=config.dt

    increment=0
    if np.min(ich) == 1:
        increment = 1


    print(&#39;Displaying observables...&#39;)
    print(f&#39;First fig is Figure {config.newfig}&#39;)
    
    displayall = False
    if len(args)==0:
        print(args)
        displayall = True
        
    from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,
                       AutoMinorLocator, MaxNLocator)
    
    colors = [&#39;red&#39;,&#39;blue&#39;,&#39;dodgerblue&#39;,&#39;gold&#39;,&#39;darkorange&#39;,&#39;darkgreen&#39;,&#39;darkviolet&#39;,&#39;grey&#39;,&#39;deeppink&#39;,&#39;black&#39;]
    
    if displayall or (&#39;disturbances&#39; in args):
        pis_max = 1.1*np.max(np.abs(simu.PistonDisturbance))
        pis_min = -pis_max
        ylim = [pis_min,pis_max]
        
        beam_patches = []
        for ia in range(NA):
            beam_patches.append(mpatches.Patch(color=colors[ia+1],label=f&#34;Telescope {ia+increment}&#34;))
        
        
        fig = plt.figure(&#34;Disturbances&#34;)
        ax1,ax2,ax3 = fig.subplots(nrows=3,ncols=1)
        for ia in range(NA):
            # plt.subplot(NA,1,ia+1), plt.title(&#39;Beam {}&#39;.format(ia+increment))
            ax1.plot(timestamps, simu.PistonDisturbance[:,ia],color=colors[ia+1])
        
        ax1.set_xlabel(&#39;Time (ms)&#39;)
        ax1.set_ylabel(&#39;Piston [µm]&#39;)
        ax1.set_ylim(ylim)
        ax1.grid()
        ax1.set_title(&#39;Disturbance scheme at {:.2f}µm&#39;.format(wl))
        ax1.legend(handles=beam_patches)

        if hasattr(simu, &#39;FreqSampling&#39;):
            if simu.FreqSampling.size == simu.DisturbancePSD.size:
                ax2.plot(simu.FreqSampling, simu.DisturbancePSD)
                ax2.set_title(&#39;Power spectral distribution of the last pupil \
            (same shape for all)&#39;)
                ax2.set_xlabel(&#39;Frequency [Hz]&#39;)             
                ax2.set_xscale(&#39;log&#39;)
                ax2.set_yscale(&#39;log&#39;)
                
                ax3.plot(simu.FreqSampling, simu.DisturbanceFilter)
                ax3.set_title(&#39;Filter&#39;)
                ax3.set_xlabel(&#39;Frequency [Hz]&#39;)             
                ax3.set_xscale(&#39;log&#39;)
                ax3.set_yscale(&#39;log&#39;)    
                
        plt.show()
        config.newfig+=1    
        
        
    if displayall or (&#39;phot&#39; in args):
        linestyles=[]
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;solid&#39;,label=&#39;Estimated&#39;))    
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;dashed&#39;,label=&#39;Disturbance&#39;))
    
    
        plt.figure(&#34;Photometries&#34;)
        plt.suptitle(&#39;Photometries at {:.2f}µm&#39;.format(wl))
        
        for ia in range(NA):
            plt.plot(timestamps, simu.PhotometryDisturbance[:,ind,ia],
                     color=colors[ia],linestyle=&#39;dashed&#39;)#),label=&#39;Photometry disturbances&#39;)
            plt.plot(timestamps, simu.PhotometryEstimated[:,ind,ia],
                     color=colors[ia],linestyle=&#39;solid&#39;)#,label=&#39;Estimated photometries&#39;)
            
        plt.legend(handles=beam_patches+linestyles)
        plt.grid()
        plt.xlabel(&#39;Time (ms)&#39;)
        plt.show()    
        config.newfig+=1    
        
    
    if displayall or (&#39;piston&#39; in args):
        &#34;&#34;&#34;
        PISTONS
        &#34;&#34;&#34;
        linestyles=[]
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;solid&#39;,label=&#39;Estimated&#39;))    
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;dashed&#39;,label=&#39;Disturbance&#39;))
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;dotted&#39;,label=&#39;Command&#39;))
        
        ax1ymax = np.max([np.max(np.abs(simu.PistonTrue)),wl/2])
        ax1ylim = [-ax1ymax,ax1ymax]
        fig = plt.figure(&#34;Pistons&#34;)
        plt.suptitle(&#39;Piston time evolution at {:.2f}µm&#39;.format(wl))
        ax1 = fig.subplots()
        ax2 = ax1.twinx()
        
        for ia in range(NA):
            # if not config.TELref:
                  # iTelref = config.TELref - 1
            #     PistonToPlot = simu.PistonTrue[:,ia]
            # else:
            #     PistonToPlot = simu.PistonTrue[:,ia] - simu.PistonTrue[:,iTELref]
            
            ax1.plot(timestamps, simu.PistonTrue[:,ia],
                     color=colors[ia+1],linestyle=&#39;solid&#39;)
            ax2.plot(timestamps, simu.PistonDisturbance[:,ia],
                     color=colors[ia+1],linestyle=&#39;dashed&#39;)
            ax2.plot(timestamps, simu.CommandODL[:-config.latency,ia],
                     color=colors[ia+1],linestyle=&#39;dotted&#39;)
            plt.grid()
        
        ax1.set_ylabel(&#39;True Pistons [µm]&#39;)
        ax1.set_ylim(ax1ylim)
        ax2.set_ylabel(&#39;Disturbance and Command Pistons [µm]&#39;)
        ax2.set_ylim(ylim)
        plt.xlabel(&#39;Time (ms)&#39;)
        plt.legend(handles=beam_patches+linestyles)
        plt.show()
        config.newfig+=1
    
        if Pistondetails:
            
            linestyles=[]
            linestyles.append(mlines.Line2D([], [], color=&#39;blue&#39;,
                                            linestyle=&#39;solid&#39;,label=&#39;Estimated&#39;))    
            linestyles.append(mlines.Line2D([], [], color=&#39;red&#39;,
                                            linestyle=&#39;solid&#39;,label=&#39;Disturbance&#39;))
            linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                            linestyle=&#39;dotted&#39;,label=&#39;Command&#39;))
            linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                            linestyle=(0,(3,5,1,5)),label=&#39;PD Command&#39;))
            linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                            linestyle=(0,(3,5,1,5,1,5)),label=&#39;GD Command&#39;))
            # linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
            #                                 linestyle=&#39;dashdot&#39;,label=&#39;Search Command&#39;))
            # linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
            #                                 linestyle=&#39;dashdot&#39;,label=&#39;Modulation Command&#39;))
        
        
            fig = plt.figure(&#34;Piston details&#34;)
            fig.suptitle(&#39;Piston time evolution at {:.2f}µm&#39;.format(wl))
            axes = fig.subplots(nrows=NA,ncols=1, sharex=True)
            ax2ymax = np.max(np.abs(simu.PistonTrue))
            ax2ylim = [-ax2ymax,ax2ymax]
            for ia in range(NA):
                ax = axes[ia]
                ax.plot(timestamps, simu.PistonDisturbance[:,ia],
                         color=&#39;red&#39;,linestyle=&#39;solid&#39;)
                ax.plot(timestamps, simu.CommandODL[:-config.latency,ia],
                         color=&#39;green&#39;,linestyle=&#39;dashed&#39;)
                ax.plot(timestamps, simu.PistonPDCommand[:-config.latency,ia],
                         color=&#39;green&#39;,linestyle=&#39;dotted&#39;)
                ax.plot(timestamps, simu.PistonGDCommand[:-config.latency,ia],
                         color=&#39;green&#39;,linestyle=(0,(3,5,1,5,1,5)))
                ax2 = ax.twinx()
                ax2.plot(timestamps, simu.PistonTrue[:,ia],
                         color=&#39;blue&#39;,linestyle=&#39;solid&#39;)
                ax.set_ylim(ylim)
                ax2.set_ylim(ax2ylim)
                ax.set_ylabel(f&#39;All Pistons except residual {ia+increment} [µm]&#39;)
                ax2.set_ylabel(f&#39;Residual Piston {ia+increment} [µm]&#39;)
                ax.grid()
            plt.xlabel(&#39;Time (ms)&#39;)
            plt.legend(handles=linestyles)
            plt.show()
            config.newfig+=1    


    if displayall or (&#39;opd&#39; in args):
        &#34;&#34;&#34;
        OPD 
        &#34;&#34;&#34;
        
        OPD_max = 1.1*np.max(np.abs([simu.OPDDisturbance,
                              simu.OPDTrue,
                              simu.OPDCommand[:-config.latency,:]]))
        OPD_min = -OPD_max
        ylim = [OPD_min,OPD_max]
    
        linestyles=[]
        linestyles.append(mlines.Line2D([], [], color=&#39;blue&#39;,
                                        linestyle=&#39;solid&#39;,label=&#39;Residual&#39;))    
        linestyles.append(mlines.Line2D([], [], color=&#39;red&#39;,
                                        linestyle=&#39;solid&#39;,label=&#39;Disturbance&#39;))
        linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                        linestyle=&#39;dotted&#39;,label=&#39;Command&#39;))
    
        DIT = min(50, config.NT - config.starttracking -1)
        ShowPerformance(float(timestamps[int((config.starttracking+config.NT)*2/3)]), wl, DIT, display=False)
        NumberOfBaselinesToShow = 3
        for ia in range(NumberOfBaselinesToShow):
            fig = plt.figure(f&#34;OPD {ia+increment}&#34;)
    #         fig.suptitle(f&#34;OPD evolution at {wl:.2f}µm for baselines \n\
    # including telescope {ia+increment}&#34;)
            axes = fig.subplots(nrows=NumberOfBaselinesToShow,ncols=2,sharex=True, gridspec_kw={&#39;width_ratios&#39;: [4, 1]})
            iap,iax=0,0
            for ax,axText in axes:
                ax2 = ax.twinx()
                ax2ymax = 1.1*np.max(np.abs(simu.OPDTrue[config.starttracking+50:]))
                ax2ylim = [-ax2ymax,ax2ymax]
                # ax2ylim = [-wl/2,wl/2]
                if iap == ia:
                    iap+=1
                if ia &lt; iap:
                    ib = coh_tools.posk(ia,iap,NA)
                    ax.plot(timestamps, simu.OPDDisturbance[:,ib],color=&#39;red&#39;)
                    ax.plot(timestamps, simu.OPDCommand[:-config.latency,ib],
                            color=&#39;green&#39;,linestyle=&#39;dotted&#39;)
                    ax2.plot(timestamps, simu.OPDTrue[:,ib],color=&#39;blue&#39;)
                else:
                    ib = coh_tools.posk(iap,ia,NA)
                    ax.plot(timestamps, -simu.OPDDisturbance[:,ib],color=&#39;red&#39;)
                    ax.plot(timestamps, -simu.OPDCommand[:-config.latency,ib],
                            color=&#39;green&#39;,linestyle=&#39;dotted&#39;)                
                    ax2.plot(timestamps, -simu.OPDTrue[:,ib],color=&#39;blue&#39;)
                
                axText.text(0.5,0.5,f&#34;{np.sqrt(simu.VarOPD[ib])*1e3:.0f}nm RMS&#34;)
                axText.axis(&#34;off&#34;)
                ax.set_ylim(ylim)
                ax2.set_ylim(ax2ylim)
                ax.set_ylabel(f&#39;OPD ({ia+1},{iap+1})\n [µm]&#39;)
                ax2.set_ylabel(f&#39;Residual \n [µm]&#39;)
                fig.tight_layout()
                # wlr = round(wl,2)
                # ax2.set_yticks([-wl,0,wl])
                # ax2.set_yticklabels([-wlr,0,wlr])
                # ax2.tick_params(axis=&#39;y&#39;,which=&#39;major&#39;, length=7)
                # ax2.tick_params(axis=&#39;y&#39;,which=&#39;minor&#39;, length=4)
                # ax2.yaxis.set_minor_locator(AutoMinorLocator(2))
                # ax2.grid(b=True,which=&#39;major&#39;)
                # ax2.grid(b=True, which=&#39;minor&#39;)
                
                
                iap += 1
                iax+=1
            # plt.tight_layout()
            ax.set_xlabel(&#39;Time (ms)&#39;)
            plt.show()
            plt.legend(handles=linestyles)
            config.newfig+=1
            
            if OneTelescope:
                break
        
    
        if OPDdetails:
            OPD_max = 1.1*np.max(np.abs([simu.OPDDisturbance,
                                  simu.GDCommand[:-config.latency,:]]))
            OPD_min = -OPD_max
            ylim = [OPD_min,OPD_max]
        
            linestyles=[]
            linestyles.append(mlines.Line2D([], [],label=&#39;Disturbance&#39;,
                                            color=&#39;red&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                        linestyle=&#39;dotted&#39;,label=&#39;GD Command&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;GD Residuals&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;:&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;PD Residuals&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;-&#39;))

            for ia in range(NA):
                fig = plt.figure(f&#34;OPD details {ia+increment}&#34;)
                fig.suptitle(f&#34;OPD evolution at {wl:.2f}µm for baselines \n\
        including telescope {ia+increment}&#34;)
                axes = fig.subplots(nrows=NA-1,ncols=3,sharex=True,gridspec_kw={&#39;width_ratios&#39;: [8, 1,1]})
                iap,iax=0,0
                for ax,axText,axLegend in axes:
                    ax2 = ax.twinx()
                    ax2ymax = 1.1*np.max(np.abs(simu.GDEstimated*wl/(2*np.pi)))
                    ax2ylim = [-ax2ymax,ax2ymax]
                    if iap == ia:
                        iap+=1
                    if ia &lt; iap:
                        ib = coh_tools.posk(ia,iap,NA)
                        ax.plot(timestamps, simu.OPDDisturbance[:,ib],
                                color=&#39;red&#39;)
                        ax2.plot(timestamps, simu.GDCommand[:-config.latency,ib],
                                color=&#39;green&#39;,linestyle=&#39;dotted&#39;)
                        ax2.plot(timestamps, simu.GDResidual[:,ib]*wl/(2*np.pi),
                                 color=&#39;black&#39;,linestyle=&#39;:&#39;)
                        ax2.plot(timestamps, simu.PDResidual[:,ib]*wl/(2*np.pi),
                                 color=&#39;black&#39;,linestyle=&#39;-&#39;)
                    else:
                        ib = coh_tools.posk(iap,ia,NA)
                        ax.plot(timestamps, -simu.OPDDisturbance[:,ib],color=&#39;red&#39;)
                        ax.plot(timestamps, -simu.GDCommand[:-config.latency,ib],
                                color=&#39;green&#39;,linestyle=&#39;dotted&#39;)
                        ax2.plot(timestamps, -simu.GDResidual[:,ib]*wl/(2*np.pi), color=&#39;black&#39;,
                                 linestyle=&#39;:&#39;)
                        ax2.plot(timestamps, -simu.PDResidual[:,ib]*wl/(2*np.pi), color=&#39;black&#39;,
                                 linestyle=&#39;-&#39;)
                    ax.set_ylim(ylim)
                    ax.set_ylabel(f&#39;[{ia+1},{iap+1}] [µm]&#39;)
                    
                    ax2.set_ylim(ax2ylim)
                    ax2.set_ylabel(f&#39;Residuals&#39;)
                    ax2.set_yticks([-wl,0,wl])

                    axText.text(0,0.70,f&#34;PD:{np.std(simu.PDEstimated[(config.starttracking+config.NT)*2//3:,ib]*wl/(2*np.pi)*1e3):.0f}nm RMS&#34;)
                    axText.text(0,0.30,f&#34;GD:{np.std(simu.GDEstimated[(config.starttracking+config.NT)*2//3:,ib]*wl/(2*np.pi)*1e3):.0f}nm RMS&#34;)
                    axText.axis(&#34;off&#34;)
                    axLegend.axis(&#34;off&#34;)
                    # wlr = round(wl,2)
                    # ax2.set_yticklabels([-wlr,0,wlr])
                    # ax2.tick_params(axis=&#39;y&#39;,which=&#39;major&#39;, length=7)
                    # ax2.tick_params(axis=&#39;y&#39;,which=&#39;minor&#39;, length=4)
                    # ax2.yaxis.set_minor_locator(AutoMinorLocator(2))
                    # ax2.grid(b=True,which=&#39;major&#39;)
                    # ax2.grid(b=True, which=&#39;minor&#39;)
                    
                    iap += 1
                    iax+=1
                    # ax2.minorticks_on()
                fig.tight_layout()
                plt.xlabel(&#39;Time (ms)&#39;)
                # plt.show()
                axLegend.legend(handles=linestyles)
                config.newfig+=1
        
                if OneTelescope:
                    break
            
        if &#39;ODPcmd&#39; in args:
            OPD_max = 1.1*np.max(np.abs([simu.OPDDisturbance,
                                  simu.GDCommand[:-config.latency,:]]))
            OPD_min = -OPD_max
            ylim = [OPD_min,OPD_max]
        
            linestyles=[]
            linestyles.append(mlines.Line2D([], [],label=&#39;Disturbance&#39;,
                                            color=&#39;red&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;Command OPD&#39;,
                                            color=&#39;blue&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;GD Estimated&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;--&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;PD Estimated&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;:&#39;))

            for ia in range(NA):
                fig = plt.figure(f&#34;OPD details {ia+increment}&#34;)
                fig.suptitle(f&#34;OPD evolution at {wl:.2f}µm for baselines \n\
        including telescope {ia+increment}&#34;)
                axes = fig.subplots(nrows=NA-1,ncols=3,sharex=True,gridspec_kw={&#39;width_ratios&#39;: [8, 1,1]})
                iap,iax=0,0
                for ax,axText,axLegend in axes:
                    ax2 = ax.twinx()
                    ax2ymax = 1.1*np.max(np.abs(simu.GDEstimated*wl/(2*np.pi)))
                    ax2ylim = [-ax2ymax,ax2ymax]
                    if iap == ia:
                        iap+=1
                    if ia &lt; iap:
                        ib = coh_tools.posk(ia,iap,NA)
                        ax.plot(timestamps, simu.OPDDisturbance[:,ib],
                                color=&#39;red&#39;)
                        # ax2.plot(timestamps, simu.GDCommand[:-config.latency,ib],
                        #         color=&#39;blue&#39;)
                        ax2.plot(timestamps, simu.OPDCommand[:-config.latency,ib],
                                color=&#39;blue&#39;)
                        ax2.plot(timestamps, simu.GDResidual[:,ib]*wl/(2*np.pi),
                                 color=&#39;black&#39;,linestyle=&#39;-.&#39;)
                        ax2.plot(timestamps, simu.PDResidual[:,ib]*wl/(2*np.pi),
                                 color=&#39;black&#39;,linestyle=&#39;-&#39;)
                    else:
                        ib = coh_tools.posk(iap,ia,NA)
                        ax.plot(timestamps, -simu.OPDDisturbance[:,ib],color=&#39;red&#39;)
                        ax.plot(timestamps, -simu.GDCommand[:-config.latency,ib],
                                color=&#39;green&#39;,linestyle=(0,(3,5,1,5,1,5)))
                        ax2.plot(timestamps, -simu.GDResidual[:,ib]*wl/(2*np.pi), color=&#39;black&#39;,
                                 linestyle=&#39;--&#39;)
                        ax2.plot(timestamps, -simu.PDResidual[:,ib]*wl/(2*np.pi), color=&#39;black&#39;,
                                 linestyle=&#39;:&#39;)
                    ax.set_ylim(ylim)
                    ax.set_ylabel(f&#39;[{ia+1},{iap+1}] [µm]&#39;)
                    
                    ax2.set_ylim(ax2ylim)
                    ax2.set_ylabel(f&#39;Residuals&#39;)
                    ax2.set_yticks([-wl,0,wl])

                    axText.text(0,0.70,f&#34;PD:{np.std(simu.PDEstimated[config.starttracking+10:,ib]*wl/(2*np.pi)*1e3):.0f}nm RMS&#34;)
                    axText.text(0,0.30,f&#34;GD:{np.std(simu.GDEstimated[config.starttracking+10:,ib]*wl/(2*np.pi)*1e3):.0f}nm RMS&#34;)
                    # axText.axis(&#34;off&#34;)
                    # axLegend.axis(&#34;off&#34;)
                    wlr = round(wl,2)
                    ax2.set_yticklabels([-wlr,0,wlr])
                    ax2.tick_params(axis=&#39;y&#39;,which=&#39;major&#39;, length=7)
                    ax2.tick_params(axis=&#39;y&#39;,which=&#39;minor&#39;, length=4)
                    ax2.yaxis.set_minor_locator(AutoMinorLocator(2))
                    ax2.grid(b=True,which=&#39;major&#39;)
                    ax2.grid(b=True, which=&#39;minor&#39;)
                    
                    iap += 1
                    iax+=1
                    # ax2.minorticks_on()
                plt.xlabel(&#39;Time (ms)&#39;)
                plt.show()
                axLegend.legend(handles=linestyles)
                config.newfig+=1
        
                if OneTelescope:
                    break


        if &#39;OPDgathered&#39; in args:

            OPD_max = 1.1*np.max(np.abs([simu.OPDDisturbance,
                                  simu.GDCommand[:-config.latency,:]]))
            OPD_min = -OPD_max
            ylim = [OPD_min,OPD_max]
        
            linestyles=[]
            linestyles.append(mlines.Line2D([], [],label=&#39;Disturbance&#39;,
                                            color=&#39;red&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;Command OPD&#39;,
                                            color=&#39;blue&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;GD Estimated&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;--&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;PD Estimated&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;:&#39;))

            fig = plt.figure(f&#34;OPD on one window&#34;)
            ax,axText,axLegend = fig.subplots(nrows=1,ncols=3,sharex=True,gridspec_kw={&#39;width_ratios&#39;: [8, 1,1]})

            for ib in range(config.NIN):
                
                ax.plot(timestamps, simu.OPDTrue[:,ib], linestyle=&#39;-&#39;, label=f&#39;OPD {config.ich[ib]}&#39;)


                wlr = round(wl,2)
                ax2.set_yticklabels([-wlr,0,wlr])
                ax2.tick_params(axis=&#39;y&#39;,which=&#39;major&#39;, length=7)
                ax2.tick_params(axis=&#39;y&#39;,which=&#39;minor&#39;, length=4)
                ax2.yaxis.set_minor_locator(AutoMinorLocator(2))
                ax2.grid(b=True,which=&#39;major&#39;)
                ax2.grid(b=True, which=&#39;minor&#39;)
                    
                    # ax2.minorticks_on()
            plt.xlabel(&#39;Time (ms)&#39;)
            plt.show()
            axLegend.legend()
            config.newfig+=1
        
            # if OneTelescope:
            #     break



    if displayall or (&#39;cp&#39; in args):
        &#34;&#34;&#34;
        CLOSURE PHASES
        &#34;&#34;&#34;
        
        
        linestyles=[]
        linestyles.append(mlines.Line2D([], [],linestyle=&#39;solid&#39;,
                                        label=&#39;Estimated&#39;))    
        linestyles.append(mlines.Line2D([], [],linestyle=&#39;dashed&#39;,
                                        label=&#39;Object&#39;))
        
        
        ymax = np.pi
        ylim = [-ymax, ymax]
        fig = plt.figure(&#39;Closure Phases&#39;)
        fig.suptitle(&#39;Closure Phases&#39;)
        ax1,ax2 = fig.subplots(nrows=2, ncols=1)
        
        # Plot on ax1 the (NA-1)(NA-2)/2 independant Closure Phases
        for ia in range(1,NA):
            for iap in range(ia+1,NA):
                ic = coh_tools.poskfai(0,ia,iap,NA)
                # if ia == 0
                ax1.plot(timestamps, simu.ClosurePhasePD[:,ic],
                         color=colors[ic])
                ax1.hlines(simu.ClosurePhaseObject[ind,ic], 0, timestamps[-1], 
                           color=colors[ic], linestyle=&#39;--&#39;)
                
        # Plot on ax2 the (NA-1)(NA-2)/2 (independant?) other Closure Phases
        for ia in range(1,NA):
            for iap in range(ia+1,NA):
                for iapp in range(iap+1,NA):
                    ic = coh_tools.poskfai(ia,iap,iapp,NA)
                    colorindex = int(ic - config.NC//2)
                    ax2.plot(timestamps, simu.ClosurePhasePD[:,ic],
                             color=colors[colorindex])
                    ax2.hlines(simu.ClosurePhaseObject[ind,ic], 0, timestamps[-1],
                               color=colors[colorindex], linestyle=&#39;--&#39;)
        
        plt.xlabel(&#39;Time [ms]&#39;)
        plt.ylabel(&#39;Closure Phase [rad]&#39;)
        ax1.set_ylim(ylim)
        ax2.set_ylim(ylim)
        ax1.grid()
        ax2.grid()
        plt.show()
        plt.legend(handles=linestyles)
        config.newfig+=1
        

    if displayall or (&#39;vis&#39; in args):
        &#34;&#34;&#34;
        VISIBILITIES
        &#34;&#34;&#34;
    
        # Squared Visibilities
        for ia in range(NA):
            fig = plt.figure(f&#34;Squared Vis {ia+increment}&#34;)
            fig.suptitle(f&#34;Squared visibility |\u03B3|² at {wl:.2f}µm for baselines \n\
    including telescope {ia+increment}&#34;)
            axes = fig.subplots(nrows=NA-1,ncols=1,sharex=True)
            iap=0
            for ax in axes:
                if iap == ia:
                    iap+=1
                
                ib = coh_tools.posk(ia,iap,NA)
                ax.plot(timestamps, simu.SquaredCoherenceDegree[:,ind,ib], color=&#39;k&#39;)
                ax.set_ylim([0,1])
                ax.set_ylabel(f&#39;({ia},{iap})&#39;)
    
                ax.grid()
                iap += 1
            plt.xlabel(&#39;Time (ms)&#39;)
            plt.show()
            config.newfig+=1
            
            if OneTelescope:
                break
    
    
        # Phase of the visibilities
        VisibilityPhase = np.angle(simu.ComplexVisibility[:,ind,:])
        ymax = np.pi #2*np.max(np.abs(VisibilityPhase))
        ylim = [-ymax,ymax]
        for ia in range(NA):
            fig = plt.figure(f&#34;Phase Vis {ia+increment}&#34;)
            fig.suptitle(f&#34;Visibility phase \u03C6 at {wl:.2f}µm for baselines \n\
    including telescope {ia+increment}&#34;)
            axes = fig.subplots(nrows=NA-1,ncols=1,sharex=True)
            iap=0
            for iax in range(len(axes)):
                ax = axes[iax]
                if iap == ia:
                    iap+=1
                
                ib = coh_tools.posk(ia,iap,NA)
                ax.plot(timestamps, VisibilityPhase[:,ib], color=&#39;k&#39;)
                ax.set_ylim(ylim)
                ax.set_ylabel(f&#39;({ia},{iap})&#39;)
                ax.grid()
                iap += 1
                fig.subplots_adjust(right=0.8)
                RMS_ax = fig.add_axes([0.82, 1-1/NA*(iax+1), 0.1, 0.9/NA])
                RMS_ax.text(0,0,f&#34;{np.std(VisibilityPhase[config.starttracking+10:,ib])/(2*np.pi):.2f}\u03BB RMS&#34;)
                RMS_ax.axis(&#34;off&#34;)
            plt.xlabel(&#39;Time (ms)&#39;)
            plt.show()
            config.newfig+=1
    
            if OneTelescope:
                break

    if displayall or (&#39;detector&#39; in args):
        &#34;&#34;&#34;
        DETECTOR VIEW
        &#34;&#34;&#34;
        fig = plt.figure(&#34;Detector intensities&#34;)
        axes = fig.subplots()
        plt.suptitle(&#39;Intensities recorded by the detector at {:.2f}µm&#39;.\
                     format(wl))
        
        if config.fs == &#39;default&#39;:
            NMod = 1
        if &#39;spica&#39; in config.fs or &#39;abcd&#39; in config.fs:
            NMod = config.FS[&#39;NM&#39;]
            
        NIN = config.NIN
        NP = config.FS[&#39;NP&#39;]
        NMod = config.FS[&#39;NMod&#39;]
        
        for ip in range(NP):
            
            ax = plt.subplot(NIN,NMod,ip+1)
            if ip &lt; NMod:
                ax.set_title(config.FS[&#39;Modulations&#39;][ip])
            im = plt.imshow(np.transpose(np.dot(np.reshape(simu.MacroImages[:,ind,ip],[NT,1]), \
                                                np.ones([1,100]))), vmin=np.min(simu.MacroImages), vmax=np.max(simu.MacroImages))    
                
            plt.tick_params(axis=&#39;y&#39;,left=&#39;off&#39;)
            if ip//NMod == ip/NMod:
                plt.ylabel(str(int(ich[ip//NMod,0]))+str(int(ich[ip//NMod,1])))
                
            if ip&gt;=NP-NMod:
                plt.xticks([0,NT],[0,NT*dt])
                plt.xlabel(&#39;Time (ms)&#39;) 
            else:
                plt.xticks([],[])
            plt.yticks([],[])
                
    
        fig.subplots_adjust(right=0.8)
        cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
        fig.colorbar(im, cax=cbar_ax)
        plt.show()
        config.newfig+=1



def ShowPerformance(TimeBonds, WavelengthOfInterest,DIT, display=True, get=[]):
    &#34;&#34;&#34;
    Processes the performance of the fringe-tracking starting at the StartingTime
    Observables processed:
        -VarOPD                 # Temporal Variance OPD [µm]
        -TempVarPD              # Temporal Variance PD [rad]
        -TempVarGD              # Temporal Variance of GD [rad]
        -VarCPD                 # Temporal Variance of CPD [rad]
        -VarCGD                 # Temporal Variance of CGD [rad]
        -FringeContrast         # Fringe Contrast [0,1] at given wavelengths
WavelengthOfInterest
        

    Parameters
    ----------
    TimeBonds : INT or ARRAY [ms]
        If int:
            The performance are processed from StartingTime until the end
        If array [StartingTime,EndingTime]: 
            The performance are processed between StartingTime and EndingTime
    WavelengthOfInterest : ARRAY
        Wavelength when the Fringe Contrast needs to be calculated.
    DIT : INT
        Integration time of the science instrument [ms]
    Returns
    -------
    None.

    &#34;&#34;&#34;
    from . import simu
    from . import config
    
    from .config import NIN,dt,NT
    
    WOI = WavelengthOfInterest
    if isinstance(WOI, float):
        WOI = [WOI]    
    NW = len(WOI) 
    
    DIT_NumberOfFrames = int(DIT/dt)
    
    if isinstance(TimeBonds,(float,int)):
        Period = int(NT - TimeBonds/dt)
        InFrame = round(TimeBonds/dt)
    elif isinstance(TimeBonds,(np.ndarray,list)):
        Period = int((TimeBonds[1]-TimeBonds[0])/dt)
        InFrame = round(TimeBonds[0]/dt)
    else:
        raise &#39;&#34;TimeBonds&#34; must be instance of (float,int,np.ndarray,list)&#39;
        
   
    simu.FringeContrast=np.zeros([NW,NIN])      # Fringe Contrast at given wavelengths [0,1]
    
    Ndit = Period//DIT_NumberOfFrames
    for it in range(Ndit):
        InFrame += DIT_NumberOfFrames
        OutFrame = InFrame + DIT_NumberOfFrames
        
        simu.VarOPD += 1/Ndit*np.var(simu.OPDTrue[InFrame:OutFrame,:],axis=0)
        simu.TempVarPD += 1/Ndit*np.var(simu.PDEstimated[InFrame:OutFrame,:],axis=0)
        simu.TempVarGD += 1/Ndit*np.var(simu.GDEstimated[InFrame:OutFrame,:],axis=0)
        simu.VarCPD += 1/Ndit*np.var(simu.ClosurePhasePD[InFrame:OutFrame,:],axis=0)
        simu.VarCGD += 1/Ndit*np.var(simu.ClosurePhaseGD[InFrame:OutFrame,:],axis=0)
        # Fringe contrast
        for iwl in range(NW):
            wl = WOI[iwl]
            for ib in range(NIN):   
                simu.FringeContrast[iwl,ib] += 1/Ndit*np.abs(np.mean(np.exp(1j*2*np.pi*simu.OPDTrue[InFrame:OutFrame,ib]/wl)))
    
    
    if not display:
        return

    observable = simu.VarOPD
    xrange = np.arange(NIN)
    
    plt.figure(f&#39;Variance OPD @{round(config.PDspectra,2)}µm&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(np.arange(NIN),observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=np.arange(NIN),labels=config.ich, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Baseline&#39;)
    plt.ylabel(&#39;Variance [µm]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1
    
    
    observable = simu.TempVarPD*(config.PDspectra/2/np.pi)
    
    plt.figure(f&#39;Variance Estimated PD @{round(config.PDspectra,2)}µm&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(np.arange(NIN),observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=np.arange(NIN),labels=config.ich, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Baseline&#39;)
    plt.ylabel(&#39;Variance [µm]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1
    
    
    observable = simu.TempVarGD*(config.PDspectra/2/np.pi)*config.FS[&#39;R&#39;]
    
    plt.figure(f&#39;Variance Estimated GD @{round(config.PDspectra,2)}µm&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(np.arange(NIN),observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=np.arange(NIN),labels=config.ich, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Baseline&#39;)
    plt.ylabel(&#39;Variance [µm]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1
    
    
    observable = simu.VarCPD
    xrange = np.arange(config.NC)
    
    plt.figure(&#39;Variance CPD&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(xrange,observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=xrange,labels=config.CPindex, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Triangle&#39;)
    plt.ylabel(&#39;Variance [rad]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1


    observable = simu.VarCGD
    
    plt.figure(&#39;Variance CGD&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(xrange,observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=xrange,labels=config.CPindex, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Triangle&#39;)
    plt.ylabel(&#39;Variance [rad]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1

    
    plt.figure(&#39;Integrated Visibility&#39;)    
    plt.ylim([0.9*np.min(simu.FringeContrast),1.1])
    for ib in range(NIN):
        plt.scatter(WOI,simu.FringeContrast[:,ib], label=f&#39;{config.ich[ib]}&#39;)
        
    plt.legend(), plt.grid()
    plt.show()
    config.newfig += 1
    
    return    


def SpectralAnalysis(OPD = (1,2)):
    &#34;&#34;&#34;
    Plot the three Transfer Function of the servo loop controlling the OPD between
    the telescopes OPD[0] and OPD[1]

    Parameters
    ----------
    OPD : TYPE, optional
        DESCRIPTION. The default is (1,2).

    Returns
    -------
    None.

    &#34;&#34;&#34;
    from . import simu
    from .config import NA, NT, dt, latency
    
    tel1 = OPD[0]-1
    tel2 = OPD[1]-1
    
    ib = coh_tools.posk(tel1, tel2, NA)
    
    FrequencySampling = np.fft.fftfreq(NT, dt*1e-3)
    PresentFrequencies = (FrequencySampling &gt;= 0) &amp; (FrequencySampling &lt; 200)
    FrequencySampling = FrequencySampling[PresentFrequencies]
    
    Residues = simu.OPDTrue[:,ib]
    Turb = simu.OPDDisturbance[:,ib]
    Command = simu.OPDCommand[:,ib]
    
    FTResidues = np.fft.fft(Residues)[PresentFrequencies]
    FTTurb = np.fft.fft(Turb)[PresentFrequencies]
    FTCommand = np.fft.fft(Command[:-latency])[PresentFrequencies]
    
    FTrej = FTResidues/FTTurb
    FTBO = FTCommand/FTResidues
    FTBF = FTCommand/FTTurb


    plt.figure(&#39;Rejection Transfer Function&#39;)
    plt.plot(FrequencySampling, np.abs(FTrej))
    # plt.plot(FrequencySampling, FrequencySampling*10**(-2), linestyle=&#39;--&#39;)
    plt.xlabel(&#39;Frequencies [Hz]&#39;)
    plt.ylabel(&#39;Normalised&#39;)
    plt.xscale(&#39;log&#39;)
    plt.yscale(&#39;log&#39;)
    plt.show()
    
    plt.figure(&#39;FTBO&#39;)
    plt.plot(FrequencySampling, np.abs(FTBO))
    plt.xlabel(&#39;Frequencies [Hz]&#39;)
    plt.ylabel(&#39;Normalised&#39;)
    plt.xscale(&#39;log&#39;)
    plt.yscale(&#39;log&#39;)
    plt.show()
    
    plt.figure(&#39;FTBF&#39;)
    plt.plot(FrequencySampling, np.abs(FTBF))
    plt.xlabel(&#39;Frequencies [Hz]&#39;)
    plt.ylabel(&#39;Normalised&#39;)
    plt.xscale(&#39;log&#39;)
    plt.yscale(&#39;log&#39;)
    plt.show()


def FSdefault(NA, NW):
    &#34;&#34;&#34;
    NEEDS TO BE UPDATE FOR BEING USED
    
    Simplest Fringe Sensor to be run with COH_LIB
    This procedure implements the P2V matrix of the simplest fringe sensor for the coh library.
    The principles are that:
        - the raw image is equal to the coherence
        - so that the coherence can be directly estimated from the image
        - but since image is real &amp; coherence is complex, a conversion is done
        thanks to the transfer matrix created with the lowlevel function coh__matcoher2real.
        - the final image is obtained by spectral reduction (until now, we don&#39;t take spectral
        dimension into account)
        - because the full coherence is estimated, demodulation (calculation of pistons and 
        amplitudes) is very simple and directly performed in coh_fs_default so that it 
        is a low-level self-contained FS used for debugging.
        
    In conclusion, it is just a non realistic, basic FS to close the loop.
    
    STRUCTURES OF IMAGE AND COHERENCE VECTORS:
            - image: [NW, NP] the mutual intensities on the detector. In this simple FS, \
        this is directly the real and imaginary parts of coherences. \ 
        (here NP = pixels number = NB = bases number). If this default parameter is given, \
        the function is run in INVERSE mode.
                    
            - coher: [NW, NB] the coherences of all basis. For k = i+NA*j, C_k(i,j) is the \
        complex conjugate of C_k(j,i). (and C_k(i,i) = 1). If this default parameter is given, \
        the function is run in DIRECT mode.

    Parameters
    ----------
    NA : int
        Number of telescopes.
    NW : int
        Number of wavelengths.

    Returns
    -------
    V2PM : [NP,NW] floats
        Visibility to Pixels matrix.
    P2VM : [NW,NP] floats
        Pixels to Visibilities matrix.
    ich : [NP, 3]
        Pixel sorting. There is no ABCD. We keep dimension 2 equal to 3 for 
        compatibility matter.
        If pixel k corresponds to base ij: ich[k] = [i,j,0]

    &#34;&#34;&#34;
    
    NB = NA**2
    NP = NB
    
    matB = coh__matcoher2real(NA)                   # simplest FS: each pixel=coher converted2real
    V2PM = np.reshape(np.repeat(matB[np.newaxis,:],NW,0),[NW,NP,NB])
    matInvB = coh__matcoher2real(NA, &#39;inverse&#39;)      # simplest FS: each pixel=coher converted2real
    P2VM = np.reshape(np.repeat(matInvB[np.newaxis,:],NW,0),[NW,NP,NB])
    
    ich = np.zeros([NP,2])
    for i in range(NA):
            for j in range(NA):
                ich[NA*i+j] = (int(i),int(j))
                
    return V2PM, P2VM, ich


def ReadCf(currCfEstimated):
    &#34;&#34;&#34;
    From measured coherent flux, estimates GD, PD, CP, Photometry, Visibilities
    
    NAME: 
        ReadCf - Calculates the group-delay, phase-delay, closure phase and 
        complex visibility from the coherent flux estimated by the FS
    
        
    INPUT: CfEstimated [MW,NB]
    
    OUTPUT: 
        
    UPDATE:
        - simu.CfPD: Coherent Flux Phase-Delay      [NT,MW,NIN]*1j
        - simu.CfGD: Coherent Flux GD               [NT,MW,NIN]*1j
        - simu.ClosurePhasePD                       [NT,MW,NC]
        - simu.ClosurePhaseGD                       [NT,MW,NC]
        - simu.PhotometryEstimated                  [NT,MW,NA]
        - simu.ComplexVisibility                    [NT,MW,NIN]*1j
        - simu.SquaredCoherenceDegree                      [NT,MW,NIN]
    &#34;&#34;&#34;

    from . import simu
    
    from .config import NA,NIN,NC
    from .config import MW
    
    it = simu.it            # Time
     
    &#34;&#34;&#34;
    Photometries extraction
    [NT,MW,NA]
    &#34;&#34;&#34;
    PhotEst = np.zeros([MW,NA])
    for ia in range(NA):
        PhotEst[:,ia] = np.real(currCfEstimated[:,ia*(NA+1)])
    
    # Extract NIN-sized coherence vector from NB-sized one. 
    # (eliminates photometric and conjugate terms)
    currCfEstimatedNIN = np.zeros([MW, NIN])*1j
    for imw in range(MW):    
        from .coh_tools import NB2NIN
        currCfEstimatedNIN[imw,:] = NB2NIN(currCfEstimated[imw,:])
        
    # Save coherent flux and photometries in stack
    simu.PhotometryEstimated[it] = PhotEst
    
    &#34;&#34;&#34;
    Visibilities extraction
    [NT,MW,NIN]
    &#34;&#34;&#34;
    
    for ia in range(NA):
        for iap in range(ia+1,NA):
            ib = coh_tools.posk(ia,iap,NA)
            Iaap = currCfEstimatedNIN[:,ib]                     # Interferometric intensity (a,a&#39;)
            Ia = PhotEst[:,ia]                                  # Photometry pupil a
            Iap = PhotEst[:,iap]                                # Photometry pupil a&#39;
            simu.ComplexVisibility[it,:,ib] = 2*Iaap/(Ia+Iap)          # Fringe ComplexVisibility of the base (a,a&#39;)
            simu.SquaredCoherenceDegree[it,:,ib] = np.abs(Iaap)**2/(Ia*Iap)      # Spatial coherence of the source on the base (a,a&#39;)
 
    &#34;&#34;&#34;
    Phase-delays extraction
    PD_ is a global stack variable [NT, NIN]
    Eq. 10 &amp; 11
    &#34;&#34;&#34;
    D = 0   # Dispersion correction factor: so far, put to zero because it&#39;s a 
            # calibration term (to define in coh_fs?)
            
    LmbdaTrack = config.PDspectra
    
    # Coherent flux corrected from dispersion
    for imw in range(MW):
        simu.CfPD[it,imw,:] = currCfEstimatedNIN[imw,:]*np.exp(1j*D*(1-LmbdaTrack/config.spectraM[imw])**2)
        
        # If ClosurePhase correction before wrapping
        # simu.CfPD[it,imw] = simu.CfPD[it,imw]*np.exp(-1j*simu.PDref)
        
    # Current Phase-Delay
    currPD = np.angle(np.sum(simu.CfPD[it,:,:], axis=0))
        
    &#34;&#34;&#34;
    Group-Delays extration
    GD_ is a global stack variable [NT, NIN]
    Eq. 15 &amp; 16
    &#34;&#34;&#34;
    
    if MW &lt;= 1:
        raise ValueError(&#39;Tracking mode = GD but no more than one wavelength. \
                         Need several wavelengths for group delay&#39;)              # Group-delay calculation
    
    Ngd = config.FT[&#39;Ngd&#39;]                 # Group-delay DIT
    Ncross = config.FT[&#39;Ncross&#39;]           # Distance between wavelengths channels for GD calculation
    
    if it &lt; Ngd:
        Ngd = it+1
    
    # Integrates GD with Ngd last frames (from it-Ngd to it)
    timerange = range(it+1-Ngd,it+1)
    for iot in timerange:
        cfgd = simu.CfPD[iot]*np.exp(-1j*simu.PDEstimated[iot])/Ngd
        
        # If ClosurePhase correction before wrapping
        # cfgd = cfgd*np.exp(-1j*simu.GDref)
        
        simu.CfGD[it,:,:] += cfgd


    currGD = np.zeros(NIN)
    for ib in range(NIN):
        # cs = 0*1j
        cfGDlmbdas = simu.CfGD[it,:-Ncross,ib]*np.conjugate(simu.CfGD[it,Ncross:,ib])
        cfGDmoy = np.sum(cfGDlmbdas)

            
        currGD[ib] = np.angle(cfGDmoy)    # Group-delay on baseline (ib).
    
    &#34;&#34;&#34;
    Closure phase calculation
    cpPD_ is a global stack variable [NT, NC]
    cpGD_ is a global stack variable [NT, NC]
    Eq. 17 &amp; 18
    CORRECTION: Eq. 18 Lacour érronée --&gt; 
        --&gt; CPgd = arg[sum_{N_l-Ncross}(gamma&#39;&#39;_{i,j,l+Ncross}*conj(gamma&#39;&#39;_{i,j,l}))*sum(....)]
    &#34;&#34;&#34;
    
    Ncp = config.FT[&#39;Ncp&#39;]
    
    if it &lt; Ncp:
        Ncp = it+1
        
    bispectrumPD = np.zeros([NC])*1j
    bispectrumGD = np.zeros([NC])*1j
    
    timerange = range(it+1-Ncp,it+1)
    for ia in range(NA):
        for iap in range(ia+1,NA):
            ib = coh_tools.posk(ia,iap,NA)      # coherent flux (ia,iap)    
            cs1 = np.sum(simu.CfPD[timerange,:,ib], axis=1)     # Sum of coherent flux (ia,iap)
            cfGDlmbdas = simu.CfGD[timerange,Ncross:,ib]*np.conjugate(simu.CfGD[timerange,:-Ncross,ib])
            cfGDmoy1 = np.sum(cfGDlmbdas,axis=1)     # Sum of coherent flux (ia,iap)  
            for iapp in range(iap+1,NA):
                ib = coh_tools.posk(iap,iapp,NA) # coherent flux (iap,iapp)    
                cs2 = np.sum(simu.CfPD[timerange,:,ib], axis=1) # Sum of coherent flux (iap,iapp)    
                cfGDlmbdas = simu.CfGD[timerange,Ncross:,ib]*np.conjugate(simu.CfGD[timerange,:-Ncross,ib])
                cfGDmoy2 = np.sum(cfGDlmbdas,axis=1)
                
                ib = coh_tools.posk(ia,iapp,NA) # coherent flux (iapp,ia)    
                cs3 = np.sum(np.conjugate(simu.CfPD[timerange,:,ib]),axis=1) # Sum of 
                cfGDlmbdas = simu.CfGD[timerange,Ncross:,ib]*np.conjugate(simu.CfGD[timerange,:-Ncross,ib])
                cfGDmoy3 = np.sum(cfGDlmbdas,axis=1)
                
                # The bispectrum of one time and one triangle adds up to
                # the Ncp last times
                ic = coh_tools.poskfai(ia,iap,iapp,NA)        # 0&lt;=ic&lt;NC=(NA-2)(NA-1) 
                
                bispectrumPD[ic]=np.sum(cs1*cs2*cs3)
                bispectrumGD[ic]=np.sum(cfGDmoy1*cfGDmoy2*np.conjugate(cfGDmoy3))
    
    
    
    
    # for iot in range(it+1-Ncp,it+1):          # integration on time Ncp
    #     # cs = 0*1j
    #     for ia in range(NA):
    #         for iap in range(ia+1,NA):
    #             ib = coh_tools.posk(ia,iap,NA)      # coherent flux (ia,iap)    
    #             cs1 = np.sum(simu.CfPD[iot,:,ib])     # Sum of coherent flux (ia,iap)
    #             cfGDlmbdas = simu.CfGD[iot,Ncross:,ib]*np.conjugate(simu.CfGD[iot,:-Ncross,ib])
    #             cfGDmoy1 = np.sum(cfGDlmbdas)     # Sum of coherent flux (ia,iap)  
    #             for iapp in range(iap+1,NA):
    #                 ib = coh_tools.posk(iap,iapp,NA) # coherent flux (iap,iapp)    
    #                 cs2 = np.sum(simu.CfPD[iot,:,ib]) # Sum of coherent flux (iap,iapp)    
    #                 cfGDlmbdas = simu.CfGD[iot,Ncross:,ib]*np.conjugate(simu.CfGD[iot,:-Ncross,ib])
    #                 cfGDmoy2 = np.sum(cfGDlmbdas)
                    
    #                 ib = coh_tools.posk(ia,iapp,NA) # coherent flux (iapp,ia)    
    #                 cs3 = np.sum(np.conjugate(simu.CfPD[iot,:,ib])) # Sum of 
    #                 cfGDlmbdas = simu.CfGD[iot,Ncross:,ib]*np.conjugate(simu.CfGD[iot,:-Ncross,ib])
    #                 cfGDmoy3 = np.sum(cfGDlmbdas)
                    
    #                 # The bispectrum of one time and one triangle adds up to
    #                 # the Ncp last times
    #                 ic = coh_tools.poskfai(ia,iap,iapp,NA)        # 0&lt;=ic&lt;NC=(NA-2)(NA-1) 
                    
    #                 bispectrumPD[ic]+=cs1*cs2*cs3
    #                 bispectrumGD[ic]+=cfGDmoy1*cfGDmoy2*np.conjugate(cfGDmoy3)
                    
    simu.ClosurePhasePD[it] = np.angle(bispectrumPD)
    simu.ClosurePhaseGD[it] = np.angle(bispectrumGD)
    
    if it%Ncp == 0:                     # At time 0, we create the reference vectors
        for ia in range(1,NA-1):
            for iap in range(ia+1,NA):
                k = coh_tools.posk(ia,iap,NA)
                ic = coh_tools.poskfai(0,ia,iap,NA)   # Position of the triangle (0,ia,iap)
                if config.FT[&#39;usePDref&#39;]:
                    simu.PDref[k] = simu.ClosurePhasePD[it,ic]
                    simu.GDref[k] = simu.ClosurePhaseGD[it,ic]
                else:
                    simu.PDref[k] = 0
                    simu.GDref[k] = 0
    
    return currPD, currGD


def SimpleIntegrator(*args, init=False, Ngd=1, Npd=1, Ncp = 1, GainPD=0, GainGD=0,
                      Ncross = 1, CPref=True,roundGD=True,Threshold=True, usePDref=True):
    &#34;&#34;&#34;
    Calculates, from the measured coherent flux, the new positions to send to the delay lines.
    
    INPUT:
        - If init: all the below parameters.
        - If not init: CfEstimated - Measured Coherent Flux   [MW,NB]
    
    OUTPUT:
        - currCmd: Piston Command to send to the ODL     [NA]
    
    USED OBSERVABLES:
        - config.FT
    UPDATED OBSERVABLES:
        - simu.PDEstimated: [MW,NIN] Estimated PD before subtraction of the reference
        - simu.GDEstimated: [MW,NIN] Estimated GD before subtraction of the reference
        - simu.CommandODL: Piston Command to send       [NT,NA]
        
    SUBROUTINES:
        - ReadCf
        - SimpleCommandCalc
 
        
    Parameters
    ----------
    *args : ARRAY [MW,NB]
        Expect current CfEstimated.
    init : BOOLEAN, optional
        If True, initialize the below parameters.
        Needs to be called before starting the simulation.
        The default is False.
    Npd : INT, optional
        Frame integration PD. The default is 1.
    Ngd : INT, optional
        Frame integration GD. The default is 1.
    Ncp : INT, optional
        Frame integration CP. The default is 1.
    GainPD : FLOAT, optional
        Gain PD. The default is 0.
    GainGD : FLOAT, optional
        Gain GD. The default is 0.
    Ncross : INT, optional
        Separation between two spectral channels for GD calculation. 
        The default is 1.
    CPref : BOOLEAN, optional
        If False, the Closure Phase is not subtracted for reference. 
        The default is True.
    roundGD : BOOLEAN, optional
        If True, the GD command is rounded to wavelength integers. 
        Advised to avoid a superposition of the PD and GD commands.
        The default is True.

    Returns
    -------
    currCmd : ARRAY [NA]
        Piston Command to send to the ODL.

    &#34;&#34;&#34;
    
    if init:
        config.FT[&#39;Name&#39;] = &#39;integrator&#39;
        config.FT[&#39;func&#39;] = SimpleIntegrator
        config.FT[&#39;GainPD&#39;] = GainPD
        config.FT[&#39;Npd&#39;] = Npd
        config.FT[&#39;Ngd&#39;] = Ngd
        config.FT[&#39;Ncp&#39;] = Ncp
        config.FT[&#39;GainGD&#39;] = GainGD
        config.FT[&#39;GainPD&#39;] = GainPD
        config.FT[&#39;Ncross&#39;] = Ncross
        config.FT[&#39;CPref&#39;] = CPref
        config.FT[&#39;roundGD&#39;] = roundGD
        config.FT[&#39;Threshold&#39;] = Threshold
        config.FT[&#39;cmdOPD&#39;] = True
        config.FT[&#39;usePDref&#39;] = usePDref
        
        from .config import NIN,NA
        config.FT[&#39;Piston2OPD&#39;] = np.zeros([NIN,NA])    # Piston to OPD matrix
        config.FT[&#39;OPD2Piston&#39;] = np.zeros([NA,NIN])    # OPD to Piston matrix
        
        from .coh_tools import posk
        
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                config.FT[&#39;Piston2OPD&#39;][ib,ia] = 1
                config.FT[&#39;Piston2OPD&#39;][ib,iap] = -1
                config.FT[&#39;OPD2Piston&#39;][ia,ib] = 1
                config.FT[&#39;OPD2Piston&#39;][iap,ib] = -1

        config.FT[&#39;OPD2Piston&#39;] = config.FT[&#39;OPD2Piston&#39;]/NA
        
        if config.TELref:
            iTELref = config.TELref - 1
            L_ref = config.FT[&#39;OPD2Piston&#39;][iTELref,:]
            config.FT[&#39;OPD2Piston&#39;] = config.FT[&#39;OPD2Piston&#39;] - L_ref
        
        print(f&#34;*** \n Inititilise Integrator: \n GainPD={GainPD} ; GainGD={GainGD} \n \
Ngd={Ngd} ; Type={config.FT[&#39;Name&#39;]} \n\ ***&#34;)
              
        return
    
    from . import simu
    from .simu import it
    
    currCfEstimated = args[0]
    
    currPD, currGD = ReadCf(currCfEstimated)
    
    simu.PDEstimated[it] = currPD
    simu.GDEstimated[it] = currGD*config.FS[&#39;R&#39;]
    
    currCmd = SimpleCommandCalc(currPD,currGD)
    
    return currCmd
    

def SimpleCommandCalc(currPD,currGD):
    &#34;&#34;&#34;
    Generates the command to send to the optical delay line according to the
    group-delay and phase-delay reduced from the OPDCalculator.

    Parameters
    ----------
    currPD : TYPE
        DESCRIPTION.
    currGD : TYPE
        DESCRIPTION.

    Returns
    -------
    cmd_odl : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from . import simu
    
    from .config import NA,NB,NIN
    from .config import FT
    
    it = simu.it            # Frame number
    
    &#34;&#34;&#34;
    Group-Delay tracking
    &#34;&#34;&#34;
    
    currGDerr = currGD - simu.GDref
    
    # Keep the GD between [-Pi, Pi] (because the GDref could have make it
    # leave this interval)
    # Eq. 35
    
    for ib in range(NIN):
        if currGDerr[ib] &gt; np.pi:
            currGDerr[ib] -= 2*np.pi
        elif currGDerr[ib] &lt; -np.pi:
            currGDerr[ib] += 2*np.pi
    
    R = config.FS[&#39;R&#39;]
    
    # Store residual GD for display only [radians]
    simu.GDResidual[it] = currGDerr*R

    
    if FT[&#39;Threshold&#39;]:             # Threshold function (eq.36)
        for ib in range(NIN):
            if currGDerr[ib] &gt; np.pi/R:
                currGDerr[ib] -= np.pi/R
            elif currGDerr[ib] &lt; -np.pi/R:
                currGDerr[ib] += np.pi/R
            else:
                currGDerr[ib] = 0
    
    
    # Integrator (Eq.37)
    &#34;&#34;&#34;
    ATTENTION: The GD estimated doesn&#39;t have a telescope of reference. It&#39;s
    according to the average
    &#34;&#34;&#34;
    if FT[&#39;cmdOPD&#39;]:     # integrator on OPD
        # Integrator
        simu.GDCommand[it] = simu.GDCommand[it-1] + FT[&#39;GainGD&#39;]*currGDerr
        # From OPD to Pistons
        simu.PistonGDCommand[it] = np.dot(FT[&#39;OPD2Piston&#39;], simu.GDCommand[it])
        
    else:                       # integrator on PD
        # From OPD to Piston
        currPistonGD = np.dot(FT[&#39;OPD2Piston&#39;], currGDerr)
        # Integrator
        simu.PistonGDCommand[it] = simu.PistonGDCommand[it-1] + FT[&#39;GainPD&#39;]*currPistonGD
    
    uGD = simu.PistonGDCommand[it]
    
    if config.FT[&#39;roundGD&#39;]:
        for ia in range(NA):
            jumps = round(uGD[ia]/config.PDspectra)
            uGD[ia] = jumps*config.PDspectra
            
    
    &#34;&#34;&#34;
    Phase-Delay command
    &#34;&#34;&#34;
    
    currPDerr = currPD - simu.PDref
 
    # Keep the PD between [-Pi, Pi]
    # Eq. 35
    for ib in range(NIN):
        if currPDerr[ib] &gt; np.pi:
            currPDerr[ib] -= 2*np.pi
        elif currPDerr[ib] &lt; -np.pi:
            currPDerr[ib] += 2*np.pi
    
    # Store residual PD for display only [radians]
    simu.PDResidual[it] = currPDerr
    
    if config.FT[&#39;cmdOPD&#39;]:     # integrator on OPD
        # Integrator
        simu.PDCommand[it] = simu.PDCommand[it-1] + FT[&#39;GainPD&#39;]*currPDerr
        # From OPD to Pistons
        simu.PistonPDCommand[it] = np.dot(FT[&#39;OPD2Piston&#39;], simu.PDCommand[it])
        
    else:                       # integrator on PD
        # From OPD to Piston
        currPistonPD = np.dot(FT[&#39;OPD2Piston&#39;], currPDerr)
        # Integrator
        simu.PistonPDCommand[it] = simu.PistonPDCommand[it-1] + FT[&#39;GainPD&#39;]*currPistonPD
    
    uPD = simu.PistonPDCommand[it]

    &#34;&#34;&#34;
    ODL command
    It is the addition of the GD, PD, SEARCH and modulation functions
    &#34;&#34;&#34;
    
    CommandODL = uPD + uGD
    
    return CommandODL


def addnoiseADU(inputADU):
    &#34;&#34;&#34;
    Add Noise to ADU image

    Parameters
    ----------
    inputADU : TYPE
        DESCRIPTION.
    sensitivity : TYPE, optional
        DESCRIPTION. The default is 5.88.
    dark_noise : TYPE, optional
        DESCRIPTION. The default is 2.
    floor : TYPE, optional
        DESCRIPTION. The default is 3.

    Returns
    -------
    image : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from .config import ron, G, enf
    
    (seedph, seedron, seeddist) = (config.seedph,config.seedron,config.seeddist)
    
    # Add SHOT noise
    rs = np.random.RandomState(seedph)
    photonADU = rs.poisson(inputADU/enf, size=inputADU.shape)*enf
    
    # Add DARK noise.
    rs = np.random.RandomState(seedron)
    ronADU = rs.normal(scale=ron/G, size=photonADU.shape) + photonADU
        
    # Quantify ADU
    ADU_out = np.round(ronADU)
    
    
    return ADU_out

# =============================================================================
# Low-level functions:
# =============================================================================


def coh__pis2coh(pis, sigma, ampl=[]):
    &#34;&#34;&#34;
    Used in the MakeAtmosphereCoherence function.
    From the two arrays (of dimension NA = number of pupils) containing the pistons 
    and the amplitudes and from the array containing the signal&#39;s spectra, the function 
    build a NAxNA array with all the mutual coherences. This enables to simulate 
    any kind of coherence pattern.
    INPUTS:
        - pis: vector containing the piston in each aperture
        - sigma: the working wavenumber (later, it will be a vector)
        - ampl: a vector containing the amplitude of the electric field in each aperture
                by default, the unitary vector.
    OUTPUT:
        - coher: [NW,NB] matrix containing the mutual coherences
    &#34;&#34;&#34;
    
    
    NA = len(pis)
    NW = len(sigma)
    pis = np.reshape(pis, [NA,1])
    
    if len(ampl) == 0:
        ampl = np.ones([NW,NA])
    
    phasor = ampl * np.exp(2j*np.pi*np.dot(np.reshape(sigma, [NW,1]),\
                                           np.transpose(pis)))

    coher = coh__phasor2coher(phasor, NA, NW)
    
    return coher

def coh__phasor2coher(phasor, NA, NW):
    
    coher = np.zeros([NW, NA, NA])*1j
    for iw in range(NW):
        phasor_iw = np.reshape(phasor[iw,:],[1,NA])
        coher[iw,:] = np.dot(np.transpose(phasor_iw),np.conjugate(phasor_iw))
    
    coher = np.reshape(coher, [NW, NA*NA])
    return coher

def coh__matcoher2real(NA, *args):
    &#39;&#39;&#39;
    Create a transfer matrix which convert conjugate coherences (complex numbers) into 
    intensities (real numbers)
    INPUTS:
        - NA: number of apertures (arms)
        - *args: can enter &#39;inverse&#39; to use inverse mode
    OUTPUT:
        - MatB: 
            if direct: coherences to intensities transfert matrix
            if indirect: intensities to coherences transfert matrix
    &#39;&#39;&#39;
    
    NB = NA**2
    MatB = np.zeros([NB,NB])*1j
    s2 = np.sqrt(0.5)
    MO = 1j*np.zeros([NA,NA,NA,NA])
    
    # first level (ia,iap) targets the real or imag domain.
    # Second level (ia,iap) targets the direct or conjugate coherence.
    for ia in range(NA):
        MO[ia,ia,ia,ia]=1
        for iap in np.arange(ia+1,NA):
            MO[ia,iap,ia,iap]=s2                # in (ia, iap) we store
            MO[ia,iap,iap,ia]=s2                # real parts
            MO[iap,ia,ia,iap]=1j*s2             # in (iap, ia) we store
            MO[iap,ia,iap,ia]=-1j*s2            # imaginary parts
    MatB = np.reshape(MO, (NB,NB))          # the matrix is unwrapped
    
    if &#39;inverse&#39; in args:
        MatB = np.conjugate(np.transpose(MatB))
    
    return MatB</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="coh_lib.skeleton.FSdefault"><code class="name flex">
<span>def <span class="ident">FSdefault</span></span>(<span>NA, NW)</span>
</code></dt>
<dd>
<div class="desc"><p>NEEDS TO BE UPDATE FOR BEING USED</p>
<p>Simplest Fringe Sensor to be run with COH_LIB
This procedure implements the P2V matrix of the simplest fringe sensor for the coh library.
The principles are that:
- the raw image is equal to the coherence
- so that the coherence can be directly estimated from the image
- but since image is real &amp; coherence is complex, a conversion is done
thanks to the transfer matrix created with the lowlevel function coh__matcoher2real.
- the final image is obtained by spectral reduction (until now, we don't take spectral
dimension into account)
- because the full coherence is estimated, demodulation (calculation of pistons and
amplitudes) is very simple and directly performed in coh_fs_default so that it
is a low-level self-contained FS used for debugging.</p>
<p>In conclusion, it is just a non realistic, basic FS to close the loop.</p>
<p>STRUCTURES OF IMAGE AND COHERENCE VECTORS:
- image: [NW, NP] the mutual intensities on the detector. In this simple FS,
this is directly the real and imaginary parts of coherences. \
(here NP = pixels number = NB = bases number). If this default parameter is given,
the function is run in INVERSE mode.</p>
<pre><code>    - coher: [NW, NB] the coherences of all basis. For k = i+NA*j, C_k(i,j) is the         complex conjugate of C_k(j,i). (and C_k(i,i) = 1). If this default parameter is given,         the function is run in DIRECT mode.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>NA</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of telescopes.</dd>
<dt><strong><code>NW</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of wavelengths.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>V2PM</code></strong> :&ensp;<code>[NP,NW] floats</code></dt>
<dd>Visibility to Pixels matrix.</dd>
<dt><strong><code>P2VM</code></strong> :&ensp;<code>[NW,NP] floats</code></dt>
<dd>Pixels to Visibilities matrix.</dd>
<dt><strong><code>ich</code></strong> :&ensp;<code>[NP, 3]</code></dt>
<dd>Pixel sorting. There is no ABCD. We keep dimension 2 equal to 3 for
compatibility matter.
If pixel k corresponds to base ij: ich[k] = [i,j,0]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FSdefault(NA, NW):
    &#34;&#34;&#34;
    NEEDS TO BE UPDATE FOR BEING USED
    
    Simplest Fringe Sensor to be run with COH_LIB
    This procedure implements the P2V matrix of the simplest fringe sensor for the coh library.
    The principles are that:
        - the raw image is equal to the coherence
        - so that the coherence can be directly estimated from the image
        - but since image is real &amp; coherence is complex, a conversion is done
        thanks to the transfer matrix created with the lowlevel function coh__matcoher2real.
        - the final image is obtained by spectral reduction (until now, we don&#39;t take spectral
        dimension into account)
        - because the full coherence is estimated, demodulation (calculation of pistons and 
        amplitudes) is very simple and directly performed in coh_fs_default so that it 
        is a low-level self-contained FS used for debugging.
        
    In conclusion, it is just a non realistic, basic FS to close the loop.
    
    STRUCTURES OF IMAGE AND COHERENCE VECTORS:
            - image: [NW, NP] the mutual intensities on the detector. In this simple FS, \
        this is directly the real and imaginary parts of coherences. \ 
        (here NP = pixels number = NB = bases number). If this default parameter is given, \
        the function is run in INVERSE mode.
                    
            - coher: [NW, NB] the coherences of all basis. For k = i+NA*j, C_k(i,j) is the \
        complex conjugate of C_k(j,i). (and C_k(i,i) = 1). If this default parameter is given, \
        the function is run in DIRECT mode.

    Parameters
    ----------
    NA : int
        Number of telescopes.
    NW : int
        Number of wavelengths.

    Returns
    -------
    V2PM : [NP,NW] floats
        Visibility to Pixels matrix.
    P2VM : [NW,NP] floats
        Pixels to Visibilities matrix.
    ich : [NP, 3]
        Pixel sorting. There is no ABCD. We keep dimension 2 equal to 3 for 
        compatibility matter.
        If pixel k corresponds to base ij: ich[k] = [i,j,0]

    &#34;&#34;&#34;
    
    NB = NA**2
    NP = NB
    
    matB = coh__matcoher2real(NA)                   # simplest FS: each pixel=coher converted2real
    V2PM = np.reshape(np.repeat(matB[np.newaxis,:],NW,0),[NW,NP,NB])
    matInvB = coh__matcoher2real(NA, &#39;inverse&#39;)      # simplest FS: each pixel=coher converted2real
    P2VM = np.reshape(np.repeat(matInvB[np.newaxis,:],NW,0),[NW,NP,NB])
    
    ich = np.zeros([NP,2])
    for i in range(NA):
            for j in range(NA):
                ich[NA*i+j] = (int(i),int(j))
                
    return V2PM, P2VM, ich</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.MakeAtmosphereCoherence"><code class="name flex">
<span>def <span class="ident">MakeAtmosphereCoherence</span></span>(<span>filepath, InterferometerFile, overwrite=False, spectra=[], RefLambda=0, NT=1000, dt=1, ampl=0, seed=100, dist='step', startframe=10, f_fin=200, r0=0.15, t0=10, L0=25, direction=0, d=1, debug=False, tel=0, highCF=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>CREATES or LOAD a disturbance scheme INTO or FROM a FITSFILE.
If filepath is empty, raise error.
If filepath already exists and overwrite is False:
the disturbance pattern is loaded and its Coherent Flux is returned.
If filepath doesn't exist or overwrite is True:
a new disturbance pattern is created and saved to filepath according to
the parameters.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li>coh: dictionnary which defines the interferometer: contains NA = number of apertures</li>
<li>ampl: amplitude of the piston disturbance</li>
<li>dist: disturbance model chosen<ul>
<li>'scan': a simple case disturbance to begin</li>
<li>'random': a randomly generated set of pistons with modelisation:<ul>
<li>if highCF=True: high cutoff frequency </li>
<li>if highCF=False: no high cutoff frequency</li>
</ul>
</li>
</ul>
</li>
<li>startframe: disturbance starting frame</li>
</ul>
<p>FITS STRUCTURE:
-PRIMARY:
- HEADER:
hdr['TYPE'] =dist
hdr['AMPL'] = ampl
hdr['TEL'] = tel
- HDU1: [ImageHDU] RealCf
- HDU2: [ImageHDU] ImagCf
- HDU3: [ImageHDU] Piston
- HDU4: [ImageHDU] Transmission
- if random:
-HDU5: [ImageHDU] DisturbancePSD
-HDU6: [ImageHDU] FreqSampling</p>
<h2 id="output">Output</h2>
<ul>
<li>CoherentFlux: [NTxNWxNB] the coherence matrix resulting from all pairs of apertures</li>
<li>OPTIONAL PistonDisturbance: [NTxNWxNB] pistons</li>
<li>OPTIONAL TransmissionDisturbance: [NTxNWxNB] amplitudes</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MakeAtmosphereCoherence(filepath, InterferometerFile, overwrite=False,
                            spectra=[], RefLambda=0, NT=1000,dt=1,
                            ampl=0, seed=100, dist=&#39;step&#39;, startframe = 10, 
                            f_fin=200,
                            r0=0.15,t0=10, L0=25, direction=0, d=1,
                            debug=False, tel=0, highCF=True,**kwargs):
    &#39;&#39;&#39;
    CREATES or LOAD a disturbance scheme INTO or FROM a FITSFILE.
    If filepath is empty, raise error.
    If filepath already exists and overwrite is False: 
        the disturbance pattern is loaded and its Coherent Flux is returned.
    If filepath doesn&#39;t exist or overwrite is True:
        a new disturbance pattern is created and saved to filepath according to
        the parameters.
    
    INPUTS:
        - coh: dictionnary which defines the interferometer: contains NA = number of apertures
        - ampl: amplitude of the piston disturbance
        - dist: disturbance model chosen
            - &#39;scan&#39;: a simple case disturbance to begin
            - &#39;random&#39;: a randomly generated set of pistons with modelisation:
                - if highCF=True: high cutoff frequency 
                - if highCF=False: no high cutoff frequency
        - startframe: disturbance starting frame
    
    FITS STRUCTURE:
        -PRIMARY:
            - HEADER:
                hdr[&#39;TYPE&#39;] =dist
                hdr[&#39;AMPL&#39;] = ampl
                hdr[&#39;TEL&#39;] = tel
        - HDU1: [ImageHDU] RealCf
        - HDU2: [ImageHDU] ImagCf
        - HDU3: [ImageHDU] Piston
        - HDU4: [ImageHDU] Transmission
        - if random:
            -HDU5: [ImageHDU] DisturbancePSD
            -HDU6: [ImageHDU] FreqSampling
        
    OUTPUT:
        - CoherentFlux: [NTxNWxNB] the coherence matrix resulting from all pairs of apertures
        - OPTIONAL PistonDisturbance: [NTxNWxNB] pistons
        - OPTIONAL TransmissionDisturbance: [NTxNWxNB] amplitudes
    &#39;&#39;&#39;
    
    import os
    from astropy.io import fits

    if len(filepath) == 0:
        raise Exception(&#39;No disturbance filepath given.&#39;)
        
    elif os.path.exists(filepath):
        print(f&#39;Disturbance file {filepath} exists.&#39;)
        if overwrite:
            os.remove(filepath)
            print(f&#39;Parameter OVERWRITE is {overwrite}.&#39;)
        else:
            print(f&#39;Parameter OVERWRITE is {overwrite}. Loading the disturbance scheme.&#39;)
            
            with fits.open(filepath) as hdu:
                CoherentFlux = hdu[&#39;RealCf&#39;].data + hdu[&#39;ImagCf&#39;].data*1j
                timestamps = hdu[&#39;TimeSampling&#39;].data[&#39;timestamps&#39;]
                spectra = hdu[&#39;SpectralSampling&#39;].data[&#39;spectra&#39;]
                
            return CoherentFlux, timestamps, spectra
       
    else:
        print(f&#39;Creating the disturbance pattern and saving it in {filepath}&#39;)
        

    if not os.path.exists(InterferometerFile):
        raise Exception(f&#34;{InterferometerFile} doesn&#39;t exist.&#34;)
    
    with fits.open(InterferometerFile) as hdu:
        ArrayParams = hdu[0].header
        NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
        ArrayName = ArrayParams[&#39;NAME&#39;]
        # TelData = hdu[1].data
        BaseData = hdu[2].data
        
        # TelNames = TelData[&#39;TelNames&#39;]
        # TelCoordinates = TelData[&#39;TelCoordinates&#39;]
        # BaseNames = BaseData[&#39;BaseNames&#39;]
        BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
    
    NB = NA**2
    NW = len(spectra)
    Lc = np.abs(1/(spectra[0]-spectra[1]))      # Coherence length
    
    if not RefLambda:
        RefLmbda = np.mean(spectra)
    
    obstime = NT*dt                     # Observation time [ms]
    timestamps = np.arange(NT)*dt        # Time sampling [ms]
    
    PistonDisturbance = np.zeros([NT,NA])
    TransmissionDisturbance = np.ones([NT,NW,NA])
    lmbdamin = 1/np.max(spectra)
    
    # np.random.seed(seed)

    if dist == &#39;coherent&#39;:
        print(&#39;No piston&#39;)
        
    elif dist == &#39;step&#39;:
        if tel &lt;=0:
            itel=0
        else:
            itel = tel-1
        PistonDisturbance[startframe:,itel] = ampl*np.ones(NT-startframe)
        
    elif dist == &#39;pair&#39;:
        PistonDisturbance[startframe:,:2] = ampl*np.ones([NT-startframe,2])
        
    elif dist == &#39;kstep&#39;:
        T = int(0.8*NT/NA)
        t = int(0.5*T)
        for ia in range(NA):
            PistonDisturbance[startframe+T*ia:startframe+T*ia+t,ia] = ampl*np.ones(t)
        
    # elif dist == &#39;scan&#39;:
    #     for ia in range(NA):
    #         PistonDisturbance[:,ia] = ampl*(-1)**(ia+1)*((0.5*ia+np.arange(NT))/NT-0.5)  # pistons in µm
    
    elif dist == &#39;slope&#39;:
        PistonDisturbance[:,1] = 0.2+np.arange(NT)/NT * ampl
        
    # The first telil sees a range of piston from -Lc to Lc
    elif dist == &#39;browse&#39;:
        PistonDisturbance[:,1] = (np.arange(NT)/NT - 1/2) * 2*Lc
    
    elif dist == &#39;random&#39;:
        
        if &#39;old&#39; in kwargs.keys():
            rmsPiston = ampl/np.sqrt(2)
            
            freq = np.fft.fftshift(np.fft.fftfreq(NT,d=dt*1e-3))
            freqfft=freq
            Fc = 100            # Maximal frequency of the atmosphere
            Fmax = np.max(freq)
            Nc = int(Fc*NT/2/Fmax)
            filtre = np.zeros(NT)
    
            # Atmospheric disturbance from Conan et al 1995
            for i in range(NT):
                if freq[i] &lt; 0.02:
                    filtre[i] = 0
                elif freq[i] &gt;= 0.02 or freq[i] &lt; 3:    # Low frequencies regime 
                    filtre[i] = freq[i]**(-4/3)
                else:                                   # High frequencies regime
                    filtre[i] = freq[i]**(-8.5/3)
            print(Fmax,freq[1]-freq[0],dt*1e-3,NT)
            filtre = filtre/np.max(filtre)
    
            if tel:                     # Disturbances on only one pupil
                itel = tel - 1
                dsp = np.fft.fftshift(np.fft.fft(np.random.randn(NT)))
                
                newdsp = dsp*filtre
                motif = np.real(np.fft.ifft(np.fft.ifftshift(newdsp)))
    
                PistonDisturbance[:,itel]= rmsPiston*motif/np.std(motif)/3
            
            else:
                for ia in range(NA):
                    
                    dsp = np.fft.fftshift(np.fft.fft(np.random.randn(NT)))
                    newdsp = dsp*filtre
                    motif = np.real(np.fft.ifft(np.fft.ifftshift(newdsp)))
        
                    PistonDisturbance[:,ia]= rmsPiston*motif/np.std(motif)/3

            # simu.DisturbancePSD = np.abs(newdsp[freqfft&gt;=0])**2    # Save the PSD of the last disturbance for example
            # simu.FreqSampling = freqfft[freqfft&gt;=0]

        else:           # Inspired from Conan but more smooth
            if &#39;baselines&#39; in kwargs.keys():
                baselines = kwargs[&#39;baselines&#39;]
            else:
                _,_,basedist,coords = coh_tools.get_array(config.Name, getcoords=True)
                
                
                
                baselines = np.zeros(NIN)
                for ia in range(NA):
                    for iap in range(ia+1,NA):
                        ib=coh_tools.posk(ia,iap,NA)
                        baselines[ib] = np.abs(basedist[ia*NA+iap])
                
                baselines = np.linalg.norm(BaseCoordinates, axis=1)
            
            V = 0.31*r0/t0*1e3              # Average wind velocity in its direction [m/s]
            L0 = L0                         # Outer scale [m]
            direction = direction           # Orientation from the North [deg] (positive toward East)
            d = d                           # Telescopes diameter [m]
                
            if ampl==0:
                wl_r0 = 0.55                # Wavelength at which r0 is defined
                ampl = np.sqrt(6.88*(L0/r0)**(5/3))*wl_r0/(2*np.pi)    # microns
                rmsPiston = ampl/np.sqrt(2)
                print(f&#39;RMS OPD={ampl}&#39;)
            # if &#39;V&#39; in kwargs.keys():
            #     V = kwargs[&#39;V&#39;]
            # if &#39;direction&#39; in kwargs.keys():
            #     direction = kwargs[&#39;direction&#39;]
            # if &#39;L0&#39; in kwargs.keys():
            #     L0 = kwargs[&#39;L0&#39;]
            # if &#39;d&#39; in kwargs.keys():
            #     d = kwargs[&#39;d&#39;]

            for ia in range(NA):
                if tel:                 # Disturbances on only one pupil
                    itel = tel - 1
                    if ia != itel:
                        continue
    
                tstart=time.perf_counter()
                print(f&#39;Piston on pupil {ia}&#39;)
    
                dfreq = 0.008                           # Minimal sampling wished
                freqmax = 1/(2*dt*1e-3)                  # Maximal frequency derived from given temporal sampling
                
                Npix = int(freqmax/dfreq)*2         # Array length (taking into account aliasing)
                
                dsp = np.fft.fftshift(np.fft.fft(np.random.randn(Npix)))
                freqfft = (np.arange(Npix)-Npix//2)*dfreq
                timefft = (np.arange(Npix)-Npix//2)*dt  #ms
                
    
                nu0 = 0.2*V/L0                 # Low cut-off frequency
                nu1 = 0.3*V/d                  # High cut-off frequency
    
                print(f&#39;Atmospheric cutoff frequencies: {nu0:.2}Hz and {nu1:.2}Hz&#39;)
                
                if highCF:
                    filtre = np.zeros(Npix)
                    # print(&#39;Number of pixels:&#39;,Npix)
                    for i in range(Npix):
                        checkpoint = int(Npix/10)
                        if i%checkpoint == 0:
                            print(f&#39;Filtering....{i/Npix*100}%&#39;)
                        if freqfft[i] == 0:
                            filtre[i] = 0
                        elif np.abs(freqfft[i]) &lt; nu0:
                            filtre[i] = np.abs(freqfft[i])
                        elif np.abs(freqfft[i]) &gt;= nu0 and np.abs(freqfft[i]) &lt; nu1:
                            b0 = nu0**(5/3)
                            filtre[i] = np.abs(freqfft[i])**(-2/3)*b0
                        else:
                            b1 = nu0**(5/3)*nu1**(6.5/3)
                            filtre[i] = np.abs(freqfft[i])**(-8.5/3)*b1
                    
                    
                &#34;&#34;&#34;
                MOST REALISTIC DISTURBANCE SO FAR
                No high frequency cut
                &#34;&#34;&#34;
                if not highFC:
                    filtre = np.zeros(Npix)
                    # print(&#39;Number of pixels:&#39;,Npix)
                    for i in range(Npix):
                        checkpoint = int(Npix/2)
                        if i%checkpoint == 0:
                            print(f&#39;Filtering....{i/Npix*100}%&#39;)
                        if freqfft[i] == 0:
                            filtre[i] = 0
                        elif np.abs(freqfft[i]) &lt; nu0:
                            filtre[i] = np.abs(freqfft[i])
                        elif np.abs(freqfft[i]) &gt;= nu0: #and np.abs(freqfft[i]) &lt; nu1:
                            b0 = nu0**(7/3)
                            filtre[i] = np.abs(freqfft[i])**(-4/3)*b0
                
                
                filtre = filtre/np.max(filtre)
                
                newdsp = dsp*filtre
                
                motif0 = np.real(np.fft.ifft(np.fft.ifftshift(newdsp), norm=&#34;ortho&#34;))
                keeptime = (timefft&gt;=0)*(timefft&lt;obstime)
                stdtime = (timefft&gt;=0)*(timefft&lt;10000)              # We&#39;ll compute the standard deviation on a sample of 10s
                            
                motif = motif0[keeptime]
    
                calibmotif = motif/np.std(motif0[stdtime])
    
                PistonDisturbance[:,ia] = rmsPiston*calibmotif
                
                PistonDisturbance[:,ia] = PistonDisturbance[:,ia] - PistonDisturbance[startframe,ia]
                ElapsedTime = time.perf_counter() - tstart
                print(f&#39;Done. Ellapsed time: {ElapsedTime}s&#39;)
        
    elif dist == &#39;chirp&#39;:
        f_fin = f_fin*1e-3   # Conversion to kHz
        omega_fin = 2*np.pi*f_fin
        t_fin = timestamps[-1]
        a = omega_fin/(2*t_fin)
        chirp = lambda phi0,t : np.sin(phi0 + a*t**2)
        if tel:
            print(f&#39;CHIRP on telescope {tel}&#39;)
            itel = tel-1
            PistonDisturbance[:,itel] = ampl*chirp(0,timestamps)
            newdsp = np.fft.fftshift(np.fft.fft(PistonDisturbance[:,itel], norm=&#39;ortho&#39;))
            freqfft = np.fft.fftshift(np.fft.fftfreq(NT, dt))
        else:
            for ia in range(NA):
                PistonDisturbance[:,ia] = chirp(ia*2*np.pi/NA,timestamps)
            newdsp = np.fft.fftshift(np.fft.fft(PistonDisturbance[:,-1], norm=&#39;ortho&#39;))
            freqfft = np.fft.fftshift(np.fft.fftfreq(NT, dt))
        # Put first time at null-piston for reference closure phase measurement
        # PistonDisturbance[:startframe] = np.zeros([startframe,NA])

    CoherentFlux = np.zeros([NT,NW,NB])*1j             # dynamical coherence matrix with time dimension NT
    for it in range(NT):
        CoherentFlux[it,:] = coh__pis2coh(PistonDisturbance[it,:], 1/spectra, ampl=TransmissionDisturbance[it,:])


    if debug:
        return CoherentFlux, PistonDisturbance, TransmissionDisturbance
    

    hdr = fits.Header()
    hdr[&#39;TYPE&#39;] =dist
    hdr[&#39;AMPL&#39;] = ampl
    hdr[&#39;TEL&#39;] = tel
    
    primary = fits.PrimaryHDU(header=hdr)
    
    col1 = fits.Column(name=&#39;spectra&#39;, format=&#39;1D&#39;, array=spectra)
    hdu1 = fits.BinTableHDU.from_columns([col1], name=&#39;SpectralSampling&#39; )
    col1 = fits.Column(name=&#39;timestamps&#39;, format=&#39;1D&#39;, array=timestamps)
    hdu2 = fits.BinTableHDU.from_columns([col1], name=&#39;TimeSampling&#39;)
    
    im1 = fits.ImageHDU(np.real(CoherentFlux), name=&#39;RealCf&#39;)
    im2 = fits.ImageHDU(np.imag(CoherentFlux), name=&#39;ImagCf&#39;)
    im3 = fits.ImageHDU(PistonDisturbance, name=&#39;Piston&#39;)
    im4 = fits.ImageHDU(TransmissionDisturbance, name=&#39;Transmission&#39;)
    
    hdu = fits.HDUList([primary,hdu1,hdu2,im1,im2,im3,im4])
    
    if dist == &#39;random&#39; or dist == &#39;chirp&#39;:

        DisturbancePSD = np.abs(newdsp[freqfft&gt;=0])**2      # Save the PSD of the last disturbance for example
        FreqSampling = freqfft[freqfft&gt;=0]                  # FreqSampling in Hz        
        im5 = fits.ImageHDU(DisturbancePSD, name=&#39;LAST TEL PSD&#39;)
        im6 = fits.ImageHDU(FreqSampling, name=&#39;FREQUENCY SAMPLING&#39;)
        im7 = fits.ImageHDU(filtre[freqfft&gt;=0], name=&#39;Disturbance Filter&#39;)
        hdu.append(im5)
        hdu.append(im6)
        hdu.append(im7)

    
    print(f&#39;Saving file into {filepath}&#39;)
    hdu.writeto(filepath)

    
    return CoherentFlux</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.ReadCf"><code class="name flex">
<span>def <span class="ident">ReadCf</span></span>(<span>currCfEstimated)</span>
</code></dt>
<dd>
<div class="desc"><p>From measured coherent flux, estimates GD, PD, CP, Photometry, Visibilities</p>
<p>NAME:
ReadCf - Calculates the group-delay, phase-delay, closure phase and
complex visibility from the coherent flux estimated by the FS</p>
<p>INPUT: CfEstimated [MW,NB]</p>
<p>OUTPUT: </p>
<h2 id="update">Update</h2>
<ul>
<li>simu.CfPD: Coherent Flux Phase-Delay
[NT,MW,NIN]*1j</li>
<li>simu.CfGD: Coherent Flux GD
[NT,MW,NIN]*1j</li>
<li>simu.ClosurePhasePD
[NT,MW,NC]</li>
<li>simu.ClosurePhaseGD
[NT,MW,NC]</li>
<li>simu.PhotometryEstimated
[NT,MW,NA]</li>
<li>simu.ComplexVisibility
[NT,MW,NIN]*1j</li>
<li>simu.SquaredCoherenceDegree
[NT,MW,NIN]</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReadCf(currCfEstimated):
    &#34;&#34;&#34;
    From measured coherent flux, estimates GD, PD, CP, Photometry, Visibilities
    
    NAME: 
        ReadCf - Calculates the group-delay, phase-delay, closure phase and 
        complex visibility from the coherent flux estimated by the FS
    
        
    INPUT: CfEstimated [MW,NB]
    
    OUTPUT: 
        
    UPDATE:
        - simu.CfPD: Coherent Flux Phase-Delay      [NT,MW,NIN]*1j
        - simu.CfGD: Coherent Flux GD               [NT,MW,NIN]*1j
        - simu.ClosurePhasePD                       [NT,MW,NC]
        - simu.ClosurePhaseGD                       [NT,MW,NC]
        - simu.PhotometryEstimated                  [NT,MW,NA]
        - simu.ComplexVisibility                    [NT,MW,NIN]*1j
        - simu.SquaredCoherenceDegree                      [NT,MW,NIN]
    &#34;&#34;&#34;

    from . import simu
    
    from .config import NA,NIN,NC
    from .config import MW
    
    it = simu.it            # Time
     
    &#34;&#34;&#34;
    Photometries extraction
    [NT,MW,NA]
    &#34;&#34;&#34;
    PhotEst = np.zeros([MW,NA])
    for ia in range(NA):
        PhotEst[:,ia] = np.real(currCfEstimated[:,ia*(NA+1)])
    
    # Extract NIN-sized coherence vector from NB-sized one. 
    # (eliminates photometric and conjugate terms)
    currCfEstimatedNIN = np.zeros([MW, NIN])*1j
    for imw in range(MW):    
        from .coh_tools import NB2NIN
        currCfEstimatedNIN[imw,:] = NB2NIN(currCfEstimated[imw,:])
        
    # Save coherent flux and photometries in stack
    simu.PhotometryEstimated[it] = PhotEst
    
    &#34;&#34;&#34;
    Visibilities extraction
    [NT,MW,NIN]
    &#34;&#34;&#34;
    
    for ia in range(NA):
        for iap in range(ia+1,NA):
            ib = coh_tools.posk(ia,iap,NA)
            Iaap = currCfEstimatedNIN[:,ib]                     # Interferometric intensity (a,a&#39;)
            Ia = PhotEst[:,ia]                                  # Photometry pupil a
            Iap = PhotEst[:,iap]                                # Photometry pupil a&#39;
            simu.ComplexVisibility[it,:,ib] = 2*Iaap/(Ia+Iap)          # Fringe ComplexVisibility of the base (a,a&#39;)
            simu.SquaredCoherenceDegree[it,:,ib] = np.abs(Iaap)**2/(Ia*Iap)      # Spatial coherence of the source on the base (a,a&#39;)
 
    &#34;&#34;&#34;
    Phase-delays extraction
    PD_ is a global stack variable [NT, NIN]
    Eq. 10 &amp; 11
    &#34;&#34;&#34;
    D = 0   # Dispersion correction factor: so far, put to zero because it&#39;s a 
            # calibration term (to define in coh_fs?)
            
    LmbdaTrack = config.PDspectra
    
    # Coherent flux corrected from dispersion
    for imw in range(MW):
        simu.CfPD[it,imw,:] = currCfEstimatedNIN[imw,:]*np.exp(1j*D*(1-LmbdaTrack/config.spectraM[imw])**2)
        
        # If ClosurePhase correction before wrapping
        # simu.CfPD[it,imw] = simu.CfPD[it,imw]*np.exp(-1j*simu.PDref)
        
    # Current Phase-Delay
    currPD = np.angle(np.sum(simu.CfPD[it,:,:], axis=0))
        
    &#34;&#34;&#34;
    Group-Delays extration
    GD_ is a global stack variable [NT, NIN]
    Eq. 15 &amp; 16
    &#34;&#34;&#34;
    
    if MW &lt;= 1:
        raise ValueError(&#39;Tracking mode = GD but no more than one wavelength. \
                         Need several wavelengths for group delay&#39;)              # Group-delay calculation
    
    Ngd = config.FT[&#39;Ngd&#39;]                 # Group-delay DIT
    Ncross = config.FT[&#39;Ncross&#39;]           # Distance between wavelengths channels for GD calculation
    
    if it &lt; Ngd:
        Ngd = it+1
    
    # Integrates GD with Ngd last frames (from it-Ngd to it)
    timerange = range(it+1-Ngd,it+1)
    for iot in timerange:
        cfgd = simu.CfPD[iot]*np.exp(-1j*simu.PDEstimated[iot])/Ngd
        
        # If ClosurePhase correction before wrapping
        # cfgd = cfgd*np.exp(-1j*simu.GDref)
        
        simu.CfGD[it,:,:] += cfgd


    currGD = np.zeros(NIN)
    for ib in range(NIN):
        # cs = 0*1j
        cfGDlmbdas = simu.CfGD[it,:-Ncross,ib]*np.conjugate(simu.CfGD[it,Ncross:,ib])
        cfGDmoy = np.sum(cfGDlmbdas)

            
        currGD[ib] = np.angle(cfGDmoy)    # Group-delay on baseline (ib).
    
    &#34;&#34;&#34;
    Closure phase calculation
    cpPD_ is a global stack variable [NT, NC]
    cpGD_ is a global stack variable [NT, NC]
    Eq. 17 &amp; 18
    CORRECTION: Eq. 18 Lacour érronée --&gt; 
        --&gt; CPgd = arg[sum_{N_l-Ncross}(gamma&#39;&#39;_{i,j,l+Ncross}*conj(gamma&#39;&#39;_{i,j,l}))*sum(....)]
    &#34;&#34;&#34;
    
    Ncp = config.FT[&#39;Ncp&#39;]
    
    if it &lt; Ncp:
        Ncp = it+1
        
    bispectrumPD = np.zeros([NC])*1j
    bispectrumGD = np.zeros([NC])*1j
    
    timerange = range(it+1-Ncp,it+1)
    for ia in range(NA):
        for iap in range(ia+1,NA):
            ib = coh_tools.posk(ia,iap,NA)      # coherent flux (ia,iap)    
            cs1 = np.sum(simu.CfPD[timerange,:,ib], axis=1)     # Sum of coherent flux (ia,iap)
            cfGDlmbdas = simu.CfGD[timerange,Ncross:,ib]*np.conjugate(simu.CfGD[timerange,:-Ncross,ib])
            cfGDmoy1 = np.sum(cfGDlmbdas,axis=1)     # Sum of coherent flux (ia,iap)  
            for iapp in range(iap+1,NA):
                ib = coh_tools.posk(iap,iapp,NA) # coherent flux (iap,iapp)    
                cs2 = np.sum(simu.CfPD[timerange,:,ib], axis=1) # Sum of coherent flux (iap,iapp)    
                cfGDlmbdas = simu.CfGD[timerange,Ncross:,ib]*np.conjugate(simu.CfGD[timerange,:-Ncross,ib])
                cfGDmoy2 = np.sum(cfGDlmbdas,axis=1)
                
                ib = coh_tools.posk(ia,iapp,NA) # coherent flux (iapp,ia)    
                cs3 = np.sum(np.conjugate(simu.CfPD[timerange,:,ib]),axis=1) # Sum of 
                cfGDlmbdas = simu.CfGD[timerange,Ncross:,ib]*np.conjugate(simu.CfGD[timerange,:-Ncross,ib])
                cfGDmoy3 = np.sum(cfGDlmbdas,axis=1)
                
                # The bispectrum of one time and one triangle adds up to
                # the Ncp last times
                ic = coh_tools.poskfai(ia,iap,iapp,NA)        # 0&lt;=ic&lt;NC=(NA-2)(NA-1) 
                
                bispectrumPD[ic]=np.sum(cs1*cs2*cs3)
                bispectrumGD[ic]=np.sum(cfGDmoy1*cfGDmoy2*np.conjugate(cfGDmoy3))
    
    
    
    
    # for iot in range(it+1-Ncp,it+1):          # integration on time Ncp
    #     # cs = 0*1j
    #     for ia in range(NA):
    #         for iap in range(ia+1,NA):
    #             ib = coh_tools.posk(ia,iap,NA)      # coherent flux (ia,iap)    
    #             cs1 = np.sum(simu.CfPD[iot,:,ib])     # Sum of coherent flux (ia,iap)
    #             cfGDlmbdas = simu.CfGD[iot,Ncross:,ib]*np.conjugate(simu.CfGD[iot,:-Ncross,ib])
    #             cfGDmoy1 = np.sum(cfGDlmbdas)     # Sum of coherent flux (ia,iap)  
    #             for iapp in range(iap+1,NA):
    #                 ib = coh_tools.posk(iap,iapp,NA) # coherent flux (iap,iapp)    
    #                 cs2 = np.sum(simu.CfPD[iot,:,ib]) # Sum of coherent flux (iap,iapp)    
    #                 cfGDlmbdas = simu.CfGD[iot,Ncross:,ib]*np.conjugate(simu.CfGD[iot,:-Ncross,ib])
    #                 cfGDmoy2 = np.sum(cfGDlmbdas)
                    
    #                 ib = coh_tools.posk(ia,iapp,NA) # coherent flux (iapp,ia)    
    #                 cs3 = np.sum(np.conjugate(simu.CfPD[iot,:,ib])) # Sum of 
    #                 cfGDlmbdas = simu.CfGD[iot,Ncross:,ib]*np.conjugate(simu.CfGD[iot,:-Ncross,ib])
    #                 cfGDmoy3 = np.sum(cfGDlmbdas)
                    
    #                 # The bispectrum of one time and one triangle adds up to
    #                 # the Ncp last times
    #                 ic = coh_tools.poskfai(ia,iap,iapp,NA)        # 0&lt;=ic&lt;NC=(NA-2)(NA-1) 
                    
    #                 bispectrumPD[ic]+=cs1*cs2*cs3
    #                 bispectrumGD[ic]+=cfGDmoy1*cfGDmoy2*np.conjugate(cfGDmoy3)
                    
    simu.ClosurePhasePD[it] = np.angle(bispectrumPD)
    simu.ClosurePhaseGD[it] = np.angle(bispectrumGD)
    
    if it%Ncp == 0:                     # At time 0, we create the reference vectors
        for ia in range(1,NA-1):
            for iap in range(ia+1,NA):
                k = coh_tools.posk(ia,iap,NA)
                ic = coh_tools.poskfai(0,ia,iap,NA)   # Position of the triangle (0,ia,iap)
                if config.FT[&#39;usePDref&#39;]:
                    simu.PDref[k] = simu.ClosurePhasePD[it,ic]
                    simu.GDref[k] = simu.ClosurePhaseGD[it,ic]
                else:
                    simu.PDref[k] = 0
                    simu.GDref[k] = 0
    
    return currPD, currGD</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.SaveSimulation"><code class="name flex">
<span>def <span class="ident">SaveSimulation</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SaveSimulation():
    
    from . import simu
    
    # infosimu = pd.DataFrame(coh)
    
    observables = pd.DataFrame({&#39;timestamp&#39;:timestamps,&#39;PistonDisturbance&#39;:simu.PistonDisturbance,&#39;pis_res&#39;:simu.PistonTrue,&#39;cmd_odl&#39;:simu.CommandODL,\
                               &#39;PD_res&#39;:simu.PDResidual,&#39;GD_res&#39;:simu.GDResidual,&#39;PDCommand&#39;:simu.PDCommand,&#39;GDCommand&#39;:simu.GDCommand,\
                               &#39;rmsPD&#39;:rmsPD_,&#39;rmsGD&#39;:rmsGD_,\
                                   &#39;phot_per&#39;:simu.TransmissionDisturbance,&#39;phot_est&#39;:simu.PhotometryEstimated,&#39;SquaredCoherenceDegree&#39;:simu.SquaredCoherenceDegree})
    
    t2 = Table.from_pandas(df)
    
    currentDT = datetime.datetime.now()
    suffix=currentDT.strftime(&#34;%Y%m%d%H%M&#34;)
    
    fits.writeto(prefix+suffix,np.array(t2))</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.ShowPerformance"><code class="name flex">
<span>def <span class="ident">ShowPerformance</span></span>(<span>TimeBonds, WavelengthOfInterest, DIT, display=True, get=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Processes the performance of the fringe-tracking starting at the StartingTime
Observables processed:
-VarOPD
# Temporal Variance OPD [µm]
-TempVarPD
# Temporal Variance PD [rad]
-TempVarGD
# Temporal Variance of GD [rad]
-VarCPD
# Temporal Variance of CPD [rad]
-VarCGD
# Temporal Variance of CGD [rad]
-FringeContrast
# Fringe Contrast [0,1] at given wavelengths
WavelengthOfInterest</p>
<pre><code>Parameters
----------
TimeBonds : INT or ARRAY [ms]
    If int:
        The performance are processed from StartingTime until the end
    If array [StartingTime,EndingTime]: 
        The performance are processed between StartingTime and EndingTime
WavelengthOfInterest : ARRAY
    Wavelength when the Fringe Contrast needs to be calculated.
DIT : INT
    Integration time of the science instrument [ms]
Returns
-------
None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ShowPerformance(TimeBonds, WavelengthOfInterest,DIT, display=True, get=[]):
    &#34;&#34;&#34;
    Processes the performance of the fringe-tracking starting at the StartingTime
    Observables processed:
        -VarOPD                 # Temporal Variance OPD [µm]
        -TempVarPD              # Temporal Variance PD [rad]
        -TempVarGD              # Temporal Variance of GD [rad]
        -VarCPD                 # Temporal Variance of CPD [rad]
        -VarCGD                 # Temporal Variance of CGD [rad]
        -FringeContrast         # Fringe Contrast [0,1] at given wavelengths
WavelengthOfInterest
        

    Parameters
    ----------
    TimeBonds : INT or ARRAY [ms]
        If int:
            The performance are processed from StartingTime until the end
        If array [StartingTime,EndingTime]: 
            The performance are processed between StartingTime and EndingTime
    WavelengthOfInterest : ARRAY
        Wavelength when the Fringe Contrast needs to be calculated.
    DIT : INT
        Integration time of the science instrument [ms]
    Returns
    -------
    None.

    &#34;&#34;&#34;
    from . import simu
    from . import config
    
    from .config import NIN,dt,NT
    
    WOI = WavelengthOfInterest
    if isinstance(WOI, float):
        WOI = [WOI]    
    NW = len(WOI) 
    
    DIT_NumberOfFrames = int(DIT/dt)
    
    if isinstance(TimeBonds,(float,int)):
        Period = int(NT - TimeBonds/dt)
        InFrame = round(TimeBonds/dt)
    elif isinstance(TimeBonds,(np.ndarray,list)):
        Period = int((TimeBonds[1]-TimeBonds[0])/dt)
        InFrame = round(TimeBonds[0]/dt)
    else:
        raise &#39;&#34;TimeBonds&#34; must be instance of (float,int,np.ndarray,list)&#39;
        
   
    simu.FringeContrast=np.zeros([NW,NIN])      # Fringe Contrast at given wavelengths [0,1]
    
    Ndit = Period//DIT_NumberOfFrames
    for it in range(Ndit):
        InFrame += DIT_NumberOfFrames
        OutFrame = InFrame + DIT_NumberOfFrames
        
        simu.VarOPD += 1/Ndit*np.var(simu.OPDTrue[InFrame:OutFrame,:],axis=0)
        simu.TempVarPD += 1/Ndit*np.var(simu.PDEstimated[InFrame:OutFrame,:],axis=0)
        simu.TempVarGD += 1/Ndit*np.var(simu.GDEstimated[InFrame:OutFrame,:],axis=0)
        simu.VarCPD += 1/Ndit*np.var(simu.ClosurePhasePD[InFrame:OutFrame,:],axis=0)
        simu.VarCGD += 1/Ndit*np.var(simu.ClosurePhaseGD[InFrame:OutFrame,:],axis=0)
        # Fringe contrast
        for iwl in range(NW):
            wl = WOI[iwl]
            for ib in range(NIN):   
                simu.FringeContrast[iwl,ib] += 1/Ndit*np.abs(np.mean(np.exp(1j*2*np.pi*simu.OPDTrue[InFrame:OutFrame,ib]/wl)))
    
    
    if not display:
        return

    observable = simu.VarOPD
    xrange = np.arange(NIN)
    
    plt.figure(f&#39;Variance OPD @{round(config.PDspectra,2)}µm&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(np.arange(NIN),observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=np.arange(NIN),labels=config.ich, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Baseline&#39;)
    plt.ylabel(&#39;Variance [µm]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1
    
    
    observable = simu.TempVarPD*(config.PDspectra/2/np.pi)
    
    plt.figure(f&#39;Variance Estimated PD @{round(config.PDspectra,2)}µm&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(np.arange(NIN),observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=np.arange(NIN),labels=config.ich, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Baseline&#39;)
    plt.ylabel(&#39;Variance [µm]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1
    
    
    observable = simu.TempVarGD*(config.PDspectra/2/np.pi)*config.FS[&#39;R&#39;]
    
    plt.figure(f&#39;Variance Estimated GD @{round(config.PDspectra,2)}µm&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(np.arange(NIN),observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=np.arange(NIN),labels=config.ich, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Baseline&#39;)
    plt.ylabel(&#39;Variance [µm]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1
    
    
    observable = simu.VarCPD
    xrange = np.arange(config.NC)
    
    plt.figure(&#39;Variance CPD&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(xrange,observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=xrange,labels=config.CPindex, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Triangle&#39;)
    plt.ylabel(&#39;Variance [rad]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1


    observable = simu.VarCGD
    
    plt.figure(&#39;Variance CGD&#39;)    
    plt.ylim([np.min(observable),np.max(observable)])
    plt.scatter(xrange,observable)
    plt.hlines(np.mean(observable), xrange[0],xrange[-1],linestyle=&#39;--&#39;)
    plt.xticks(ticks=xrange,labels=config.CPindex, rotation=&#39;vertical&#39;)    
    plt.xlabel(&#39;Triangle&#39;)
    plt.ylabel(&#39;Variance [rad]&#39;)
    plt.grid()
    plt.show()
    config.newfig += 1

    
    plt.figure(&#39;Integrated Visibility&#39;)    
    plt.ylim([0.9*np.min(simu.FringeContrast),1.1])
    for ib in range(NIN):
        plt.scatter(WOI,simu.FringeContrast[:,ib], label=f&#39;{config.ich[ib]}&#39;)
        
    plt.legend(), plt.grid()
    plt.show()
    config.newfig += 1
    
    return    </code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.SimpleCommandCalc"><code class="name flex">
<span>def <span class="ident">SimpleCommandCalc</span></span>(<span>currPD, currGD)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the command to send to the optical delay line according to the
group-delay and phase-delay reduced from the OPDCalculator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>currPD</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>currGD</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cmd_odl</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SimpleCommandCalc(currPD,currGD):
    &#34;&#34;&#34;
    Generates the command to send to the optical delay line according to the
    group-delay and phase-delay reduced from the OPDCalculator.

    Parameters
    ----------
    currPD : TYPE
        DESCRIPTION.
    currGD : TYPE
        DESCRIPTION.

    Returns
    -------
    cmd_odl : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from . import simu
    
    from .config import NA,NB,NIN
    from .config import FT
    
    it = simu.it            # Frame number
    
    &#34;&#34;&#34;
    Group-Delay tracking
    &#34;&#34;&#34;
    
    currGDerr = currGD - simu.GDref
    
    # Keep the GD between [-Pi, Pi] (because the GDref could have make it
    # leave this interval)
    # Eq. 35
    
    for ib in range(NIN):
        if currGDerr[ib] &gt; np.pi:
            currGDerr[ib] -= 2*np.pi
        elif currGDerr[ib] &lt; -np.pi:
            currGDerr[ib] += 2*np.pi
    
    R = config.FS[&#39;R&#39;]
    
    # Store residual GD for display only [radians]
    simu.GDResidual[it] = currGDerr*R

    
    if FT[&#39;Threshold&#39;]:             # Threshold function (eq.36)
        for ib in range(NIN):
            if currGDerr[ib] &gt; np.pi/R:
                currGDerr[ib] -= np.pi/R
            elif currGDerr[ib] &lt; -np.pi/R:
                currGDerr[ib] += np.pi/R
            else:
                currGDerr[ib] = 0
    
    
    # Integrator (Eq.37)
    &#34;&#34;&#34;
    ATTENTION: The GD estimated doesn&#39;t have a telescope of reference. It&#39;s
    according to the average
    &#34;&#34;&#34;
    if FT[&#39;cmdOPD&#39;]:     # integrator on OPD
        # Integrator
        simu.GDCommand[it] = simu.GDCommand[it-1] + FT[&#39;GainGD&#39;]*currGDerr
        # From OPD to Pistons
        simu.PistonGDCommand[it] = np.dot(FT[&#39;OPD2Piston&#39;], simu.GDCommand[it])
        
    else:                       # integrator on PD
        # From OPD to Piston
        currPistonGD = np.dot(FT[&#39;OPD2Piston&#39;], currGDerr)
        # Integrator
        simu.PistonGDCommand[it] = simu.PistonGDCommand[it-1] + FT[&#39;GainPD&#39;]*currPistonGD
    
    uGD = simu.PistonGDCommand[it]
    
    if config.FT[&#39;roundGD&#39;]:
        for ia in range(NA):
            jumps = round(uGD[ia]/config.PDspectra)
            uGD[ia] = jumps*config.PDspectra
            
    
    &#34;&#34;&#34;
    Phase-Delay command
    &#34;&#34;&#34;
    
    currPDerr = currPD - simu.PDref
 
    # Keep the PD between [-Pi, Pi]
    # Eq. 35
    for ib in range(NIN):
        if currPDerr[ib] &gt; np.pi:
            currPDerr[ib] -= 2*np.pi
        elif currPDerr[ib] &lt; -np.pi:
            currPDerr[ib] += 2*np.pi
    
    # Store residual PD for display only [radians]
    simu.PDResidual[it] = currPDerr
    
    if config.FT[&#39;cmdOPD&#39;]:     # integrator on OPD
        # Integrator
        simu.PDCommand[it] = simu.PDCommand[it-1] + FT[&#39;GainPD&#39;]*currPDerr
        # From OPD to Pistons
        simu.PistonPDCommand[it] = np.dot(FT[&#39;OPD2Piston&#39;], simu.PDCommand[it])
        
    else:                       # integrator on PD
        # From OPD to Piston
        currPistonPD = np.dot(FT[&#39;OPD2Piston&#39;], currPDerr)
        # Integrator
        simu.PistonPDCommand[it] = simu.PistonPDCommand[it-1] + FT[&#39;GainPD&#39;]*currPistonPD
    
    uPD = simu.PistonPDCommand[it]

    &#34;&#34;&#34;
    ODL command
    It is the addition of the GD, PD, SEARCH and modulation functions
    &#34;&#34;&#34;
    
    CommandODL = uPD + uGD
    
    return CommandODL</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.SimpleIntegrator"><code class="name flex">
<span>def <span class="ident">SimpleIntegrator</span></span>(<span>*args, init=False, Ngd=1, Npd=1, Ncp=1, GainPD=0, GainGD=0, Ncross=1, CPref=True, roundGD=True, Threshold=True, usePDref=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates, from the measured coherent flux, the new positions to send to the delay lines.</p>
<h2 id="input">Input</h2>
<ul>
<li>If init: all the below parameters.</li>
<li>If not init: CfEstimated - Measured Coherent Flux
[MW,NB]</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li>currCmd: Piston Command to send to the ODL
[NA]</li>
</ul>
<p>USED OBSERVABLES:
- config.FT
UPDATED OBSERVABLES:
- simu.PDEstimated: [MW,NIN] Estimated PD before subtraction of the reference
- simu.GDEstimated: [MW,NIN] Estimated GD before subtraction of the reference
- simu.CommandODL: Piston Command to send
[NT,NA]</p>
<h2 id="subroutines">Subroutines</h2>
<ul>
<li>ReadCf</li>
<li>SimpleCommandCalc</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>ARRAY [MW,NB]</code></dt>
<dd>Expect current CfEstimated.</dd>
<dt><strong><code>init</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If True, initialize the below parameters.
Needs to be called before starting the simulation.
The default is False.</dd>
<dt><strong><code>Npd</code></strong> :&ensp;<code>INT</code>, optional</dt>
<dd>Frame integration PD. The default is 1.</dd>
<dt><strong><code>Ngd</code></strong> :&ensp;<code>INT</code>, optional</dt>
<dd>Frame integration GD. The default is 1.</dd>
<dt><strong><code>Ncp</code></strong> :&ensp;<code>INT</code>, optional</dt>
<dd>Frame integration CP. The default is 1.</dd>
<dt><strong><code>GainPD</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Gain PD. The default is 0.</dd>
<dt><strong><code>GainGD</code></strong> :&ensp;<code>FLOAT</code>, optional</dt>
<dd>Gain GD. The default is 0.</dd>
<dt><strong><code>Ncross</code></strong> :&ensp;<code>INT</code>, optional</dt>
<dd>Separation between two spectral channels for GD calculation.
The default is 1.</dd>
<dt><strong><code>CPref</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If False, the Closure Phase is not subtracted for reference.
The default is True.</dd>
<dt><strong><code>roundGD</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If True, the GD command is rounded to wavelength integers.
Advised to avoid a superposition of the PD and GD commands.
The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>currCmd</code></strong> :&ensp;<code>ARRAY [NA]</code></dt>
<dd>Piston Command to send to the ODL.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SimpleIntegrator(*args, init=False, Ngd=1, Npd=1, Ncp = 1, GainPD=0, GainGD=0,
                      Ncross = 1, CPref=True,roundGD=True,Threshold=True, usePDref=True):
    &#34;&#34;&#34;
    Calculates, from the measured coherent flux, the new positions to send to the delay lines.
    
    INPUT:
        - If init: all the below parameters.
        - If not init: CfEstimated - Measured Coherent Flux   [MW,NB]
    
    OUTPUT:
        - currCmd: Piston Command to send to the ODL     [NA]
    
    USED OBSERVABLES:
        - config.FT
    UPDATED OBSERVABLES:
        - simu.PDEstimated: [MW,NIN] Estimated PD before subtraction of the reference
        - simu.GDEstimated: [MW,NIN] Estimated GD before subtraction of the reference
        - simu.CommandODL: Piston Command to send       [NT,NA]
        
    SUBROUTINES:
        - ReadCf
        - SimpleCommandCalc
 
        
    Parameters
    ----------
    *args : ARRAY [MW,NB]
        Expect current CfEstimated.
    init : BOOLEAN, optional
        If True, initialize the below parameters.
        Needs to be called before starting the simulation.
        The default is False.
    Npd : INT, optional
        Frame integration PD. The default is 1.
    Ngd : INT, optional
        Frame integration GD. The default is 1.
    Ncp : INT, optional
        Frame integration CP. The default is 1.
    GainPD : FLOAT, optional
        Gain PD. The default is 0.
    GainGD : FLOAT, optional
        Gain GD. The default is 0.
    Ncross : INT, optional
        Separation between two spectral channels for GD calculation. 
        The default is 1.
    CPref : BOOLEAN, optional
        If False, the Closure Phase is not subtracted for reference. 
        The default is True.
    roundGD : BOOLEAN, optional
        If True, the GD command is rounded to wavelength integers. 
        Advised to avoid a superposition of the PD and GD commands.
        The default is True.

    Returns
    -------
    currCmd : ARRAY [NA]
        Piston Command to send to the ODL.

    &#34;&#34;&#34;
    
    if init:
        config.FT[&#39;Name&#39;] = &#39;integrator&#39;
        config.FT[&#39;func&#39;] = SimpleIntegrator
        config.FT[&#39;GainPD&#39;] = GainPD
        config.FT[&#39;Npd&#39;] = Npd
        config.FT[&#39;Ngd&#39;] = Ngd
        config.FT[&#39;Ncp&#39;] = Ncp
        config.FT[&#39;GainGD&#39;] = GainGD
        config.FT[&#39;GainPD&#39;] = GainPD
        config.FT[&#39;Ncross&#39;] = Ncross
        config.FT[&#39;CPref&#39;] = CPref
        config.FT[&#39;roundGD&#39;] = roundGD
        config.FT[&#39;Threshold&#39;] = Threshold
        config.FT[&#39;cmdOPD&#39;] = True
        config.FT[&#39;usePDref&#39;] = usePDref
        
        from .config import NIN,NA
        config.FT[&#39;Piston2OPD&#39;] = np.zeros([NIN,NA])    # Piston to OPD matrix
        config.FT[&#39;OPD2Piston&#39;] = np.zeros([NA,NIN])    # OPD to Piston matrix
        
        from .coh_tools import posk
        
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                config.FT[&#39;Piston2OPD&#39;][ib,ia] = 1
                config.FT[&#39;Piston2OPD&#39;][ib,iap] = -1
                config.FT[&#39;OPD2Piston&#39;][ia,ib] = 1
                config.FT[&#39;OPD2Piston&#39;][iap,ib] = -1

        config.FT[&#39;OPD2Piston&#39;] = config.FT[&#39;OPD2Piston&#39;]/NA
        
        if config.TELref:
            iTELref = config.TELref - 1
            L_ref = config.FT[&#39;OPD2Piston&#39;][iTELref,:]
            config.FT[&#39;OPD2Piston&#39;] = config.FT[&#39;OPD2Piston&#39;] - L_ref
        
        print(f&#34;*** \n Inititilise Integrator: \n GainPD={GainPD} ; GainGD={GainGD} \n \
Ngd={Ngd} ; Type={config.FT[&#39;Name&#39;]} \n\ ***&#34;)
              
        return
    
    from . import simu
    from .simu import it
    
    currCfEstimated = args[0]
    
    currPD, currGD = ReadCf(currCfEstimated)
    
    simu.PDEstimated[it] = currPD
    simu.GDEstimated[it] = currGD*config.FS[&#39;R&#39;]
    
    currCmd = SimpleCommandCalc(currPD,currGD)
    
    return currCmd</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.SpectralAnalysis"><code class="name flex">
<span>def <span class="ident">SpectralAnalysis</span></span>(<span>OPD=(1, 2))</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the three Transfer Function of the servo loop controlling the OPD between
the telescopes OPD[0] and OPD[1]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>OPD</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is (1,2).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SpectralAnalysis(OPD = (1,2)):
    &#34;&#34;&#34;
    Plot the three Transfer Function of the servo loop controlling the OPD between
    the telescopes OPD[0] and OPD[1]

    Parameters
    ----------
    OPD : TYPE, optional
        DESCRIPTION. The default is (1,2).

    Returns
    -------
    None.

    &#34;&#34;&#34;
    from . import simu
    from .config import NA, NT, dt, latency
    
    tel1 = OPD[0]-1
    tel2 = OPD[1]-1
    
    ib = coh_tools.posk(tel1, tel2, NA)
    
    FrequencySampling = np.fft.fftfreq(NT, dt*1e-3)
    PresentFrequencies = (FrequencySampling &gt;= 0) &amp; (FrequencySampling &lt; 200)
    FrequencySampling = FrequencySampling[PresentFrequencies]
    
    Residues = simu.OPDTrue[:,ib]
    Turb = simu.OPDDisturbance[:,ib]
    Command = simu.OPDCommand[:,ib]
    
    FTResidues = np.fft.fft(Residues)[PresentFrequencies]
    FTTurb = np.fft.fft(Turb)[PresentFrequencies]
    FTCommand = np.fft.fft(Command[:-latency])[PresentFrequencies]
    
    FTrej = FTResidues/FTTurb
    FTBO = FTCommand/FTResidues
    FTBF = FTCommand/FTTurb


    plt.figure(&#39;Rejection Transfer Function&#39;)
    plt.plot(FrequencySampling, np.abs(FTrej))
    # plt.plot(FrequencySampling, FrequencySampling*10**(-2), linestyle=&#39;--&#39;)
    plt.xlabel(&#39;Frequencies [Hz]&#39;)
    plt.ylabel(&#39;Normalised&#39;)
    plt.xscale(&#39;log&#39;)
    plt.yscale(&#39;log&#39;)
    plt.show()
    
    plt.figure(&#39;FTBO&#39;)
    plt.plot(FrequencySampling, np.abs(FTBO))
    plt.xlabel(&#39;Frequencies [Hz]&#39;)
    plt.ylabel(&#39;Normalised&#39;)
    plt.xscale(&#39;log&#39;)
    plt.yscale(&#39;log&#39;)
    plt.show()
    
    plt.figure(&#39;FTBF&#39;)
    plt.plot(FrequencySampling, np.abs(FTBF))
    plt.xlabel(&#39;Frequencies [Hz]&#39;)
    plt.ylabel(&#39;Normalised&#39;)
    plt.xscale(&#39;log&#39;)
    plt.yscale(&#39;log&#39;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.addnoiseADU"><code class="name flex">
<span>def <span class="ident">addnoiseADU</span></span>(<span>inputADU)</span>
</code></dt>
<dd>
<div class="desc"><p>Add Noise to ADU image</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inputADU</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>sensitivity</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 5.88.</dd>
<dt><strong><code>dark_noise</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 2.</dd>
<dt><strong><code>floor</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 3.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addnoiseADU(inputADU):
    &#34;&#34;&#34;
    Add Noise to ADU image

    Parameters
    ----------
    inputADU : TYPE
        DESCRIPTION.
    sensitivity : TYPE, optional
        DESCRIPTION. The default is 5.88.
    dark_noise : TYPE, optional
        DESCRIPTION. The default is 2.
    floor : TYPE, optional
        DESCRIPTION. The default is 3.

    Returns
    -------
    image : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    
    from .config import ron, G, enf
    
    (seedph, seedron, seeddist) = (config.seedph,config.seedron,config.seeddist)
    
    # Add SHOT noise
    rs = np.random.RandomState(seedph)
    photonADU = rs.poisson(inputADU/enf, size=inputADU.shape)*enf
    
    # Add DARK noise.
    rs = np.random.RandomState(seedron)
    ronADU = rs.normal(scale=ron/G, size=photonADU.shape) + photonADU
        
    # Quantify ADU
    ADU_out = np.round(ronADU)
    
    
    return ADU_out</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.coh__matcoher2real"><code class="name flex">
<span>def <span class="ident">coh__matcoher2real</span></span>(<span>NA, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a transfer matrix which convert conjugate coherences (complex numbers) into
intensities (real numbers)</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li>NA: number of apertures (arms)</li>
<li>*args: can enter 'inverse' to use inverse mode</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li>MatB:
if direct: coherences to intensities transfert matrix
if indirect: intensities to coherences transfert matrix</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coh__matcoher2real(NA, *args):
    &#39;&#39;&#39;
    Create a transfer matrix which convert conjugate coherences (complex numbers) into 
    intensities (real numbers)
    INPUTS:
        - NA: number of apertures (arms)
        - *args: can enter &#39;inverse&#39; to use inverse mode
    OUTPUT:
        - MatB: 
            if direct: coherences to intensities transfert matrix
            if indirect: intensities to coherences transfert matrix
    &#39;&#39;&#39;
    
    NB = NA**2
    MatB = np.zeros([NB,NB])*1j
    s2 = np.sqrt(0.5)
    MO = 1j*np.zeros([NA,NA,NA,NA])
    
    # first level (ia,iap) targets the real or imag domain.
    # Second level (ia,iap) targets the direct or conjugate coherence.
    for ia in range(NA):
        MO[ia,ia,ia,ia]=1
        for iap in np.arange(ia+1,NA):
            MO[ia,iap,ia,iap]=s2                # in (ia, iap) we store
            MO[ia,iap,iap,ia]=s2                # real parts
            MO[iap,ia,ia,iap]=1j*s2             # in (iap, ia) we store
            MO[iap,ia,iap,ia]=-1j*s2            # imaginary parts
    MatB = np.reshape(MO, (NB,NB))          # the matrix is unwrapped
    
    if &#39;inverse&#39; in args:
        MatB = np.conjugate(np.transpose(MatB))
    
    return MatB</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.coh__phasor2coher"><code class="name flex">
<span>def <span class="ident">coh__phasor2coher</span></span>(<span>phasor, NA, NW)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coh__phasor2coher(phasor, NA, NW):
    
    coher = np.zeros([NW, NA, NA])*1j
    for iw in range(NW):
        phasor_iw = np.reshape(phasor[iw,:],[1,NA])
        coher[iw,:] = np.dot(np.transpose(phasor_iw),np.conjugate(phasor_iw))
    
    coher = np.reshape(coher, [NW, NA*NA])
    return coher</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.coh__pis2coh"><code class="name flex">
<span>def <span class="ident">coh__pis2coh</span></span>(<span>pis, sigma, ampl=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Used in the MakeAtmosphereCoherence function.
From the two arrays (of dimension NA = number of pupils) containing the pistons
and the amplitudes and from the array containing the signal's spectra, the function
build a NAxNA array with all the mutual coherences. This enables to simulate
any kind of coherence pattern.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li>pis: vector containing the piston in each aperture</li>
<li>sigma: the working wavenumber (later, it will be a vector)</li>
<li>ampl: a vector containing the amplitude of the electric field in each aperture
by default, the unitary vector.</li>
</ul>
<h2 id="output">Output</h2>
<ul>
<li>coher: [NW,NB] matrix containing the mutual coherences</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coh__pis2coh(pis, sigma, ampl=[]):
    &#34;&#34;&#34;
    Used in the MakeAtmosphereCoherence function.
    From the two arrays (of dimension NA = number of pupils) containing the pistons 
    and the amplitudes and from the array containing the signal&#39;s spectra, the function 
    build a NAxNA array with all the mutual coherences. This enables to simulate 
    any kind of coherence pattern.
    INPUTS:
        - pis: vector containing the piston in each aperture
        - sigma: the working wavenumber (later, it will be a vector)
        - ampl: a vector containing the amplitude of the electric field in each aperture
                by default, the unitary vector.
    OUTPUT:
        - coher: [NW,NB] matrix containing the mutual coherences
    &#34;&#34;&#34;
    
    
    NA = len(pis)
    NW = len(sigma)
    pis = np.reshape(pis, [NA,1])
    
    if len(ampl) == 0:
        ampl = np.ones([NW,NA])
    
    phasor = ampl * np.exp(2j*np.pi*np.dot(np.reshape(sigma, [NW,1]),\
                                           np.transpose(pis)))

    coher = coh__phasor2coher(phasor, NA, NW)
    
    return coher</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>*args, wl=1.6, Pistondetails=False, OPDdetails=False, OneTelescope=True)</span>
</code></dt>
<dd>
<div class="desc"><p>NAME:
COH__PLOT - Plots different interesting results from the simulation</p>
<p>CALLING SEQUENCE:
coh__plot(coh, pis_display=True, coher_display=True)</p>
<h2 id="purpose">Purpose</h2>
<p>This procedure plots different results from the simulation, like
pistons commands and amplitudes of wavefronts function of time.
It is called at the end of a coh_turn routine to show these results
which have been stored in global variables during the loop.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li>args: write, as strings, the different observables you want to plot
among: 'disturbance', phot', 'piston', 'opd','vis','detector'</li>
<li>wl: wavelength</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(*args, wl=1.6,Pistondetails=False,OPDdetails=False,OneTelescope=True):
    
    &#39;&#39;&#39;
    NAME:
    COH__PLOT - Plots different interesting results from the simulation
    
    CALLING SEQUENCE:
        coh__plot(coh, pis_display=True, coher_display=True)
        
    PURPOSE:
        This procedure plots different results from the simulation, like \
        pistons commands and amplitudes of wavefronts function of time. \
        It is called at the end of a coh_turn routine to show these results\
        which have been stored in global variables during the loop.
        
    INPUTS:
        - args: write, as strings, the different observables you want to plot
        among: &#39;disturbance&#39;, phot&#39;, &#39;piston&#39;, &#39;opd&#39;,&#39;vis&#39;,&#39;detector&#39;
        - wl: wavelength 
        
    &#39;&#39;&#39;
          
    import matplotlib.patches as mpatches
    import matplotlib.lines as mlines
    
    from . import simu
    # import config
    
    from .simu import timestamps
    
    ind = np.where(np.abs(config.spectraM-wl) &lt; 0.1)[0]
    ind = ind[0]
    wl = config.spectraM[ind]
    
    from .config import NA,NT
       
    ich = config.FS[&#39;ich&#39;]
    
    dt=config.dt

    increment=0
    if np.min(ich) == 1:
        increment = 1


    print(&#39;Displaying observables...&#39;)
    print(f&#39;First fig is Figure {config.newfig}&#39;)
    
    displayall = False
    if len(args)==0:
        print(args)
        displayall = True
        
    from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,
                       AutoMinorLocator, MaxNLocator)
    
    colors = [&#39;red&#39;,&#39;blue&#39;,&#39;dodgerblue&#39;,&#39;gold&#39;,&#39;darkorange&#39;,&#39;darkgreen&#39;,&#39;darkviolet&#39;,&#39;grey&#39;,&#39;deeppink&#39;,&#39;black&#39;]
    
    if displayall or (&#39;disturbances&#39; in args):
        pis_max = 1.1*np.max(np.abs(simu.PistonDisturbance))
        pis_min = -pis_max
        ylim = [pis_min,pis_max]
        
        beam_patches = []
        for ia in range(NA):
            beam_patches.append(mpatches.Patch(color=colors[ia+1],label=f&#34;Telescope {ia+increment}&#34;))
        
        
        fig = plt.figure(&#34;Disturbances&#34;)
        ax1,ax2,ax3 = fig.subplots(nrows=3,ncols=1)
        for ia in range(NA):
            # plt.subplot(NA,1,ia+1), plt.title(&#39;Beam {}&#39;.format(ia+increment))
            ax1.plot(timestamps, simu.PistonDisturbance[:,ia],color=colors[ia+1])
        
        ax1.set_xlabel(&#39;Time (ms)&#39;)
        ax1.set_ylabel(&#39;Piston [µm]&#39;)
        ax1.set_ylim(ylim)
        ax1.grid()
        ax1.set_title(&#39;Disturbance scheme at {:.2f}µm&#39;.format(wl))
        ax1.legend(handles=beam_patches)

        if hasattr(simu, &#39;FreqSampling&#39;):
            if simu.FreqSampling.size == simu.DisturbancePSD.size:
                ax2.plot(simu.FreqSampling, simu.DisturbancePSD)
                ax2.set_title(&#39;Power spectral distribution of the last pupil \
            (same shape for all)&#39;)
                ax2.set_xlabel(&#39;Frequency [Hz]&#39;)             
                ax2.set_xscale(&#39;log&#39;)
                ax2.set_yscale(&#39;log&#39;)
                
                ax3.plot(simu.FreqSampling, simu.DisturbanceFilter)
                ax3.set_title(&#39;Filter&#39;)
                ax3.set_xlabel(&#39;Frequency [Hz]&#39;)             
                ax3.set_xscale(&#39;log&#39;)
                ax3.set_yscale(&#39;log&#39;)    
                
        plt.show()
        config.newfig+=1    
        
        
    if displayall or (&#39;phot&#39; in args):
        linestyles=[]
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;solid&#39;,label=&#39;Estimated&#39;))    
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;dashed&#39;,label=&#39;Disturbance&#39;))
    
    
        plt.figure(&#34;Photometries&#34;)
        plt.suptitle(&#39;Photometries at {:.2f}µm&#39;.format(wl))
        
        for ia in range(NA):
            plt.plot(timestamps, simu.PhotometryDisturbance[:,ind,ia],
                     color=colors[ia],linestyle=&#39;dashed&#39;)#),label=&#39;Photometry disturbances&#39;)
            plt.plot(timestamps, simu.PhotometryEstimated[:,ind,ia],
                     color=colors[ia],linestyle=&#39;solid&#39;)#,label=&#39;Estimated photometries&#39;)
            
        plt.legend(handles=beam_patches+linestyles)
        plt.grid()
        plt.xlabel(&#39;Time (ms)&#39;)
        plt.show()    
        config.newfig+=1    
        
    
    if displayall or (&#39;piston&#39; in args):
        &#34;&#34;&#34;
        PISTONS
        &#34;&#34;&#34;
        linestyles=[]
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;solid&#39;,label=&#39;Estimated&#39;))    
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;dashed&#39;,label=&#39;Disturbance&#39;))
        linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                        linestyle=&#39;dotted&#39;,label=&#39;Command&#39;))
        
        ax1ymax = np.max([np.max(np.abs(simu.PistonTrue)),wl/2])
        ax1ylim = [-ax1ymax,ax1ymax]
        fig = plt.figure(&#34;Pistons&#34;)
        plt.suptitle(&#39;Piston time evolution at {:.2f}µm&#39;.format(wl))
        ax1 = fig.subplots()
        ax2 = ax1.twinx()
        
        for ia in range(NA):
            # if not config.TELref:
                  # iTelref = config.TELref - 1
            #     PistonToPlot = simu.PistonTrue[:,ia]
            # else:
            #     PistonToPlot = simu.PistonTrue[:,ia] - simu.PistonTrue[:,iTELref]
            
            ax1.plot(timestamps, simu.PistonTrue[:,ia],
                     color=colors[ia+1],linestyle=&#39;solid&#39;)
            ax2.plot(timestamps, simu.PistonDisturbance[:,ia],
                     color=colors[ia+1],linestyle=&#39;dashed&#39;)
            ax2.plot(timestamps, simu.CommandODL[:-config.latency,ia],
                     color=colors[ia+1],linestyle=&#39;dotted&#39;)
            plt.grid()
        
        ax1.set_ylabel(&#39;True Pistons [µm]&#39;)
        ax1.set_ylim(ax1ylim)
        ax2.set_ylabel(&#39;Disturbance and Command Pistons [µm]&#39;)
        ax2.set_ylim(ylim)
        plt.xlabel(&#39;Time (ms)&#39;)
        plt.legend(handles=beam_patches+linestyles)
        plt.show()
        config.newfig+=1
    
        if Pistondetails:
            
            linestyles=[]
            linestyles.append(mlines.Line2D([], [], color=&#39;blue&#39;,
                                            linestyle=&#39;solid&#39;,label=&#39;Estimated&#39;))    
            linestyles.append(mlines.Line2D([], [], color=&#39;red&#39;,
                                            linestyle=&#39;solid&#39;,label=&#39;Disturbance&#39;))
            linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                            linestyle=&#39;dotted&#39;,label=&#39;Command&#39;))
            linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                            linestyle=(0,(3,5,1,5)),label=&#39;PD Command&#39;))
            linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                            linestyle=(0,(3,5,1,5,1,5)),label=&#39;GD Command&#39;))
            # linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
            #                                 linestyle=&#39;dashdot&#39;,label=&#39;Search Command&#39;))
            # linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
            #                                 linestyle=&#39;dashdot&#39;,label=&#39;Modulation Command&#39;))
        
        
            fig = plt.figure(&#34;Piston details&#34;)
            fig.suptitle(&#39;Piston time evolution at {:.2f}µm&#39;.format(wl))
            axes = fig.subplots(nrows=NA,ncols=1, sharex=True)
            ax2ymax = np.max(np.abs(simu.PistonTrue))
            ax2ylim = [-ax2ymax,ax2ymax]
            for ia in range(NA):
                ax = axes[ia]
                ax.plot(timestamps, simu.PistonDisturbance[:,ia],
                         color=&#39;red&#39;,linestyle=&#39;solid&#39;)
                ax.plot(timestamps, simu.CommandODL[:-config.latency,ia],
                         color=&#39;green&#39;,linestyle=&#39;dashed&#39;)
                ax.plot(timestamps, simu.PistonPDCommand[:-config.latency,ia],
                         color=&#39;green&#39;,linestyle=&#39;dotted&#39;)
                ax.plot(timestamps, simu.PistonGDCommand[:-config.latency,ia],
                         color=&#39;green&#39;,linestyle=(0,(3,5,1,5,1,5)))
                ax2 = ax.twinx()
                ax2.plot(timestamps, simu.PistonTrue[:,ia],
                         color=&#39;blue&#39;,linestyle=&#39;solid&#39;)
                ax.set_ylim(ylim)
                ax2.set_ylim(ax2ylim)
                ax.set_ylabel(f&#39;All Pistons except residual {ia+increment} [µm]&#39;)
                ax2.set_ylabel(f&#39;Residual Piston {ia+increment} [µm]&#39;)
                ax.grid()
            plt.xlabel(&#39;Time (ms)&#39;)
            plt.legend(handles=linestyles)
            plt.show()
            config.newfig+=1    


    if displayall or (&#39;opd&#39; in args):
        &#34;&#34;&#34;
        OPD 
        &#34;&#34;&#34;
        
        OPD_max = 1.1*np.max(np.abs([simu.OPDDisturbance,
                              simu.OPDTrue,
                              simu.OPDCommand[:-config.latency,:]]))
        OPD_min = -OPD_max
        ylim = [OPD_min,OPD_max]
    
        linestyles=[]
        linestyles.append(mlines.Line2D([], [], color=&#39;blue&#39;,
                                        linestyle=&#39;solid&#39;,label=&#39;Residual&#39;))    
        linestyles.append(mlines.Line2D([], [], color=&#39;red&#39;,
                                        linestyle=&#39;solid&#39;,label=&#39;Disturbance&#39;))
        linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                        linestyle=&#39;dotted&#39;,label=&#39;Command&#39;))
    
        DIT = min(50, config.NT - config.starttracking -1)
        ShowPerformance(float(timestamps[int((config.starttracking+config.NT)*2/3)]), wl, DIT, display=False)
        NumberOfBaselinesToShow = 3
        for ia in range(NumberOfBaselinesToShow):
            fig = plt.figure(f&#34;OPD {ia+increment}&#34;)
    #         fig.suptitle(f&#34;OPD evolution at {wl:.2f}µm for baselines \n\
    # including telescope {ia+increment}&#34;)
            axes = fig.subplots(nrows=NumberOfBaselinesToShow,ncols=2,sharex=True, gridspec_kw={&#39;width_ratios&#39;: [4, 1]})
            iap,iax=0,0
            for ax,axText in axes:
                ax2 = ax.twinx()
                ax2ymax = 1.1*np.max(np.abs(simu.OPDTrue[config.starttracking+50:]))
                ax2ylim = [-ax2ymax,ax2ymax]
                # ax2ylim = [-wl/2,wl/2]
                if iap == ia:
                    iap+=1
                if ia &lt; iap:
                    ib = coh_tools.posk(ia,iap,NA)
                    ax.plot(timestamps, simu.OPDDisturbance[:,ib],color=&#39;red&#39;)
                    ax.plot(timestamps, simu.OPDCommand[:-config.latency,ib],
                            color=&#39;green&#39;,linestyle=&#39;dotted&#39;)
                    ax2.plot(timestamps, simu.OPDTrue[:,ib],color=&#39;blue&#39;)
                else:
                    ib = coh_tools.posk(iap,ia,NA)
                    ax.plot(timestamps, -simu.OPDDisturbance[:,ib],color=&#39;red&#39;)
                    ax.plot(timestamps, -simu.OPDCommand[:-config.latency,ib],
                            color=&#39;green&#39;,linestyle=&#39;dotted&#39;)                
                    ax2.plot(timestamps, -simu.OPDTrue[:,ib],color=&#39;blue&#39;)
                
                axText.text(0.5,0.5,f&#34;{np.sqrt(simu.VarOPD[ib])*1e3:.0f}nm RMS&#34;)
                axText.axis(&#34;off&#34;)
                ax.set_ylim(ylim)
                ax2.set_ylim(ax2ylim)
                ax.set_ylabel(f&#39;OPD ({ia+1},{iap+1})\n [µm]&#39;)
                ax2.set_ylabel(f&#39;Residual \n [µm]&#39;)
                fig.tight_layout()
                # wlr = round(wl,2)
                # ax2.set_yticks([-wl,0,wl])
                # ax2.set_yticklabels([-wlr,0,wlr])
                # ax2.tick_params(axis=&#39;y&#39;,which=&#39;major&#39;, length=7)
                # ax2.tick_params(axis=&#39;y&#39;,which=&#39;minor&#39;, length=4)
                # ax2.yaxis.set_minor_locator(AutoMinorLocator(2))
                # ax2.grid(b=True,which=&#39;major&#39;)
                # ax2.grid(b=True, which=&#39;minor&#39;)
                
                
                iap += 1
                iax+=1
            # plt.tight_layout()
            ax.set_xlabel(&#39;Time (ms)&#39;)
            plt.show()
            plt.legend(handles=linestyles)
            config.newfig+=1
            
            if OneTelescope:
                break
        
    
        if OPDdetails:
            OPD_max = 1.1*np.max(np.abs([simu.OPDDisturbance,
                                  simu.GDCommand[:-config.latency,:]]))
            OPD_min = -OPD_max
            ylim = [OPD_min,OPD_max]
        
            linestyles=[]
            linestyles.append(mlines.Line2D([], [],label=&#39;Disturbance&#39;,
                                            color=&#39;red&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [], color=&#39;green&#39;,
                                        linestyle=&#39;dotted&#39;,label=&#39;GD Command&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;GD Residuals&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;:&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;PD Residuals&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;-&#39;))

            for ia in range(NA):
                fig = plt.figure(f&#34;OPD details {ia+increment}&#34;)
                fig.suptitle(f&#34;OPD evolution at {wl:.2f}µm for baselines \n\
        including telescope {ia+increment}&#34;)
                axes = fig.subplots(nrows=NA-1,ncols=3,sharex=True,gridspec_kw={&#39;width_ratios&#39;: [8, 1,1]})
                iap,iax=0,0
                for ax,axText,axLegend in axes:
                    ax2 = ax.twinx()
                    ax2ymax = 1.1*np.max(np.abs(simu.GDEstimated*wl/(2*np.pi)))
                    ax2ylim = [-ax2ymax,ax2ymax]
                    if iap == ia:
                        iap+=1
                    if ia &lt; iap:
                        ib = coh_tools.posk(ia,iap,NA)
                        ax.plot(timestamps, simu.OPDDisturbance[:,ib],
                                color=&#39;red&#39;)
                        ax2.plot(timestamps, simu.GDCommand[:-config.latency,ib],
                                color=&#39;green&#39;,linestyle=&#39;dotted&#39;)
                        ax2.plot(timestamps, simu.GDResidual[:,ib]*wl/(2*np.pi),
                                 color=&#39;black&#39;,linestyle=&#39;:&#39;)
                        ax2.plot(timestamps, simu.PDResidual[:,ib]*wl/(2*np.pi),
                                 color=&#39;black&#39;,linestyle=&#39;-&#39;)
                    else:
                        ib = coh_tools.posk(iap,ia,NA)
                        ax.plot(timestamps, -simu.OPDDisturbance[:,ib],color=&#39;red&#39;)
                        ax.plot(timestamps, -simu.GDCommand[:-config.latency,ib],
                                color=&#39;green&#39;,linestyle=&#39;dotted&#39;)
                        ax2.plot(timestamps, -simu.GDResidual[:,ib]*wl/(2*np.pi), color=&#39;black&#39;,
                                 linestyle=&#39;:&#39;)
                        ax2.plot(timestamps, -simu.PDResidual[:,ib]*wl/(2*np.pi), color=&#39;black&#39;,
                                 linestyle=&#39;-&#39;)
                    ax.set_ylim(ylim)
                    ax.set_ylabel(f&#39;[{ia+1},{iap+1}] [µm]&#39;)
                    
                    ax2.set_ylim(ax2ylim)
                    ax2.set_ylabel(f&#39;Residuals&#39;)
                    ax2.set_yticks([-wl,0,wl])

                    axText.text(0,0.70,f&#34;PD:{np.std(simu.PDEstimated[(config.starttracking+config.NT)*2//3:,ib]*wl/(2*np.pi)*1e3):.0f}nm RMS&#34;)
                    axText.text(0,0.30,f&#34;GD:{np.std(simu.GDEstimated[(config.starttracking+config.NT)*2//3:,ib]*wl/(2*np.pi)*1e3):.0f}nm RMS&#34;)
                    axText.axis(&#34;off&#34;)
                    axLegend.axis(&#34;off&#34;)
                    # wlr = round(wl,2)
                    # ax2.set_yticklabels([-wlr,0,wlr])
                    # ax2.tick_params(axis=&#39;y&#39;,which=&#39;major&#39;, length=7)
                    # ax2.tick_params(axis=&#39;y&#39;,which=&#39;minor&#39;, length=4)
                    # ax2.yaxis.set_minor_locator(AutoMinorLocator(2))
                    # ax2.grid(b=True,which=&#39;major&#39;)
                    # ax2.grid(b=True, which=&#39;minor&#39;)
                    
                    iap += 1
                    iax+=1
                    # ax2.minorticks_on()
                fig.tight_layout()
                plt.xlabel(&#39;Time (ms)&#39;)
                # plt.show()
                axLegend.legend(handles=linestyles)
                config.newfig+=1
        
                if OneTelescope:
                    break
            
        if &#39;ODPcmd&#39; in args:
            OPD_max = 1.1*np.max(np.abs([simu.OPDDisturbance,
                                  simu.GDCommand[:-config.latency,:]]))
            OPD_min = -OPD_max
            ylim = [OPD_min,OPD_max]
        
            linestyles=[]
            linestyles.append(mlines.Line2D([], [],label=&#39;Disturbance&#39;,
                                            color=&#39;red&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;Command OPD&#39;,
                                            color=&#39;blue&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;GD Estimated&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;--&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;PD Estimated&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;:&#39;))

            for ia in range(NA):
                fig = plt.figure(f&#34;OPD details {ia+increment}&#34;)
                fig.suptitle(f&#34;OPD evolution at {wl:.2f}µm for baselines \n\
        including telescope {ia+increment}&#34;)
                axes = fig.subplots(nrows=NA-1,ncols=3,sharex=True,gridspec_kw={&#39;width_ratios&#39;: [8, 1,1]})
                iap,iax=0,0
                for ax,axText,axLegend in axes:
                    ax2 = ax.twinx()
                    ax2ymax = 1.1*np.max(np.abs(simu.GDEstimated*wl/(2*np.pi)))
                    ax2ylim = [-ax2ymax,ax2ymax]
                    if iap == ia:
                        iap+=1
                    if ia &lt; iap:
                        ib = coh_tools.posk(ia,iap,NA)
                        ax.plot(timestamps, simu.OPDDisturbance[:,ib],
                                color=&#39;red&#39;)
                        # ax2.plot(timestamps, simu.GDCommand[:-config.latency,ib],
                        #         color=&#39;blue&#39;)
                        ax2.plot(timestamps, simu.OPDCommand[:-config.latency,ib],
                                color=&#39;blue&#39;)
                        ax2.plot(timestamps, simu.GDResidual[:,ib]*wl/(2*np.pi),
                                 color=&#39;black&#39;,linestyle=&#39;-.&#39;)
                        ax2.plot(timestamps, simu.PDResidual[:,ib]*wl/(2*np.pi),
                                 color=&#39;black&#39;,linestyle=&#39;-&#39;)
                    else:
                        ib = coh_tools.posk(iap,ia,NA)
                        ax.plot(timestamps, -simu.OPDDisturbance[:,ib],color=&#39;red&#39;)
                        ax.plot(timestamps, -simu.GDCommand[:-config.latency,ib],
                                color=&#39;green&#39;,linestyle=(0,(3,5,1,5,1,5)))
                        ax2.plot(timestamps, -simu.GDResidual[:,ib]*wl/(2*np.pi), color=&#39;black&#39;,
                                 linestyle=&#39;--&#39;)
                        ax2.plot(timestamps, -simu.PDResidual[:,ib]*wl/(2*np.pi), color=&#39;black&#39;,
                                 linestyle=&#39;:&#39;)
                    ax.set_ylim(ylim)
                    ax.set_ylabel(f&#39;[{ia+1},{iap+1}] [µm]&#39;)
                    
                    ax2.set_ylim(ax2ylim)
                    ax2.set_ylabel(f&#39;Residuals&#39;)
                    ax2.set_yticks([-wl,0,wl])

                    axText.text(0,0.70,f&#34;PD:{np.std(simu.PDEstimated[config.starttracking+10:,ib]*wl/(2*np.pi)*1e3):.0f}nm RMS&#34;)
                    axText.text(0,0.30,f&#34;GD:{np.std(simu.GDEstimated[config.starttracking+10:,ib]*wl/(2*np.pi)*1e3):.0f}nm RMS&#34;)
                    # axText.axis(&#34;off&#34;)
                    # axLegend.axis(&#34;off&#34;)
                    wlr = round(wl,2)
                    ax2.set_yticklabels([-wlr,0,wlr])
                    ax2.tick_params(axis=&#39;y&#39;,which=&#39;major&#39;, length=7)
                    ax2.tick_params(axis=&#39;y&#39;,which=&#39;minor&#39;, length=4)
                    ax2.yaxis.set_minor_locator(AutoMinorLocator(2))
                    ax2.grid(b=True,which=&#39;major&#39;)
                    ax2.grid(b=True, which=&#39;minor&#39;)
                    
                    iap += 1
                    iax+=1
                    # ax2.minorticks_on()
                plt.xlabel(&#39;Time (ms)&#39;)
                plt.show()
                axLegend.legend(handles=linestyles)
                config.newfig+=1
        
                if OneTelescope:
                    break


        if &#39;OPDgathered&#39; in args:

            OPD_max = 1.1*np.max(np.abs([simu.OPDDisturbance,
                                  simu.GDCommand[:-config.latency,:]]))
            OPD_min = -OPD_max
            ylim = [OPD_min,OPD_max]
        
            linestyles=[]
            linestyles.append(mlines.Line2D([], [],label=&#39;Disturbance&#39;,
                                            color=&#39;red&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;Command OPD&#39;,
                                            color=&#39;blue&#39;,linestyle=&#39;solid&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;GD Estimated&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;--&#39;))
            linestyles.append(mlines.Line2D([], [],label=&#39;PD Estimated&#39;,
                                            color=&#39;black&#39;,linestyle=&#39;:&#39;))

            fig = plt.figure(f&#34;OPD on one window&#34;)
            ax,axText,axLegend = fig.subplots(nrows=1,ncols=3,sharex=True,gridspec_kw={&#39;width_ratios&#39;: [8, 1,1]})

            for ib in range(config.NIN):
                
                ax.plot(timestamps, simu.OPDTrue[:,ib], linestyle=&#39;-&#39;, label=f&#39;OPD {config.ich[ib]}&#39;)


                wlr = round(wl,2)
                ax2.set_yticklabels([-wlr,0,wlr])
                ax2.tick_params(axis=&#39;y&#39;,which=&#39;major&#39;, length=7)
                ax2.tick_params(axis=&#39;y&#39;,which=&#39;minor&#39;, length=4)
                ax2.yaxis.set_minor_locator(AutoMinorLocator(2))
                ax2.grid(b=True,which=&#39;major&#39;)
                ax2.grid(b=True, which=&#39;minor&#39;)
                    
                    # ax2.minorticks_on()
            plt.xlabel(&#39;Time (ms)&#39;)
            plt.show()
            axLegend.legend()
            config.newfig+=1
        
            # if OneTelescope:
            #     break



    if displayall or (&#39;cp&#39; in args):
        &#34;&#34;&#34;
        CLOSURE PHASES
        &#34;&#34;&#34;
        
        
        linestyles=[]
        linestyles.append(mlines.Line2D([], [],linestyle=&#39;solid&#39;,
                                        label=&#39;Estimated&#39;))    
        linestyles.append(mlines.Line2D([], [],linestyle=&#39;dashed&#39;,
                                        label=&#39;Object&#39;))
        
        
        ymax = np.pi
        ylim = [-ymax, ymax]
        fig = plt.figure(&#39;Closure Phases&#39;)
        fig.suptitle(&#39;Closure Phases&#39;)
        ax1,ax2 = fig.subplots(nrows=2, ncols=1)
        
        # Plot on ax1 the (NA-1)(NA-2)/2 independant Closure Phases
        for ia in range(1,NA):
            for iap in range(ia+1,NA):
                ic = coh_tools.poskfai(0,ia,iap,NA)
                # if ia == 0
                ax1.plot(timestamps, simu.ClosurePhasePD[:,ic],
                         color=colors[ic])
                ax1.hlines(simu.ClosurePhaseObject[ind,ic], 0, timestamps[-1], 
                           color=colors[ic], linestyle=&#39;--&#39;)
                
        # Plot on ax2 the (NA-1)(NA-2)/2 (independant?) other Closure Phases
        for ia in range(1,NA):
            for iap in range(ia+1,NA):
                for iapp in range(iap+1,NA):
                    ic = coh_tools.poskfai(ia,iap,iapp,NA)
                    colorindex = int(ic - config.NC//2)
                    ax2.plot(timestamps, simu.ClosurePhasePD[:,ic],
                             color=colors[colorindex])
                    ax2.hlines(simu.ClosurePhaseObject[ind,ic], 0, timestamps[-1],
                               color=colors[colorindex], linestyle=&#39;--&#39;)
        
        plt.xlabel(&#39;Time [ms]&#39;)
        plt.ylabel(&#39;Closure Phase [rad]&#39;)
        ax1.set_ylim(ylim)
        ax2.set_ylim(ylim)
        ax1.grid()
        ax2.grid()
        plt.show()
        plt.legend(handles=linestyles)
        config.newfig+=1
        

    if displayall or (&#39;vis&#39; in args):
        &#34;&#34;&#34;
        VISIBILITIES
        &#34;&#34;&#34;
    
        # Squared Visibilities
        for ia in range(NA):
            fig = plt.figure(f&#34;Squared Vis {ia+increment}&#34;)
            fig.suptitle(f&#34;Squared visibility |\u03B3|² at {wl:.2f}µm for baselines \n\
    including telescope {ia+increment}&#34;)
            axes = fig.subplots(nrows=NA-1,ncols=1,sharex=True)
            iap=0
            for ax in axes:
                if iap == ia:
                    iap+=1
                
                ib = coh_tools.posk(ia,iap,NA)
                ax.plot(timestamps, simu.SquaredCoherenceDegree[:,ind,ib], color=&#39;k&#39;)
                ax.set_ylim([0,1])
                ax.set_ylabel(f&#39;({ia},{iap})&#39;)
    
                ax.grid()
                iap += 1
            plt.xlabel(&#39;Time (ms)&#39;)
            plt.show()
            config.newfig+=1
            
            if OneTelescope:
                break
    
    
        # Phase of the visibilities
        VisibilityPhase = np.angle(simu.ComplexVisibility[:,ind,:])
        ymax = np.pi #2*np.max(np.abs(VisibilityPhase))
        ylim = [-ymax,ymax]
        for ia in range(NA):
            fig = plt.figure(f&#34;Phase Vis {ia+increment}&#34;)
            fig.suptitle(f&#34;Visibility phase \u03C6 at {wl:.2f}µm for baselines \n\
    including telescope {ia+increment}&#34;)
            axes = fig.subplots(nrows=NA-1,ncols=1,sharex=True)
            iap=0
            for iax in range(len(axes)):
                ax = axes[iax]
                if iap == ia:
                    iap+=1
                
                ib = coh_tools.posk(ia,iap,NA)
                ax.plot(timestamps, VisibilityPhase[:,ib], color=&#39;k&#39;)
                ax.set_ylim(ylim)
                ax.set_ylabel(f&#39;({ia},{iap})&#39;)
                ax.grid()
                iap += 1
                fig.subplots_adjust(right=0.8)
                RMS_ax = fig.add_axes([0.82, 1-1/NA*(iax+1), 0.1, 0.9/NA])
                RMS_ax.text(0,0,f&#34;{np.std(VisibilityPhase[config.starttracking+10:,ib])/(2*np.pi):.2f}\u03BB RMS&#34;)
                RMS_ax.axis(&#34;off&#34;)
            plt.xlabel(&#39;Time (ms)&#39;)
            plt.show()
            config.newfig+=1
    
            if OneTelescope:
                break

    if displayall or (&#39;detector&#39; in args):
        &#34;&#34;&#34;
        DETECTOR VIEW
        &#34;&#34;&#34;
        fig = plt.figure(&#34;Detector intensities&#34;)
        axes = fig.subplots()
        plt.suptitle(&#39;Intensities recorded by the detector at {:.2f}µm&#39;.\
                     format(wl))
        
        if config.fs == &#39;default&#39;:
            NMod = 1
        if &#39;spica&#39; in config.fs or &#39;abcd&#39; in config.fs:
            NMod = config.FS[&#39;NM&#39;]
            
        NIN = config.NIN
        NP = config.FS[&#39;NP&#39;]
        NMod = config.FS[&#39;NMod&#39;]
        
        for ip in range(NP):
            
            ax = plt.subplot(NIN,NMod,ip+1)
            if ip &lt; NMod:
                ax.set_title(config.FS[&#39;Modulations&#39;][ip])
            im = plt.imshow(np.transpose(np.dot(np.reshape(simu.MacroImages[:,ind,ip],[NT,1]), \
                                                np.ones([1,100]))), vmin=np.min(simu.MacroImages), vmax=np.max(simu.MacroImages))    
                
            plt.tick_params(axis=&#39;y&#39;,left=&#39;off&#39;)
            if ip//NMod == ip/NMod:
                plt.ylabel(str(int(ich[ip//NMod,0]))+str(int(ich[ip//NMod,1])))
                
            if ip&gt;=NP-NMod:
                plt.xticks([0,NT],[0,NT*dt])
                plt.xlabel(&#39;Time (ms)&#39;) 
            else:
                plt.xticks([],[])
            plt.yticks([],[])
                
    
        fig.subplots_adjust(right=0.8)
        cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
        fig.colorbar(im, cax=cbar_ax)
        plt.show()
        config.newfig+=1</code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>Interferometer, ObsFile, DisturbanceFile, NT=512, OT=1, MW=5, ND=1, spectra=[], spectraM=[], PDspectra=0, spectrum=[], mode='search', fs='default', TELref=0, FSfitsfile='', R=0.5, dt=1, sigsky=[], imsky=[], ft='integrator', state=0, noise=False, ron=0, qe=0.5, phnoise=0, G=1, enf=1.5, M=1, seedph=100, seedron=100, seeddist=100, starttracking=100, latencytime=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>NAME: initialize - Initializes a structure to simulate an interferometer by
COH_LIB</p>
<pre><code>PURPOSE:
    This procedure creates the coh structure and intializes it with the         FS-given information.
    Other user-information are filled with coh_user.

OUTPUT:
    coh: dictionnary which defines the interferometric setup.

INPUTS:
    MANDATORY:
    NA : (integer) Number of input beams
    NW  : (integer) Number of waves in the simulation
    MW  : (integer) Number of macro-waves (detector spectral channels)
    spectra   : (float array) Set of reference wavelengths

OPTIONAL:
    fs : (string) the name of the Fringe Sensor procedure coh_fs_name
    FSfitsfile : (string) the name of the experimental V2PM fitsfile
    mode : the algorithm (pd, gd,...)
    lmbda  : (float array) Value of wavelengths
    spectrum   : ([NB,NW] float array) XX TODO How to weight waveNUMBERS 
    on the corresponding baseline
    filename : (string) Filename for automatic saves
    step_resp: (FLTARR(xT)) ODL response to a Heaviside step
    /openloop : to simulate an openloop with coh_ft_openloop
    [DEFAULT]=closed loop with coh_ft_integrator
    random : random start for the pseudo-random sequence
    version : (optional input) prints version number before execution. 
    help    : (optional input) prints the documentation and exits.
    F : Amplification factor of an EM-CCD camera, by default = 1
</code></pre>
<h2 id="example">Example</h2>
<p>See unitary test at the end of file </p>
<h2 id="restrictions">Restrictions</h2>
<p>This code is copyright (c) ONERA, 2009. </p>
<h2 id="source">Source</h2>
<p>This code is born from Choquet and Cassaing's IDL code developped at ONERA
(2009)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(Interferometer, ObsFile, DisturbanceFile, NT=512, OT=1, MW = 5, ND=1, 
             spectra = [], spectraM=[],PDspectra=0,
             spectrum = [], mode = &#39;search&#39;,
             fs=&#39;default&#39;, TELref=0, FSfitsfile=&#39;&#39;, R = 0.5, dt=1,sigsky=[],imsky=[],
             ft = &#39;integrator&#39;, state = 0,
             noise=False,ron=0, qe=0.5, phnoise = 0, G=1, enf=1.5, M=1,
             seedph=100, seedron=100, seeddist=100,
             starttracking=100, latencytime=0,
             **kwargs):
    
    &#34;&#34;&#34;
    NAME: initialize - Initializes a structure to simulate an interferometer by \
    COH_LIB
    
    PURPOSE:
        This procedure creates the coh structure and intializes it with the \
        FS-given information.
        Other user-information are filled with coh_user.
        
    OUTPUT:
        coh: dictionnary which defines the interferometric setup.
        
    INPUTS:
        MANDATORY:
        NA : (integer) Number of input beams
        NW  : (integer) Number of waves in the simulation
        MW  : (integer) Number of macro-waves (detector spectral channels)
        spectra   : (float array) Set of reference wavelengths
        
    OPTIONAL:
        fs : (string) the name of the Fringe Sensor procedure coh_fs_name
        FSfitsfile : (string) the name of the experimental V2PM fitsfile
        mode : the algorithm (pd, gd,...)
        lmbda  : (float array) Value of wavelengths
        spectrum   : ([NB,NW] float array) XX TODO How to weight waveNUMBERS 
        on the corresponding baseline
        filename : (string) Filename for automatic saves
        step_resp: (FLTARR(xT)) ODL response to a Heaviside step
        /openloop : to simulate an openloop with coh_ft_openloop
        [DEFAULT]=closed loop with coh_ft_integrator
        random : random start for the pseudo-random sequence
        version : (optional input) prints version number before execution. 
        help    : (optional input) prints the documentation and exits.
        F : Amplification factor of an EM-CCD camera, by default = 1 
    
EXAMPLE:
    See unitary test at the end of file 
    
RESTRICTIONS:
    This code is copyright (c) ONERA, 2009. 
    
SOURCE:
    This code is born from Choquet and Cassaing&#39;s IDL code developped at ONERA\
    (2009)
    
&#34;&#34;&#34;
        

    &#34;&#34;&#34;
    LOAD INTERFEROMETER INFOS
    &#34;&#34;&#34;

    filepath = Interferometer
    if not os.path.exists(filepath):
        raise Exception(f&#34;{filepath} doesn&#39;t exist.&#34;)
    
    with fits.open(filepath) as hdu:
        ArrayParams = hdu[0].header
        NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
        TelData = hdu[1].data
        BaseData = hdu[2].data
        
        TelNames = TelData[&#39;TelNames&#39;]
        TelCoordinates = TelData[&#39;TelCoordinates&#39;]
        TelTransmissions = TelData[&#39;TelTransmissions&#39;]
        TelSurfaces = TelData[&#39;TelSurfaces&#39;]
        BaseNames = BaseData[&#39;BaseNames&#39;]
        BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
        
        
    # Redundant number of baselines
    NB = NA**2
    
    # Non-redundant number of Closure Phase
    NC = int((NA-2)*(NA-1))
   
    NP = config.FS[&#39;NP&#39;]
    
# TEMPORAL PARAMETERS
    
    MT=int(NT/OT)                        # Total number of temporal samples
    timestamps = np.arange(NT)*dt       # Time sampling in [ms]
    
# SPECTRAL PARAMETERS
    
    if len(spectra) == 0:
        raise ValueError(&#39;Lambda array required&#39;)      # Array which contains our signal&#39;s 
                                            # pseudo wavenumbers (1/lambda)
    
    NW = len(spectra)
    
    OW = int(NW/MW)                         # Oversampling factor
    if len(spectraM) == 0:
        spectraM = np.array([np.mean(spectra[i*OW:(i+1)*OW]) for i in range(MW)])
        
        
    if PDspectra==0:
        PDspectra = np.mean(spectraM) 
        

    if type(qe) == float:
        qe=qe*np.ones(MW)

    # Disturbance Pattern
    
    OW = int(NW/MW)
    if OW != NW/MW:
        raise ValueError(&#39;Oversampling might be integer.&#39;)
    

    # CONFIG PARAMETERS
    
    dyn=0.                                  # to be updtated later by FS (for ex via coh_algo)
      
    if imsky == []:
        imsky = np.zeros([MW,NP])               # Sky background
    if sigsky == []:
        sigsky = np.zeros([MW,NP])              # Darknoise image


    # Observation parameters
    config.ObservationFile = ObsFile
    config.DisturbanceFile = DisturbanceFile
    config.NA=NA
    config.NB=NB
    config.NC=NC
    config.NIN=NIN
    config.MT=MT
    config.NT=NT
    config.OT=OT
    config.timestamps = timestamps
 
    # Fringe Sensor parameters
    config.NW=NW
    config.MW=MW
    config.OW=OW
    config.NX=0
    config.NY=0
    config.ND=ND
    config.dt=dt                    # ms

    # Noises
    config.noise=noise
    config.ron=ron
    config.FS[&#39;sigsky&#39;] = config.FS[&#39;sigsky&#39;]*ron
    config.phnoise=phnoise
    config.G = G
    config.enf=enf
    config.M=M

    if latencytime == 0:
        config.latency = config.dt
    else:
        config.latency = round(latencytime/config.dt)
    
    
    # Random Statemachine seeds
    config.seedph=seedph
    config.seedron=seedron
    config.seeddist=seeddist
    
    # Fringe tracker
    config.starttracking = starttracking
    
    
    # Source description
    config.spectra=spectra
    config.spectraM=spectraM
    config.PDspectra=PDspectra
    config.dyn=dyn
    
    # Simulation parameters
    # config.SimuFilename=SimuFilename        # Where to save the data
    config.TELref=TELref             # For display only: reference delay line
    
    config.ich = np.zeros([NIN,2])
    for ia in range(NA):
        for iap in range(ia+1,NA):
            config.ich[coh_tools.posk(ia,iap,NA)] = [ia,iap]
    
    config.CPindex = np.zeros([NC,3])
    for ia in range(NA):
        for iap in range(ia+1,NA):
            for iapp in range(iap+1,NA):
                config.CPindex[coh_tools.poskfai(ia,iap,iapp,NA)] = [ia,iap,iapp]

    return </code></pre>
</details>
</dd>
<dt id="coh_lib.skeleton.loop"><code class="name flex">
<span>def <span class="ident">loop</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Core of the simulator. This routine calls the different modules according
to the simulation timeline.
At the end, the data must be stored in a file. It has not yet been
developped.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>DisturbanceFitsfile</code></strong> :&ensp;<code>STRING</code></dt>
<dd>Fits file containing the disturbance data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop(*args):
    &#34;&#34;&#34;
    Core of the simulator. This routine calls the different modules according
    to the simulation timeline. 
    At the end, the data must be stored in a file. It has not yet been 
    developped.
    
    Parameters
    ----------
    DisturbanceFitsfile : STRING
        Fits file containing the disturbance data.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    
    from . import simu

    from .config import NT, timestamps, spectra
    
    # Reload simu module for initialising the observables with their shape
    reload(simu)
    
    # Importation of the object 
    CfObj, CPObj = coh_tools.get_CfObj(config.ObservationFile,spectra)
    
    #scaling it to the spectral sampling  and integration time dt
    delta_wav = np.abs(spectra[1]-spectra[2])
    
    CfObj = CfObj * delta_wav
    CfObj = CfObj * config.dt*1e-3
    
    
    simu.ClosurePhaseObject = CPObj
    simu.CoherentFluxObject = CfObj
    
    # Importation of the disturbance
    CfDist, PistonDist, TransmissionDist = coh_tools.get_CfDisturbance(config.DisturbanceFile, spectra, timestamps)
    simu.CfDisturbance = CfDist
    simu.PistonDisturbance = PistonDist
    simu.TransmissionDisturbance = TransmissionDist    
    # simu.PhotometryDisturbance = np.zeros([config.NT,config.NW,config.NA])
    
    for ia in range(config.NA):
        PhotometryObject = np.abs(CfObj[:,ia*(config.NA+1)])
        simu.PhotometryDisturbance[:,:,ia] = simu.TransmissionDisturbance[:,:,ia]*PhotometryObject

    simu.FTmode[:config.starttracking] = np.zeros(config.starttracking)

    print(&#34;Processing simulation ...&#34;)
    
    simu.it = 0
    time0 = time.time()
    for it in range(NT):                        # We browse all the (macro)times
        simu.it = it
        
        # Coherence of the ODL
        CfODL = coh__pis2coh(-simu.CommandODL[it,:],1/config.spectra)
        
        currCfTrue = CfObj * simu.CfDisturbance[it,:,:] * CfODL
        simu.CfTrue[it,:,:] = currCfTrue
        
        &#34;&#34;&#34;
        Fringe Sensor: From oversampled true coherences to macrosampled 
        measured coherences
        &#34;&#34;&#34;
        fringesensor = config.FS[&#39;func&#39;]
        currCfEstimated = fringesensor(currCfTrue)
        simu.CfEstimated[it,:,:] = currCfEstimated

        &#34;&#34;&#34;
        FRINGE TRACKER: From measured coherences to ODL commands
        &#34;&#34;&#34;
        if simu.FTmode[it] == 0:
            GainGD = config.FT[&#39;GainGD&#39;]
            GainPD = config.FT[&#39;GainPD&#39;]
            config.FT[&#39;GainGD&#39;] = 0
            config.FT[&#39;GainPD&#39;] = 0
        fringetracker = config.FT[&#39;func&#39;]
        CmdODL = fringetracker(currCfEstimated)
        config.FT[&#39;GainGD&#39;] = GainGD
        config.FT[&#39;GainPD&#39;] = GainPD
        
        simu.CommandODL[it+config.latency,:] = CmdODL
        
        checkpoint = int(NT/10)
        if (it%checkpoint == 0) and (it!=0):
            processedfraction = it/NT
            LeftProcessingTime = (time.time()-time0)*(1-processedfraction)/processedfraction
            print(f&#39;Processed: {processedfraction*100}%, Elapsed time: {round(time.time()-time0)}s&#39;)

    
    # Process observables for visualisation
    simu.PistonTrue = simu.PistonDisturbance - simu.CommandODL[:-config.latency]

    # Save true OPDs in an observable
    for ia in range(config.NA):
        for iap in range(ia+1,config.NA):
            ib = coh_tools.posk(ia,iap,config.NA)
            simu.OPDTrue[:,ib] = simu.PistonTrue[:,ia] - simu.PistonTrue[:,iap]
            simu.OPDDisturbance[:,ib] = simu.PistonDisturbance[:,ia] - simu.PistonDisturbance[:,iap]
            simu.OPDCommand[:,ib] = simu.CommandODL[:,ia] - simu.CommandODL[:,iap]    
    
    # print(args)
    if len(args):
        print(f&#39;Saving infos in {filepath}&#39;)
        filepath = args[0]
        
        fileexists = os.path.exists(filepath)
        
        if fileexists:
            if &#39;overwrite&#39; in args:
                os.remove(filepath)
            else:
                overwrite = (input(f&#39;{filepath} already exists. Do you want to overwrite it? (y/n)&#39;) == &#39;y&#39;)
                if overwrite:
                    os.remove(filepath)
                else:
                    return
        
        
        hdr = fits.Header()
        hdr[&#39;Date&#39;] = time.strftime(&#34;%a, %d %b %Y %H:%M&#34;, time.localtime())
        hdr[&#39;ObservationFile&#39;] = config.ObservationFile
        hdr[&#39;DisturbanceFile&#39;] = config.DisturbanceFile
        for key in [&#39;NA&#39;, &#39;dt&#39;, &#39;ron&#39;, &#39;enf&#39;]:
            print(key)     
            hdr[key] = getattr(config, key)
            
        primary = fits.PrimaryHDU(header=hdr, data= config.spectra)
        col1 = fits.Column(name=&#39;OPDTrue&#39;, format=&#39;15D&#39;, array=simu.OPDTrue)
        col2 = fits.Column(name=&#39;PistonTrue&#39;, format=&#39;6D&#39;, array=simu.PistonTrue)
        
        coldefs = fits.ColDefs([col1, col2])
        hdu1 = fits.BinTableHDU.from_columns(coldefs, name=&#39;Observables&#39; )

        hdu = fits.HDUList([primary, hdu1])
        
        hdu.writeto(filepath)
    
    return</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coh_lib" href="index.html">coh_lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="coh_lib.skeleton.FSdefault" href="#coh_lib.skeleton.FSdefault">FSdefault</a></code></li>
<li><code><a title="coh_lib.skeleton.MakeAtmosphereCoherence" href="#coh_lib.skeleton.MakeAtmosphereCoherence">MakeAtmosphereCoherence</a></code></li>
<li><code><a title="coh_lib.skeleton.ReadCf" href="#coh_lib.skeleton.ReadCf">ReadCf</a></code></li>
<li><code><a title="coh_lib.skeleton.SaveSimulation" href="#coh_lib.skeleton.SaveSimulation">SaveSimulation</a></code></li>
<li><code><a title="coh_lib.skeleton.ShowPerformance" href="#coh_lib.skeleton.ShowPerformance">ShowPerformance</a></code></li>
<li><code><a title="coh_lib.skeleton.SimpleCommandCalc" href="#coh_lib.skeleton.SimpleCommandCalc">SimpleCommandCalc</a></code></li>
<li><code><a title="coh_lib.skeleton.SimpleIntegrator" href="#coh_lib.skeleton.SimpleIntegrator">SimpleIntegrator</a></code></li>
<li><code><a title="coh_lib.skeleton.SpectralAnalysis" href="#coh_lib.skeleton.SpectralAnalysis">SpectralAnalysis</a></code></li>
<li><code><a title="coh_lib.skeleton.addnoiseADU" href="#coh_lib.skeleton.addnoiseADU">addnoiseADU</a></code></li>
<li><code><a title="coh_lib.skeleton.coh__matcoher2real" href="#coh_lib.skeleton.coh__matcoher2real">coh__matcoher2real</a></code></li>
<li><code><a title="coh_lib.skeleton.coh__phasor2coher" href="#coh_lib.skeleton.coh__phasor2coher">coh__phasor2coher</a></code></li>
<li><code><a title="coh_lib.skeleton.coh__pis2coh" href="#coh_lib.skeleton.coh__pis2coh">coh__pis2coh</a></code></li>
<li><code><a title="coh_lib.skeleton.display" href="#coh_lib.skeleton.display">display</a></code></li>
<li><code><a title="coh_lib.skeleton.initialize" href="#coh_lib.skeleton.initialize">initialize</a></code></li>
<li><code><a title="coh_lib.skeleton.loop" href="#coh_lib.skeleton.loop">loop</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>