<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>coh_lib.coh_tools API documentation</title>
<meta name="description" content="Created on Fri Mar
6 16:14:42 2020 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coh_lib.coh_tools</code></h1>
</header>
<section id="section-intro">
<p>Created on Fri Mar
6 16:14:42 2020</p>
<p>@author: cpannetier</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Fri Mar  6 16:14:42 2020

@author: cpannetier
&#34;&#34;&#34;

import os
# os.chdir(&#39;C:/Users/cpannetier/Documents/These/FringeTracking/Python/coh_pack/coh_lib&#39;)
datadir = &#39;data/&#39;

import pandas as pd
import numpy as np
from scipy.special import jv
from scipy import interpolate

import astropy.units as u
from astropy.time import Time
from astropy.coordinates import SkyCoord, EarthLocation, AltAz

from astropy.io import fits

from . import config
import coh_lib.decorators as deco

global h_, c_, k_

h_ = 6.626e-34  # Planck&#39;s constant
c_ = 3.0e+8     # Light velocity
k_ = 1.38e-23    # Boltzmann&#39;s constant


class Error(Exception):
    &#34;&#34;&#34;Base class for exceptions in this module.&#34;&#34;&#34;
    pass

class InputError(Error):
    &#34;&#34;&#34;Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    &#34;&#34;&#34;

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message


def BBstar(wav, T):
    &#34;&#34;&#34;
    Returns the spectral luminance of a black-body given its temperature.
    Will be useful to give the shape of the spectra of a star.

    Parameters
    ----------
    wav : [NW] float [meter]
        Wavelength in meter.
    T : float [K]
        Temperature of the Black-Body in Kelvin.

    Returns
    -------
    luminance : [NW] floats [W/s/m²/sr]
        Luminance of the source per steradian.

    &#34;&#34;&#34;
    global h_, c_, k_
    
    a = 2.0*h_*c_**2
    b = h_*c_/(wav*k_*T)
    luminance = a / ( (wav**5) * (np.exp(b) - 1.0) ) # W/m²/sr/µm
    
    # nu = c_/spectra   # Electromagnetic frequency [Hz]
    # a = 2.*h_/c_**2
    # b = h_/k_/T
    # B_sig = a*nu**3/(np.exp(b*nu)-1)  # W/m²/sr/s
    
    return luminance


def info_array(array, band):
    &#34;&#34;&#34;
    Stores the transmission efficiencies of the CHARA interferometer in the
    expected bands: so far, R and H.
    Gives the same transmission for all telescopes.
    Take into account:
        - Telescope mirror transmission
        - Injection loss: in fibers
        - Strehl ratio: 
        - Beam splitters - Part of the flux is used for:
            - For AO in R band
            - For image control in R band
            - For photometry calibration in R band

    Parameters
    ----------
    array : STRING
        Array name.
    band : STRING
        Observation band: H or R.

    Raises
    ------
    ValueError
        If array is not CHARA.

    Returns
    -------
    transmission : FLOAT
        Total transmission.

    &#34;&#34;&#34;
    if array == &#39;chara&#39;: # information in SPICA JOSAA paper
        if band == &#39;H&#39;:     
            T_tel = 0.1
            T_inj = 0.65
            T_strehl = 0.8
            T_BS = 1            # No beam splitter in H ? OA?
        if band == &#39;R&#39;:
            T_tel = 0.03
            T_inj = 0.5
            T_strehl = 0.8
            T_BS = 0.88         # Transmission beam-splitter before injection
        
        # Diameter of a telescope and collecting surface [meter²]
        diameter = 1                            
        surface = np.pi*diameter**2/4            
        
        surface = 0.74 #MAM thesis - diameter=1m and occultation=0.25m
                                
    else:
        raise ValueError(&#39;So far, there is data for &#34;chara&#34; only.&#39;)
        
    transmission = T_tel*T_inj*T_strehl*T_BS

    return transmission, surface
    

def get_array(name,getcoords=False):
    &#34;&#34;&#34;
    Returns the coordinates, baselines and base names of a given array

    Parameters
    ----------
    name : STRING
        Name of the array.
    getcoords : BOOLEAN, optional
        If True, add the array coordinates to the output.
        The default is False.

    Raises
    ------
    NameError
        Name must be &#39;CHARA&#39;.

    Returns
    -------
    TelNames : [NA] list strings
        Names of the telescopes
    BaseNames : [NB] strings
        Name of each baseline.
    BaseNorms : [NB] floats [meter]
        Baselines.
    coords, OPTIONAL: [NA,3] FLOAT ARRAY [meter]
        Coordinates of the array, following the format:
            (XOFFSET,YOFFSET,ZOFFSET) where:
                XOFFSET - East offset in microns from S1
                YOFFSET - North offset in microns from S1
                ZOFFSET - vertical (+ is up) offset in microns from S1,,)
        Take S1 as reference.
    
    &#34;&#34;&#34;
    
    print(name)
    if name == &#39;CHARA&#39;:         
            
        #official coordinates in [µm]
        coords = np.array([[125333989.819,305932632.737,-5909735.735],\
                                 [70396607.118,269713282.258,-2796743.645],\
                                     [0,0,0],\
                                         [-5746854.437,33580641.636,636719.086],\
                                             [-175073332.211,216320434.499,-10791111.235],\
                                                 [-69093582.796,199334733.235,467336.023]])
        coords=coords*1e-6      # [m]
        
    else:
        raise NameError(&#39;Array name must be &#34;CHARA&#34;&#39;)
        
    NA = np.shape(coords)[0]
    
    TelNames = [&#39;E1&#39;,&#39;E2&#39;,&#39;S1&#39;,&#39;S2&#39;,&#39;W1&#39;,&#39;W2&#39;]
    BaseNames = []
    BaseNorms =[]
    config.BasesVectors = np.array([])
    for ia in range(NA):
        for iap in range(NA):
            
            BaseNames.append(str(TelNames[ia]+TelNames[iap]))
            BaseNorms.append(np.sqrt((coords[ia,0]-coords[iap,0])**2 + \
                                    (coords[ia,1]-coords[iap,1])**2 + \
                                  (coords[ia,2]-coords[iap,2])**2))
               
            
    if getcoords:
        return TelNames, BaseNames, BaseNorms, coords
        
    config.BasesVectors
    return TelNames, BaseNames, BaseNorms
    

def get_Bproj(baseline, theta):
    &#34;&#34;&#34;
    Calculates projected bases acording to the viewed angle in radian

    Parameters
    ----------
    baseline : float [meter]
        Distance between telescopes in meters.
    theta : float [radian]
        Angle viewed by the base (depend on declination and azimuth).
        
    Returns
    -------
    Bproj : float [meter]
        Projected base.

    &#34;&#34;&#34;
    
    Bproj = baseline * np.sin(theta)
    return Bproj


def get_visibility(alpha, baseline, spectra, model=&#39;disk&#39;):
    &#34;&#34;&#34;
    Using the Bessel expression of the visibility of a centered circular star,
    returns the spectral absolute visibility curve of a centered star of 
    angular diameter alpha as seen with the given baseline distance.
    Replaced by VanCittert function that calculates complex visibilities
    with a more realistic calculation.

    Parameters
    ----------
    alpha : float [radian]
        Angular diameter
    base : float [meter]
        Baseline
    spectra : [MW] floats [µm]
        Wavelength.
    model : string, optional
        The model of the object. The default is &#39;disk&#39;.

    Returns
    -------
    V : [MW]
        Spectral visibilities of the object.

    &#34;&#34;&#34;
    spectra = spectra*1e-6
    if model == &#39;disk&#39;:
        if base == 0:
            V = 1
        else:
            V = np.abs(2*jv(1, np.pi*alpha*baseline/spectra)/(np.pi*alpha*baseline/spectra))

    return V


@deco.timer
def VanCittert(spectra, Obs, Target,display=False):
    &#34;&#34;&#34;
    Create the Coherent flux matrix of an object in the (u,v) plane according
    to:
        - the Observation parameters: array, date and star coords.
        - the Science object: angular diameters, positions, relative luminosity


    Parameters
    ----------
    spectra : TYPE
        DESCRIPTION.
    starname : TYPE, optional
        DESCRIPTION. The default is &#39;Deneb&#39;.
    angdiameters : TYPE, optional
        DESCRIPTION. The default is (0.3,0.3).
    relative_L : TYPE, optional
        DESCRIPTION. The default is (1,1).
    display : TYPE, optional
        DESCRIPTION. The default is False.

    Returns
    -------
    visibilities : ARRAY [NW,NIN]*1j
        DESCRIPTION.

    &#34;&#34;&#34;
        
    print(&#34;Calculation of object&#39;s visibilities from Van Cittert theorem\n ...&#34;)

    # Relative positions of the two stars
    pos_star1 = Target.Star1[&#39;Position&#39;]
    angular_diameter1 = Target.Star1[&#39;AngDiameter&#39;]
    H1 = Target.Star1[&#39;Hmag&#39;]
    
    BinaryObject = True
    try:
        pos_star2 = Target.Star2[&#39;Position&#39;]
        angular_diameter2 = Target.Star2[&#39;AngDiameter&#39;]
        H2 = Target.Star2[&#39;Hmag&#39;]
    except:
        print(&#39;Simple centered star1&#39;)
        BinaryObject = False
        
        # angular_diameter2 = angular_diameter1
        # H2 = 0
        
    # pos_star1 = np.array([1,-1])
    # pos_star2 = np.array([-1,1])
    
    # BinaryObject = (type(angdiameters) == tuple)
    
    if BinaryObject:
        # Calculation of a relative luminosity
        (luminosity1,luminosity2) = (10**(-0.4*H1),10**(-0.4*H2))
        # (angular_diameter1,angular_diameter2) = angdiameters
        
        # Pixel unit luminance ratio between both stars
        LuminanceRatio = luminosity1/angular_diameter1*angular_diameter2/luminosity2
    # else:
    #     # angular_diameter1 = angdiameters
    #     # angular_diameter2 = angdiameters
    #     luminosity1 = 1
    #     # luminosity2 = 0
    #     # pos_star1 = np.array([0,0])
    
    
    # Npix = 1024
    # thetamax = 10
    # dtheta = 2*thetamax/Npix
    
    # dtheta must well sample the smallest star
    if BinaryObject:
        dtheta = np.min((angular_diameter1,angular_diameter2))/5
    else:
        dtheta = angular_diameter1/5
    
    # thetamax must be sufficiently high compared to the widest star
    # if BinaryObject:
    #     thetamax = 100*np.max((angular_diameter1,angular_diameter2))
    # else:
    #     thetamax = 100*angular_diameter1
    
    Npix = 5000     #2*int(thetamax/dtheta)

    thetamax = dtheta*Npix/2

    obj_plane = np.zeros([Npix,Npix])
    
    coords = (np.arange(Npix)- Npix/2)*dtheta
    (alpha,beta) = np.meshgrid(coords,-coords)
    dist1 = np.sqrt((alpha-pos_star1[0])**2 + (beta-pos_star1[1])**2)
    obj_plane[dist1&lt;angular_diameter1] = 1
    NpixStar1 = np.sum(obj_plane)
    
    if BinaryObject:
        dist2 = np.sqrt((alpha-pos_star2[0])**2 + (beta-pos_star2[1])**2)
        obj_plane[dist2&lt;angular_diameter2] = 1/LuminanceRatio
        
    
    # Normalisation of the luminosity, with first star as reference
    obj_plane = obj_plane/NpixStar1

    Nticks = 7
    ticks = np.linspace(0,Npix,Nticks)
        
    if display:            

        spaceticks = (ticks-round(Npix/2))*dtheta
        spaceticks = spaceticks.round(decimals=1)
        
        plt.figure(config.newfig), plt.title(&#39;Object&#39;)
        plt.imshow(obj_plane)
        plt.xticks(ticks,spaceticks)
        plt.yticks(ticks,-spaceticks)
        plt.xlabel(&#39;\u03B1 [mas]&#39;)
        plt.ylabel(&#39;\u03B2 [mas]&#39;)
        plt.show()
        config.newfig +=1
    
    # Van-Cittert theorem (calculation of the visibility)
    
    uv_plane = np.fft.ifftshift(np.fft.fft2(np.fft.fftshift(obj_plane)))
    uv_plane /= np.max(np.abs(uv_plane))
    
    # (u,v) sampling
    freqs = np.fft.fftshift(np.fft.fftfreq(Npix, dtheta))
    dfreq = freqs[1] - freqs[0]
    (ucoords,vcoords) = np.meshgrid(freqs, -freqs)
    freqticks = (ticks-round(Npix/2))*dfreq
    freqticks = freqticks.round(decimals=1)
    
    if display:        
        plt.figure(config.newfig), plt.title(&#39;Module of the visibility&#39;)
        plt.imshow(np.abs(uv_plane))
        plt.xticks(ticks,freqticks)
        plt.yticks(ticks,-freqticks)
        plt.xlabel(&#39;u [mas-1]&#39;)
        plt.ylabel(&#39;v [mas-1]&#39;)
        plt.show()
        config.newfig+=1
        
        plt.figure(config.newfig), plt.title(&#39;Phase of the visibility&#39;)
        plt.imshow(np.angle(uv_plane))
        plt.xticks(ticks,freqticks)
        plt.yticks(ticks,-freqticks)
        plt.xlabel(&#39;u [mas-1]&#39;)
        plt.ylabel(&#39;v [mas-1]&#39;)
        plt.show()
        config.newfig+=1
    
    &#34;&#34;&#34;
    Projection of the interferometer on the (u,v) plane
    &#34;&#34;&#34;
    
    # Get telescopes coordinates and names
    TelNames,_,_,CHARAcoords = get_array(config.Name, getcoords=True)    
    
    CHARAcoords *= 1e6          # Convert to [µm]
    NA = len(CHARAcoords)
    
    CHARAaltaz = np.zeros([NA,2])
    for ia in range(NA):
        if np.linalg.norm(CHARAcoords[ia]) == 0:
            CHARAaltaz[ia,0] = 0
            CHARAaltaz[ia,1] = 0    
        else:
            CHARAaltaz[ia,1] = np.arctan(CHARAcoords[ia,0]/CHARAcoords[ia,1])
            CHARAaltaz[ia,0] = np.arcsin(CHARAcoords[ia,2]/np.linalg.norm(CHARAcoords[ia]))
    
    NIN = int(NA*(NA-1)/2)
    basealtaz = np.zeros([NIN,2])       # Altazimuthal coordinates of the baselines [radians]
    basedist = np.zeros([NIN,1])        # Baselines lengths in [µm]
    basecoords = np.zeros([NIN,3])      # Baselines coordinates [µm]
    basenames = []                      # Baselines names [string]
    
    for ia in range(NA):
        for iap in range(ia+1,NA):
            ib = int(ia*NA-ia*(ia+3)/2+iap-1)
            
            basealtaz[ib] = CHARAaltaz[iap]-CHARAaltaz[ia]
            
            basenames.append(TelNames[ia]+TelNames[iap])
            basecoords[ib] = CHARAcoords[iap] - CHARAcoords[ia]
            basedist[ib] = np.linalg.norm(basecoords[ib])
    
    
    # First case: the name of the object has been given. We search it in Simbad
    # database and its AltAzimutal coordinates if a Date has been given.
    if Target.Name not in (&#39;Simple&#39;,&#39;Binary&#39;):
        starttime = Time(Obs.Date)
        print(f&#34;Observation date: {Obs.Date}&#34;)
    
        starcoords = SkyCoord.from_name(Target.Name)
        staraltaz = starcoords.transform_to(AltAz(obstime=starttime,location=Obs.ArrayName))
        
        (altitude, azimuth) = (staraltaz.alt.radian,staraltaz.az.radian)
        
    else:
        (altitude, azimuth) = (theta*np.pi/180 for theta in Obs.AltAz)
        print(f&#34;User defined {Target.Name} object with AltAz={Obs.AltAz}&#34;)
        
    
    # Projection baselines on (u,v) plane
    baselines = np.transpose(basedist)*np.sin(altitude-basealtaz[:,0])
    
    NW = len(spectra)
    # Projection baselines on the u,v coordinates (oriented with the star north-east)
    chara_uv = np.zeros([NW,NIN,2])
    for iw in range(NW):
        lmbda=spectra[iw]
        chara_uv[iw,:,0] = baselines*np.cos(azimuth-basealtaz[:,1])/lmbda
        chara_uv[iw,:,1] = baselines*np.sin(azimuth-basealtaz[:,1])/lmbda
    
    # Conversion functions
    mas2rad = lambda mas : 1/3600*1e-3*np.pi/180*mas
    rad2mas = lambda rad : 3600*1e3*180/np.pi*rad

    #Convert (u,v) plane from radian to mas
    chara_uv_direct = 1/chara_uv
    chara_uv_direct_mas = rad2mas(chara_uv_direct)
    chara_uv = 1/chara_uv_direct_mas
    
    if display:         # Display (u,v) plane with interferometer projections (first wavelength)
        print(f&#39;Plot CHARA (u,v) coverage on figure {config.newfig}&#39;)    
        chara_uv_complete = np.concatenate((chara_uv[0], -chara_uv[0]),axis=0)
        
        uvmax = np.max(chara_uv[0]/dfreq)+10
        
        Ndisplay = 2*int(uvmax+10)
        
        uv_crop = uv_plane[(Npix-Ndisplay)//2:(Npix+Ndisplay)//2,(Npix-Ndisplay)//2:(Npix+Ndisplay)//2]
        chara_plot = chara_uv_complete/dfreq+Ndisplay/2
        
        Nticks = 11
        ticks = np.linspace(0,Ndisplay-1,Nticks)
        freqticks = (ticks+1-round(Ndisplay/2))*dfreq
        freqticks = freqticks.round(decimals=1)
        
        # Display the Visibility and the interferometer baselines on the (u,v) plane
        fig = plt.figure(config.newfig)
        ax = fig.subplots()
        fig.suptitle(&#39;(u,v) coverage&#39;)
        ax.imshow(np.abs(uv_crop))
        ax.plot(chara_plot[:,0], chara_plot[:,1], &#39;.&#39;, linewidth=1, color=&#39;firebrick&#39;)
        plt.xticks(ticks,freqticks)
        plt.yticks(ticks,-freqticks)
        plt.xlabel(&#39;u [mas-1]&#39;)
        plt.ylabel(&#39;v [mas-1]&#39;)
        config.newfig += 1
        
    # Return the complex visibility vector of the source
    visibilities = np.zeros([NW,NIN])*1j
    for iw in range(NW):
        for ib in range(NIN):
            baselinecoords = chara_uv[iw,ib]
            closestfreq = ((ucoords - baselinecoords[0])**2+(vcoords - baselinecoords[1])**2).argmin()
            Nx = closestfreq//Npix
            Ny = closestfreq%Npix
            visibilities[iw,ib] = uv_plane[Nx,Ny]
    
    print(&#34;Visibilities calculated.&#34;)
    return visibilities

def create_obsfile(spectra, Obs, Target, savingfilepath=&#39;&#39;, overwrite=False, display=False):
    &#34;&#34;&#34;
    Returns the absolute spectral photometry of a star given physical properties 
    (BlackBody approx), its angular diameter and the array parameter. 

    Parameters
    ----------
    spectra : TYPE
        DESCRIPTION.
    magH : FLOAT
        Star&#39;s magnitude in H-band.
    array : STRING
        Name of the array among [&#39;chara&#39;].
    angdiameters : FLOAT OR TUPLE
        Angular diameter of the object. 
        If one star, expects float. If two stars, expects tuple.
    surface : FLOAT
        Collecting surface of the telescope. 
        Necessary for photometry.
    angle : FLOAT
        Star&#39;s angular distance to horizon in radian. (elevation)
        Necessary for CHARA&#39;s projection on (u,v) plane.
    starfile : TYPE
        DESCRIPTION.
    savingname : TYPE, optional
        DESCRIPTION. The default is &#39;&#39;.
    display : TYPE, optional
        DESCRIPTION. The default is False.
    **kwargs : TYPE
        DESCRIPTION.

    Returns
    -------
    spectrum : FLOAT ARRAY [NW,NB]
        Spectral photon distribution including visibility and star photometry
        on all baselines. [ph/s]
    phot : [NW]
        Spectral photon distribution [pht/s/telescope/µm] of the star without visibility.
    VisObj : COMPLEX ARRAY [NW,NB]
        DESCRIPTION.
    CPObj : FLOAT ARRAY [NW,NC]
    
    BaseNorms : TYPE
        DESCRIPTION.
    TelNames : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;

    fileexists = os.path.exists(savingfilepath)
    if fileexists:
        print(f&#39;{savingfilepath} already exists.&#39;)
        if overwrite:
            os.remove(savingfilepath)
        else:
            raise Exception(&#34;You didn&#39;t ask to overwrite it.&#34;)          

    # spectra = 1/sigma     # [µm] Wavelengths
    NW = len(spectra)     # [int] Wavelengths number
    
    # First case: Temperature of the first star is given
    # We compute a BlackBody model
    if &#39;T&#39; in Target.Star1.keys():    
        T=Target.Star1[&#39;T&#39;]
        Irradiance = BBstar(spectra*1e-6, T)       # Create BB star model in wavelengths    
        Irradiance = Irradiance[::-1]             # (Reverse) the spectra according to sigmas
        norm = np.mean(Irradiance[(spectra&gt;=1.4)*(spectra&lt;=1.75)])    # Normalization of the flux on the whole H band
        Irradiance/=norm

    else:
        Irradiance=np.ones_like(spectra)
        
    magH = Target.Star1[&#39;Hmag&#39;]
    # Luminance according to apparent magnitude    
    
    L0_ph = 93.3e8        # Photons.m-2.s-1.µm-1 at 1.63µm
    
    Lph_H = L0_ph*10**(-0.4*magH)
    
    # delta_wav = np.abs(spectra[0] - spectra[1])     # Width of a spectral channel
    
    # Preference for photons directly to keep a uniform spectra
    UncohIrradiance = Irradiance*Lph_H             # [phot/s/m²/deltalmbda] Source Irradiance 
    
    # Using Watt as reference and converting in photons: drawback=non uniform spectra
    # L0_w = 7 * 10**(-10)                      # [W/m²/µm] Reference luminance at 1.65µm (Lena)
    # L0_w = 11.38 * 10**(-10)                  # [W/m²/µm] Reference luminance at 1.63µm (Bessel)
    # Lw_H = L0_w*10**(-0.4*magH)                        # Definition of the magnitude
    # UncohIrradiance_w = luminance*Lw_H*delta_wav / (h_*c_/spectra*1e6)          # [phot/s/m²/deltalmbda]


    filepath = Obs.Filepath
    if not os.path.exists(filepath):
        raise Exception(f&#34;{filepath} doesn&#39;t exist.&#34;)
    
    with fits.open(filepath) as hdu:
        ArrayParams = hdu[0].header
        NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
        ArrayName = ArrayParams[&#39;NAME&#39;]
        TelData = hdu[1].data
        BaseData = hdu[2].data
        
        TelNames = TelData[&#39;TelNames&#39;]
        TelCoordinates = TelData[&#39;TelCoordinates&#39;]
        TelTransmissions = TelData[&#39;TelTransmissions&#39;]
        TelSurfaces = TelData[&#39;TelSurfaces&#39;]
        BaseNames = BaseData[&#39;BaseNames&#39;]
        BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
        
    NB = NA**2
    NC = (NA-2)*(NA-1)
    
    # Transportation of the star light into the interferometer
    Throughput = np.reshape(TelSurfaces*TelTransmissions,[1,NA])
    ThroughputMatrix = np.sqrt(np.dot(np.transpose(Throughput), Throughput))
    ThroughputMatrix = ThroughputMatrix.reshape([1,NB])
    # Matrix where the element at the (ia*NA+iap) position is Ta*Tap
    # UncohIrradianceAfterTelescopes = np.dot(np.diag(TelTransmissions),np.transpose(UncohIrradiance))
        
    BaseNorms = np.linalg.norm(BaseCoordinates, axis=1)
    
    # Projection of the base on the (u,v) plane
    BaseNorms = get_Bproj(np.array(BaseNorms), Obs.AltAz[0])
    
    VisObj = np.zeros([NW,NB])*1j       # Object Visibility [normalised]
    CohIrradiance = np.zeros([NW,NB])*1j        # Source coherent Irradiance [phot/s/m²/deltalmbda]    
      
    # UncohIrradianceAfterTelescopes = UncohIrradiance*TelTransmissions*TelSurfaces
    

    if Target.Name == &#39;Unresolved&#39;:
        VisObj = np.ones([NW,NB])
        CPObj = np.zeros([NW,NC])
        
    elif Target.Name == &#39;Manual&#39;:
        phi = np.zeros([NW,NB])
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                phi[:,ia*NA+iap] = Target.Phases[ib]
                phi[:,iap*NA+ia] = -Target.Phases[ib]
        VisObj = np.exp(1j*phi)
        # VisObj = np.repeat(VisObj[np.newaxis,:],NW,axis=0)
        
        bispectrum = np.zeros([NW,NC])*1j
        for ia in range(NA):
            for iap in range(ia+1,NA):
                for iapp in range(iap+1,NA):
                    ci1 = VisObj[:,ia*NA+iap]
                    ci2 = VisObj[:,iap*NA+iapp]
                    ci3 = VisObj[:,iapp*NA+ia]
                    ic = poskfai(ia,iap,iapp,NA)
                    bispectrum[:,ic] = ci1*ci2*ci3
        CPObj = np.angle(bispectrum)
        
    else:           # Van-Cittert theorem visibility
        visibilities = VanCittert(spectra, Obs, Target,display=display)
        
        
        bispectrum = np.zeros([NW,NC])*1j
        
        for ia in range(NA):
            VisObj[:,ia*(NA+1)] = np.ones(NW)
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                VisObj[:,ia*NA+iap] = visibilities[:,ib]
                VisObj[:,iap*NA+ia] = np.conj(visibilities[:,ib])
                for iapp in range(iap+1,NA):
                    cs1 = VisObj[:,ia*NA+iap]     # Coherent flux (ia,iap) 
                    cs2 = VisObj[:,iap*NA+iapp]  # Coherent flux (iap,iapp) 
                    cs3 = VisObj[:,iapp*NA+ia] # Coherent flux (iapp,ia) 
                    ic = poskfai(ia,iap,iapp,NA) 
                    bispectrum[:,ic]+=cs1*cs2*cs3
                    
        CPObj = np.angle(bispectrum)
        
    for iw in range(NW):    
        CohIrradiance[iw] = UncohIrradiance[iw] * ThroughputMatrix * VisObj[iw]
            
    # hdr = ArrayParams
    hdr = fits.Header()
    
    hdr[&#39;Filepath&#39;] = savingfilepath.split(&#39;/&#39;)[-1]
    hdr[&#39;ARRAY&#39;] = Obs.ArrayName
    hdr[&#39;Target&#39;] = Target.Name
    hdr[&#39;NA&#39;] = NA
    hdr[&#39;NIN&#39;] = NIN
    hdr[&#39;MINWAVE&#39;] = spectra[0]
    hdr[&#39;MAXWAVE&#39;] = spectra[-1]
    hdr[&#39;DWAVE&#39;] = spectra[1] - spectra[0]

    for attr in vars(Target).keys():
        if type(getattr(Target, attr)) is not dict:            
            if attr not in [&#39;Name&#39;,&#39;Filepath&#39;, &#39;Phases&#39;]:
                hdr[attr] = getattr(Target, attr)
        else:
            for key in getattr(Target, attr).keys():
                if key == &#39;Position&#39;:
                    hdr[f&#34;{attr}_alpha&#34;] = getattr(Target, attr)[key][0]
                    hdr[f&#34;{attr}_beta&#34;] = getattr(Target, attr)[key][1]
                else:
                    hdr[f&#34;{attr}_{key}&#34;] = getattr(Target, attr)[key]
                
    for attr in vars(Obs).keys():
        if isinstance(getattr(Obs, attr),
                      (str, int, float, complex, bool,
                       np.floating, np.integer, np.complexfloating,
                       np.bool_)):
            
            if attr != &#39;Filepath&#39;:
                if attr != ArrayName:
                    hdr[attr] = getattr(Obs, attr)
            else:
                hdr[&#39;ArrayFile&#39;] = getattr(Obs, attr).split(&#39;/&#39;)[-1]
        
    
    primary = fits.PrimaryHDU(header=hdr)
    
    im1 = fits.ImageHDU(np.real(VisObj), name=&#39;VReal&#39;)
    im2 = fits.ImageHDU(np.imag(VisObj), name=&#39;VImag&#39;)
    im3 = fits.ImageHDU(np.real(CohIrradiance), name=&#39;CfReal&#39;)
    im4 = fits.ImageHDU(np.imag(CohIrradiance), name=&#39;CfImag&#39;)
    im5 = fits.ImageHDU(CPObj, name=&#39;Closure Phase&#39;)
    
    col1 = fits.Column(name=&#39;WLsampling&#39;, format=&#39;1D&#39;, array=spectra)
    hdu1 = fits.BinTableHDU.from_columns([col1], name=&#39;spectra&#39; )
    
    hdu = fits.HDUList([primary,hdu1,im1,im2,im3,im4,im5])
    
    print(f&#39;Saving file into {savingfilepath}&#39;)
    hdu.writeto(savingfilepath)


    if display:
        plt.figure(config.newfig), plt.title(&#39;Absolute Visibility of the star on different baselines&#39;)
        plt.plot(spectra, np.abs(VisObj[:,0]), label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[0]+TelNames[0],BaseNorms[0]))  
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                plt.plot(spectra, np.abs(VisObj[:,k]), label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[ia]+TelNames[iap],BaseNorms[k]))  
        plt.xlabel(&#39;Wavelengths [µm]&#39;)
        plt.ylabel(&#39;Coherence Degree Module&#39;)
        plt.legend()
        plt.grid()
        plt.show()
        config.newfig+=1
        
        plt.figure(config.newfig), plt.title(&#39;Phase Visibility of the star on different baselines&#39;)
        plt.plot(spectra, np.angle(VisObj[:,0]), label=&#39;{0:}&#39;.format(&#39;Uncoherent flux&#39;))  
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                plt.plot(spectra, np.angle(VisObj[:,k]), label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[ia]+TelNames[iap],BaseNorms[k]))  
        plt.xlabel(&#39;Wavelengths [µm]&#39;)
        plt.ylabel(&#39;Coherence Degree Phase [rad]&#39;)
        plt.ylim([-1.1*np.pi,1.1*np.pi])
        plt.legend()
        plt.grid()
        plt.show()
        config.newfig += 1
    
        plt.figure(config.newfig), plt.title(f&#39;Irradiance of the star&#39;)
        plt.plot(spectra, UncohIrradiance)  
        plt.xlabel(&#39;Wavelengths [µm]&#39;)
        plt.ylabel(&#39;Irradiance [photons/s/m²/µm]&#39;)
        plt.grid()
        plt.show()
        config.newfig += 1
        
        
        plt.figure(config.newfig), plt.title(&#39;Coherent Irradiance of the star&#39;)
        plt.plot(spectra, np.abs(VisObj[:,0])*UncohIrradiance, label=&#39;{0:}&#39;.format(&#39;Uncoherent flux&#39;))  
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                plt.plot(spectra, np.abs(VisObj[:,k])*UncohIrradiance, label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[ia]+TelNames[iap],BaseNorms[k]))  
        plt.xlabel(&#39;Wavelengths [µm]&#39;)
        plt.ylabel(&#39;Irradiance [photons/s/m²/µm]&#39;)
        plt.legend()
        plt.grid()
        plt.show()
        config.newfig += 1
    
    return CohIrradiance, UncohIrradiance, VisObj, BaseNorms, TelNames


def get_CfObj(filepath, spectra):
    &#34;&#34;&#34;
    Reads data of an observation contained in a FITSfile.
    Adapt the spectral sampling to the FS spectral sampling.
    Return it

    Parameters
    ----------
    filepath : TYPE
        DESCRIPTION.
    spectra : TYPE
        DESCRIPTION.

    Returns
    -------
    CohIrradiance : ARRAY[NW,NB]
        Coherence Flux of the object in photons/s.
    ClosurePhase : ARRAY[NW,NC]
        Closure Phases of the object in radian.

    &#34;&#34;&#34;

    fileexists = os.path.exists(filepath)
    if not fileexists:
        raise Exception(f&#34;{filepath} doesn&#39;t exists.&#34;)          
    with fits.open(filepath) as hdu:

        ObsParams = hdu[0].header
        WLsampling = hdu[&#39;SPECTRA&#39;].data[&#39;WLsampling&#39;]
        
        real = hdu[&#39;VReal&#39;].data
        imag = hdu[&#39;VImag&#39;].data

        ComplexVisObj = real + imag*1j
        
        real = hdu[&#39;CfReal&#39;].data
        imag = hdu[&#39;CfImag&#39;].data

        CoherentIrradiance = real + imag*1j
        NW, NB = CoherentIrradiance.shape
        NA = int(np.sqrt(NB))
        NC = (NA-2)*(NA-1)
        ClosurePhase = np.zeros([NW,NC])
        for ia in range(NA):
            for iap in range(ia+1,NA):
                for iapp in range(iap+1,NA):
                    ic = poskfai(ia,iap,iapp,NA)
                    ci1 = CoherentIrradiance[:,ia*NA+iap]
                    ci2 = CoherentIrradiance[:,iap*NA+iapp]
                    ci3 = CoherentIrradiance[:,iapp*NA+ia]
                    ClosurePhase[:,ic] = np.angle(ci1*ci2*ci3)
        # ClosurePhase = hdu[&#39;Closure Phase&#39;].data
        
        f = interpolate.interp1d(WLsampling, CoherentIrradiance, axis=0)
        
        CoherentIrradiance = f(spectra)
        
    return CoherentIrradiance, ClosurePhase


def get_CfDisturbance(DisturbanceFile, spectra, timestamps):
    from . import simu
    
    with fits.open(DisturbanceFile) as hdu:
        RealCf = hdu[&#39;RealCf&#39;].data
        ImagCf = hdu[&#39;ImagCf&#39;].data
        FileCoherentFlux = RealCf + 1j*ImagCf
        CfDisturbance = FileCoherentFlux
        
        PistonDisturbance = hdu[&#39;Piston&#39;].data
        TransmissionDisturbance = hdu[&#39;Transmission&#39;].data
        
        filetimestamps = hdu[&#39;TimeSampling&#39;].data[&#39;timestamps&#39;]
        filespectra = hdu[&#39;SpectralSampling&#39;].data[&#39;spectra&#39;]
        
        try:
            simu.DisturbancePSD = hdu[&#39;Last tel PSD&#39;].data
            simu.FreqSampling = hdu[&#39;Frequency sampling&#39;].data
            simu.DisturbanceFilter = hdu[&#39;Disturbance Filter&#39;].data
            print(&#39;Disturbance PSD present in FITSfile.&#39;)
        except:
            print(&#39;No Disturbance PSD in FITSfile.&#39;)
            
    # Interpolate on the time axis   
    newobservables = []
    for observable in [CfDisturbance, PistonDisturbance, TransmissionDisturbance]:
        f = interpolate.interp1d(filetimestamps,observable, axis=0)
        newobservables.append(f(timestamps))
        
    
    TempCfDisturbance, PistonDisturbance, TempTransmissionDisturbance = newobservables
    
    # Interpolate on the spectral axis (Piston is not chromatic)
    newobservables = []
    for observable in [TempCfDisturbance, TempTransmissionDisturbance]:
        f = interpolate.interp1d(filespectra,observable, axis=1)
        newobservables.append(f(spectra))
    
    CfDisturbance, TransmissionDisturbance = newobservables

    return CfDisturbance, PistonDisturbance, TransmissionDisturbance
    

def get_subarray(pup_used, dsp_all, TelNames, base):
    &#34;&#34;&#34;
    From the visibility matrix of the whole array (dependant on the object)
    returns, the visibility matrix of the array made of the given pupils.

    Parameters
    ----------
    pup_used : string LIST [NA]
        Names of the pupils of the subarray.
    dsp_all : float [NW,NA0**2]
        The visibility matrix of the whole array.
    TelNames : string LIST [NA0]
        Names of the pupils composing the whole array.

    Returns
    -------
    dsp : float [NW,NA**2]
        The visibility matrix of the whole array.
    base : string list [NA**2]
        Base names of the subarray.

    &#34;&#34;&#34;
    
    NA = len(pup_used)
    NA0 = len(TelNames)
    NW = np.shape(dsp_all)[0]
    dsp = np.zeros([NW,NA**2])
    tmp = base
    base=[]
    for ia in range(NA):
        a = TelNames.index(pup_used[ia])
        # dsp[:,ia*(NA+1)] = dsp_all[:,a*(NA0+1)]
        # base.append(tmp[a*(NA0+1)])
        for iap in range(NA):
            k = ia*NA+iap
            ap = TelNames.index(pup_used[iap])
            kp = a*NA0+ap
            dsp[:,k] = dsp_all[:,kp]
            base.append(tmp[kp])
    # import pdb; pdb.set_trace()
   
    return dsp, base, NA
    

def generate_spectra0(lmbda1,lmbda2,R, sampling=&#39;linearsig&#39;):
    &#34;&#34;&#34;
    Generates a spectra of a grism of resolution R linearly spaced on wavenumbers
    or wavelength

    Parameters
    ----------
    lmbda1 : float
        Minimal wavelength.
    lmbda2 : float
        Maximal wavelength.
    R : int
        Spectral resolution.
    sampling : TYPE, optional
        Method of sampling. The default is &#39;linearsig&#39;.
        OPTIONS:
            - &#39;linearsig&#39;: linear in wavenumbers [advised]
            - &#39;linearlambda&#39;: linear in wavelengths

    Returns
    -------
    spectra : ARRAY 1D
        Ascending order.
    sigma : ARRAY 1D
        Descending order.

    &#34;&#34;&#34;
    
    if sampling == &#39;linearsig&#39;:
        sigma1 = 1/lmbda2
        sigma2 = 1/lmbda1
        deltasig = np.min([sigma1,sigma2])/R
        sigma = np.arange(sigma1,sigma2,deltasig)
        sigma = np.sort(sigma)[::-1]
        spectra = 1/sigma
        
    elif sampling == &#39;linearlambda&#39;:
        deltalmbda = np.min([lmbda1,lmbda2])/R
        spectra = np.arange(lmbda1, lmbda2, deltalmbda)
        sigma = 1/spectra
        
    return spectra, sigma


def generate_spectra(lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode=&#39;linear_sig&#39;):
    &#34;&#34;&#34;
    Returns the micro and macro wavenumbers to use for the simulation

    Parameters
    ----------
    sigma : vector [MW]
        Wavenumbers
    OW : int
        Oversampling wavenumbers.
    sigmaband : vector [MW], optional
        Channel bandwidth
    mode : string, optional
        Way of generating the spectras. The default is &#39;regular&#39;.

    Raises
    ------
    ValueError
        Mode needs to be in acceptable values.

    Returns
    -------
    sigma : [MW*OW] floats
        Micro Wavenumbers.
    sigmaM : [MW] floats
        Macro wavenumbers.

    &#34;&#34;&#34;
    possible_modes = [&#39;linear_wl&#39;,&#39;linear_sig&#39;]
    
    if R:
        if MW:
            raise Exception(&#34;MW can&#39;t be given with R.&#34;)
        deltalmbda = np.mean([lmbda1,lmbda2])/R
        MW = int(round((lmbda2-lmbda1)/deltalmbda))
        
    elif not MW:
        raise Exception(&#34;MW or R must be given.&#34;)
    
    if mode == &#39;linear_sig&#39;:
        sig1, sig2 = np.min([1/lmbda1,1/lmbda2]), np.max([1/lmbda1,1/lmbda2])
        sigma = np.linspace(sig1, sig2, MW)
        spectra = np.sort(1/sigma)

        deltasig = sigma[1] - sigma[0]
        # sigmaband = spectraband*spectra**(-2)
        
        sigma_os = np.array([])
        for i in range(MW):
            sigbottom = sigma[i]-deltasig/2
            sigtop = sigma[i]+deltasig/2
            sigma_temp = np.linspace(sigbottom, sigtop, OW)
            sigma_os = np.concatenate((sigma_os,sigma_temp))
        spectra_os = np.sort(1/sigma_os)
        
    elif mode == &#39;linear_wl&#39;:
        spectra_os = np.array([])
        spectra = np.linspace(lmbda1, lmbda2, MW)
        deltalmbda = spectra[1] - spectra[0]
        for i in range(MW):
            wlbottom = spectra[i]-deltalmbda/2
            wltop = spectra[i]+deltalmbda/2
            spectra_temp = np.linspace(wlbottom, wltop, OW)
            spectra_os = np.concatenate((spectra_os,spectra_temp))
    
    else:
        raise ValueError(f&#39;mode={mode}. Unknown mode, needs to be in {possible_modes}.&#39;)
    
    return spectra_os, spectra


def oversample_wv(spectra, OW, spectraband=[], mode=&#39;linear_sig&#39;):

# def oversample_wv(lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode=&#39;linear_sig&#39;):
    &#34;&#34;&#34;
    Returns the micro and macro wavenumbers to use for the simulation

    Parameters
    ----------
    sigma : vector [MW]
        Wavenumbers
    OW : int
        Oversampling wavenumbers.
    sigmaband : vector [MW], optional
        Channel bandwidth
    mode : string, optional
        Way of generating the spectras. The default is &#39;regular&#39;.

    Raises
    ------
    ValueError
        Mode needs to be in acceptable values.

    Returns
    -------
    sigma : [MW*OW] floats
        Micro Wavenumbers.
    sigmaM : [MW] floats
        Macro wavenumbers.

    &#34;&#34;&#34;
    possible_modes = [&#39;linear_wl&#39;,&#39;linear_sig&#39;]
    
    
    MW = len(spectra)
    
    spectra = np.sort(spectra)
    sigma = np.sort(1/spectra)
    
    
    if len(spectraband)==0:
        spectraband = np.zeros_like(spectra)
        sigmaband = np.zeros_like(spectra)
        for i in range(1,MW):
            spectraband[i] = spectra[i] - spectra[i-1]
            sigmaband[i] = sigma[i] - sigma[i-1]
        spectraband[0] = spectraband[1]
        sigmaband[0] = sigmaband[1]
    
    if mode == &#39;linear_sig&#39;:
        sigma = np.sort(1/spectra)
        sigmaband = spectraband*spectra**(-2)
        
        sigma_os = np.array([])
        for i in range(MW):
            sigbottom = sigma[i]-sigmaband[i]/2
            sigtop = sigma[i]+sigmaband[i]/2
            sigma_temp = np.linspace(sigbottom, sigtop, OW)
            sigma_os = np.concatenate((sigma_os,sigma_temp))
        spectra_os = np.sort(1/sigma_os)
        
    elif mode == &#39;linear_wl&#39;:
        spectra_os = np.array([])
        for i in range(MW):
            wlbottom = spectra[i]-spectraband[i]/2
            wltop = spectra[i]+spectraband[i]/2
            spectra_temp = np.linspace(wlbottom, wltop, OW)
            spectra_os = np.concatenate((spectra_os,spectra_temp))
    
    else:
        raise ValueError(f&#39;mode={mode}. Unknown mode, needs to be in {possible_modes}.&#39;)
    
    return spectra_os, spectra



def coh__GRAV2simu(matrix):
    &#34;&#34;&#34;
    Adapt the GRAVITY&#39;s matrix formalism in the simulator one

    Parameters
    ----------
    matrix : TYPE
        DESCRIPTION.

    Returns
    -------
    simuV2PM : TYPE
        DESCRIPTION.
    simuP2VM : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;    
    shape = np.shape(matrix)
    
    if len(shape)==3:    # It&#39;s a V2PM
        (NW,NP,NB) = shape
        simuV2PM = np.zeros([NW,NP,NB])*1j
        simuP2VM = np.zeros([NW,NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            simuV2PM[:,:,ksim] = matrix[:,:,ia]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1

                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)
                Real = matrix[:,:,k]
                k = int(NA*(NA+1)/2 + kp)
                Imag = matrix[:,:,k]
                
                # Direct and Conjugate coherence vectors
                ksim = ia*NA+iap
                simuV2PM[:,:,ksim] = 1/2*(Real + Imag*1j)
                ksim = iap*NA+ia          # 
                simuV2PM[:,:,ksim] = 1/2*(Real - Imag*1j)
        
        for iw in range(NW):
            simuP2VM[iw,:,:] = np.linalg.pinv(simuV2PM[iw,:,:])
        
    else:
        (NP,NB) = shape
        simuV2PM = np.zeros([NP,NB])*1j
        simuP2VM = np.zeros([NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            simuV2PM[:,ksim] = matrix[:,ia]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1

                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)
                Real = matrix[:,k]
                k = int(NA*(NA+1)/2 + kp)
                Imag = matrix[:,k]
                
                # Direct and Conjugate coherence vectors
                ksim = ia*NA+iap
                simuV2PM[:,ksim] = 1/2*(Real + Imag*1j)
                ksim = iap*NA+ia          # 
                simuV2PM[:,ksim] = 1/2*(Real - Imag*1j)
        
        simuP2VM = np.linalg.pinv(simuV2PM)
        
    return simuV2PM, simuP2VM


def simu2GRAV(matrix):
    
    shape = np.shape(matrix)    
    
    if len(shape)==3:    # There&#39;s several wavelengths
        (NW,NP,NB) = shape
        gravV2PM = np.zeros([NW,NP,NB])*1j
        gravP2VM = np.zeros([NW,NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            gravV2PM[:,:,ia] = matrix[:,:,ksim]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1
                
                # Direct and Conjugate coherence vectors
                direct = matrix[:,:,ia*NA+iap]
                conj = matrix[:,:,iap*NA+ia]
                
                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)                    # Real part location
                gravV2PM[:,:,k] = (direct+conj)/2
                k = int(NA*(NA+1)/2 + kp)           # Imaginary part location
                gravV2PM[:,:,k] = (direct-conj)/2/1j
            
        for iw in range(NW):
            gravP2VM[iw,:,:] = np.linalg.pinv(gravV2PM[iw,:,:])
    
    else:        
        (NP,NB) = shape
        gravV2PM = np.zeros([NP,NB])*1j
        gravP2VM = np.zeros([NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            gravV2PM[:,ia] = matrix[:,ksim]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1
                
                # Direct and Conjugate coherence vectors
                direct = matrix[:,ia*NA+iap]
                conj = matrix[:,iap*NA+ia]
                
                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)                    # Real part location
                gravV2PM[:,k] = (direct+conj)/2
                k = int(NA*(NA+1)/2 + kp)           # Imaginary part location
                gravV2PM[:,k] = (direct-conj)/2/1j
        
        gravP2VM = np.linalg.pinv(gravV2PM)
    
    return gravV2PM, gravP2VM


def poskfai(ia,iap,iapp,N):
    &#34;&#34;&#34;
    k-Position of the PhaseClosure for non redundant combination of three pupils
    in a total of N pupils.

    Parameters
    ----------
    ia : TYPE
        DESCRIPTION.
    iap : TYPE
        DESCRIPTION.
    iapp : TYPE
        DESCRIPTION.
    N : Integer
        Number of telescopes.

    Returns
    -------
    Integer
        k-position

    &#34;&#34;&#34;
    
    from scipy.special import binom
    k0 = np.sum(binom(np.arange(N-ia,N),2))
    k1 = posk(iap-ia-1,iapp-iap,N-ia)
    
    return int(k0+k1)


def posk(ia,iap,N):
    &#34;&#34;&#34;
    k-Position of the OPD[ia,iap] for non redundant combination of two pupils in
    a total of N pupils

    Parameters
    ----------
    ia : TYPE
        DESCRIPTION.
    iap : TYPE
        DESCRIPTION.
    iapp : TYPE
        DESCRIPTION.
    N : Integer
        Number of telescopes

    Returns
    -------
    Integer
        k-position on the most logical order: 
            for 6T: 01,02,03,04,05,12,13,14,15,23,24,25,34,35,45

    &#34;&#34;&#34;
    
    return int(ia*N-ia*(ia+3)/2+iap-1)

def NB2NIN(vector):
    &#34;&#34;&#34;
    Returns the entry vector of length NA**2 (which might the expected quantities) 
    on a non-redundant form of length NIN=NA(NA-1)/2 sorted as follow:
        12,..,1NA,23,..,2NA,34,..,3NA,..,(NA-1)(NA)

    Parameters
    ----------
    vector : FLOAT COMPLEX ARRAY [NB]
        Vector of general complex coherences.

    Returns
    -------
    ninvec : FLOAT COMPLEX ARRAY [NIN]
        Complex Vector of non-redundant mutual coherences.
    &#34;&#34;&#34;

    
    NB = len(vector)
    NA = int(np.sqrt(NB))
    NIN = int(NA*(NA-1)/2)
    
    ninvec = np.zeros([NIN])*1j
    for ia in range(NA):
        for iap in range(ia+1,NA):
            k = posk(ia,iap,NA)
            ninvec[k] = vector[ia*NA+iap]
    
    return ninvec


import matplotlib.pyplot as plt
from .config import Observation, ScienceObject

if __name__ == &#39;__main__&#39;:
    
    plt.close(&#39;all&#39;)
    sigma1 = 1/1.5
    sigma2 = 1/1.75
    
    MW = 5
    OW = 10
    sigmaM = np.linspace(sigma1,sigma2,MW)
    sigma = oversample_wv(sigmaM, OW)
    spectra = 1/sigma
    
    # Star and Array characteristics
    star = &#39;Deneb&#39;
    ARRAY = &#39;chara&#39;
    angular_diameter_mas = 0.38
    mas2rad = 1e-3 /3600 * np.pi/180        # Conversion from mas to radian
    diam_ang = angular_diameter_mas*mas2rad # angular diameter of Deneb [radian]
    T = 8700                                # Temperature of the star
    M_H = 0.87                              # Magnitude of the star in H-band
    diameter = 1                            # Diameter of a telescope
    surface = np.pi*diameter**2/4           # Collecting surface of the telescope
                                            # (without occultation) 
    angle = np.pi/2                         # Altitude of the star
    
    starfile=&#39;FlatUnresolved.fits&#39;
    savingname= &#39;new1.fits&#39;
    
    Obs = Observation(ArrayName=&#39;CHARA&#39;,AltAz=(90,0))
    
    Target = ScienceObject(&#39;Simple&#39;)
    Target.Star1 = {&#39;Position&#39;:(0,0),&#39;AngDiameter&#39;:0.5,&#39;Hmag&#39;:0}
    Target.Star2 = {&#39;Position&#39;:(0,1),&#39;AngDiameter&#39;:0.1,&#39;Hmag&#39;:0}
    
    # spectrum = phot * visibility on each baseline per second
    CohIrr, UncohIrr, VisObj, base, TelNames = create_star(spectra, Obs, Target, savingname=savingname,display=True) 
    NA = len(TelNames)
    
    
    # transmission = info_array(&#39;chara&#39;,&#39;H&#39;)  # Transmission factor of CHARA
    # dt = 0.001                                      # Frame time: 1ms
    # spectrum = spectrum * transmission * dt
    
    # plt.close(&#39;all&#39;)
    # plt.figure(config.newfig), plt.title(&#39;Visibility of the star on different baselines&#39;)
    # plt.plot(spectra, visibility[:,0], label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[0]+TelNames[0],base[0]))  
    # for ia in range(NA):
    #     for iap in range(ia+1,NA):
    #         k = ia*NA+iap
    #         plt.plot(spectra, visibility[:,k], label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[ia]+TelNames[iap],base[k]))  
    # plt.xlabel(&#39;Wavelengths [µm]&#39;)
    # plt.ylabel(&#39;Visibility&#39;)
    # plt.legend()
    # plt.show()
    # config.newfig+=1
    
    # plt.figure(config.newfig), plt.title(f&#39;Photometry of {star}&#39;)
    # plt.plot(spectra, phot)  
    # plt.xlabel(&#39;Wavelengths [µm]&#39;)
    # plt.ylabel(&#39;Photons number&#39;)
    # plt.show()
    # config.newfig+=1
    
    # plt.figure(config.newfig), plt.title(&#39;Photometry/ms of the star taking into account visibilities and transmission losses &#39;)
    # plt.plot(spectra, spectrum[:,0], label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[0]+TelNames[0],base[0]))  
    # for ia in range(NA):
    #     for iap in range(ia+1,NA):
    #         k = ia*NA+iap
    #         plt.plot(spectra, spectrum[:,k], label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[ia]+TelNames[iap],base[k]))  
    # plt.xlabel(&#39;Wavelengths [µm]&#39;)
    # plt.ylabel(&#39;Visibility&#39;)
    # plt.legend()
    # plt.show()
    # config.newfig+=1
    
    # from coh_lib import coh_fs_abcdphot
    # from coh_fs_spica import true
    # import coh_lib
    
    # directory = &#39;C:/Users/cpannetier/Documents/These/FringeTracking/SPICA-FT/V2PM_SPICA/&#39;
    # filename = &#39;MIRCX_ABCD_H_PRISM22_V2PM.fits&#39;
    # fitsfile = directory+filename
    
    # MW = 5

    # # sigmaM = np.linspace(sigma1, sigma2, MW)
    # # sigma = ct.oversample_wv(sigmaM, OW)
    
    # lmbda1 = 1.3
    # lmbda2 = 1.75
    # R = 22
    # spectra = generatespectra(lmbda1, lmbda2, 10*R, MW=5)

    # v2pm = true(fitsfile,spectra)[0]
    
    # print(&#39;\n&#39;,v2pm)
    # coher = np.ones(4)
    # gravV2PM,gravP2VM = simu2GRAV(v2pm)
    
    # print(&#39;\n&#39;,gravV2PM)
    
    
    # simuV2PM,simup2vm = coh__GRAV2simu(gravV2PM)
    # print(&#39;\n&#39;,simuV2PM)
    
    
    
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="coh_lib.coh_tools.BBstar"><code class="name flex">
<span>def <span class="ident">BBstar</span></span>(<span>wav, T)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the spectral luminance of a black-body given its temperature.
Will be useful to give the shape of the spectra of a star.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wav</code></strong> :&ensp;<code>[NW] float [meter]</code></dt>
<dd>Wavelength in meter.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float [K]</code></dt>
<dd>Temperature of the Black-Body in Kelvin.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>luminance</code></strong> :&ensp;<code>[NW] floats [W/s/m²/sr]</code></dt>
<dd>Luminance of the source per steradian.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BBstar(wav, T):
    &#34;&#34;&#34;
    Returns the spectral luminance of a black-body given its temperature.
    Will be useful to give the shape of the spectra of a star.

    Parameters
    ----------
    wav : [NW] float [meter]
        Wavelength in meter.
    T : float [K]
        Temperature of the Black-Body in Kelvin.

    Returns
    -------
    luminance : [NW] floats [W/s/m²/sr]
        Luminance of the source per steradian.

    &#34;&#34;&#34;
    global h_, c_, k_
    
    a = 2.0*h_*c_**2
    b = h_*c_/(wav*k_*T)
    luminance = a / ( (wav**5) * (np.exp(b) - 1.0) ) # W/m²/sr/µm
    
    # nu = c_/spectra   # Electromagnetic frequency [Hz]
    # a = 2.*h_/c_**2
    # b = h_/k_/T
    # B_sig = a*nu**3/(np.exp(b*nu)-1)  # W/m²/sr/s
    
    return luminance</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.NB2NIN"><code class="name flex">
<span>def <span class="ident">NB2NIN</span></span>(<span>vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the entry vector of length NA**2 (which might the expected quantities)
on a non-redundant form of length NIN=NA(NA-1)/2 sorted as follow:
12,..,1NA,23,..,2NA,34,..,3NA,..,(NA-1)(NA)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>FLOAT COMPLEX ARRAY [NB]</code></dt>
<dd>Vector of general complex coherences.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ninvec</code></strong> :&ensp;<code>FLOAT COMPLEX ARRAY [NIN]</code></dt>
<dd>Complex Vector of non-redundant mutual coherences.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NB2NIN(vector):
    &#34;&#34;&#34;
    Returns the entry vector of length NA**2 (which might the expected quantities) 
    on a non-redundant form of length NIN=NA(NA-1)/2 sorted as follow:
        12,..,1NA,23,..,2NA,34,..,3NA,..,(NA-1)(NA)

    Parameters
    ----------
    vector : FLOAT COMPLEX ARRAY [NB]
        Vector of general complex coherences.

    Returns
    -------
    ninvec : FLOAT COMPLEX ARRAY [NIN]
        Complex Vector of non-redundant mutual coherences.
    &#34;&#34;&#34;

    
    NB = len(vector)
    NA = int(np.sqrt(NB))
    NIN = int(NA*(NA-1)/2)
    
    ninvec = np.zeros([NIN])*1j
    for ia in range(NA):
        for iap in range(ia+1,NA):
            k = posk(ia,iap,NA)
            ninvec[k] = vector[ia*NA+iap]
    
    return ninvec</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.coh__GRAV2simu"><code class="name flex">
<span>def <span class="ident">coh__GRAV2simu</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Adapt the GRAVITY's matrix formalism in the simulator one</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>simuV2PM</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>simuP2VM</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coh__GRAV2simu(matrix):
    &#34;&#34;&#34;
    Adapt the GRAVITY&#39;s matrix formalism in the simulator one

    Parameters
    ----------
    matrix : TYPE
        DESCRIPTION.

    Returns
    -------
    simuV2PM : TYPE
        DESCRIPTION.
    simuP2VM : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;    
    shape = np.shape(matrix)
    
    if len(shape)==3:    # It&#39;s a V2PM
        (NW,NP,NB) = shape
        simuV2PM = np.zeros([NW,NP,NB])*1j
        simuP2VM = np.zeros([NW,NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            simuV2PM[:,:,ksim] = matrix[:,:,ia]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1

                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)
                Real = matrix[:,:,k]
                k = int(NA*(NA+1)/2 + kp)
                Imag = matrix[:,:,k]
                
                # Direct and Conjugate coherence vectors
                ksim = ia*NA+iap
                simuV2PM[:,:,ksim] = 1/2*(Real + Imag*1j)
                ksim = iap*NA+ia          # 
                simuV2PM[:,:,ksim] = 1/2*(Real - Imag*1j)
        
        for iw in range(NW):
            simuP2VM[iw,:,:] = np.linalg.pinv(simuV2PM[iw,:,:])
        
    else:
        (NP,NB) = shape
        simuV2PM = np.zeros([NP,NB])*1j
        simuP2VM = np.zeros([NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            simuV2PM[:,ksim] = matrix[:,ia]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1

                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)
                Real = matrix[:,k]
                k = int(NA*(NA+1)/2 + kp)
                Imag = matrix[:,k]
                
                # Direct and Conjugate coherence vectors
                ksim = ia*NA+iap
                simuV2PM[:,ksim] = 1/2*(Real + Imag*1j)
                ksim = iap*NA+ia          # 
                simuV2PM[:,ksim] = 1/2*(Real - Imag*1j)
        
        simuP2VM = np.linalg.pinv(simuV2PM)
        
    return simuV2PM, simuP2VM</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.create_obsfile"><code class="name flex">
<span>def <span class="ident">create_obsfile</span></span>(<span>spectra, Obs, Target, savingfilepath='', overwrite=False, display=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the absolute spectral photometry of a star given physical properties
(BlackBody approx), its angular diameter and the array parameter. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spectra</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>magH</code></strong> :&ensp;<code>FLOAT</code></dt>
<dd>Star's magnitude in H-band.</dd>
<dt><strong><code>array</code></strong> :&ensp;<code>STRING</code></dt>
<dd>Name of the array among ['chara'].</dd>
<dt><strong><code>angdiameters</code></strong> :&ensp;<code>FLOAT OR TUPLE</code></dt>
<dd>Angular diameter of the object.
If one star, expects float. If two stars, expects tuple.</dd>
<dt><strong><code>surface</code></strong> :&ensp;<code>FLOAT</code></dt>
<dd>Collecting surface of the telescope.
Necessary for photometry.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>FLOAT</code></dt>
<dd>Star's angular distance to horizon in radian. (elevation)
Necessary for CHARA's projection on (u,v) plane.</dd>
<dt><strong><code>starfile</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>savingname</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is ''.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is False.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>spectrum</code></strong> :&ensp;<code>FLOAT ARRAY [NW,NB]</code></dt>
<dd>Spectral photon distribution including visibility and star photometry
on all baselines. [ph/s]</dd>
<dt><strong><code>phot</code></strong> :&ensp;<code>[NW]</code></dt>
<dd>Spectral photon distribution [pht/s/telescope/µm] of the star without visibility.</dd>
<dt><strong><code>VisObj</code></strong> :&ensp;<code>COMPLEX ARRAY [NW,NB]</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>CPObj</code></strong> :&ensp;<code>FLOAT ARRAY [NW,NC]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>BaseNorms</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>TelNames</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_obsfile(spectra, Obs, Target, savingfilepath=&#39;&#39;, overwrite=False, display=False):
    &#34;&#34;&#34;
    Returns the absolute spectral photometry of a star given physical properties 
    (BlackBody approx), its angular diameter and the array parameter. 

    Parameters
    ----------
    spectra : TYPE
        DESCRIPTION.
    magH : FLOAT
        Star&#39;s magnitude in H-band.
    array : STRING
        Name of the array among [&#39;chara&#39;].
    angdiameters : FLOAT OR TUPLE
        Angular diameter of the object. 
        If one star, expects float. If two stars, expects tuple.
    surface : FLOAT
        Collecting surface of the telescope. 
        Necessary for photometry.
    angle : FLOAT
        Star&#39;s angular distance to horizon in radian. (elevation)
        Necessary for CHARA&#39;s projection on (u,v) plane.
    starfile : TYPE
        DESCRIPTION.
    savingname : TYPE, optional
        DESCRIPTION. The default is &#39;&#39;.
    display : TYPE, optional
        DESCRIPTION. The default is False.
    **kwargs : TYPE
        DESCRIPTION.

    Returns
    -------
    spectrum : FLOAT ARRAY [NW,NB]
        Spectral photon distribution including visibility and star photometry
        on all baselines. [ph/s]
    phot : [NW]
        Spectral photon distribution [pht/s/telescope/µm] of the star without visibility.
    VisObj : COMPLEX ARRAY [NW,NB]
        DESCRIPTION.
    CPObj : FLOAT ARRAY [NW,NC]
    
    BaseNorms : TYPE
        DESCRIPTION.
    TelNames : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;

    fileexists = os.path.exists(savingfilepath)
    if fileexists:
        print(f&#39;{savingfilepath} already exists.&#39;)
        if overwrite:
            os.remove(savingfilepath)
        else:
            raise Exception(&#34;You didn&#39;t ask to overwrite it.&#34;)          

    # spectra = 1/sigma     # [µm] Wavelengths
    NW = len(spectra)     # [int] Wavelengths number
    
    # First case: Temperature of the first star is given
    # We compute a BlackBody model
    if &#39;T&#39; in Target.Star1.keys():    
        T=Target.Star1[&#39;T&#39;]
        Irradiance = BBstar(spectra*1e-6, T)       # Create BB star model in wavelengths    
        Irradiance = Irradiance[::-1]             # (Reverse) the spectra according to sigmas
        norm = np.mean(Irradiance[(spectra&gt;=1.4)*(spectra&lt;=1.75)])    # Normalization of the flux on the whole H band
        Irradiance/=norm

    else:
        Irradiance=np.ones_like(spectra)
        
    magH = Target.Star1[&#39;Hmag&#39;]
    # Luminance according to apparent magnitude    
    
    L0_ph = 93.3e8        # Photons.m-2.s-1.µm-1 at 1.63µm
    
    Lph_H = L0_ph*10**(-0.4*magH)
    
    # delta_wav = np.abs(spectra[0] - spectra[1])     # Width of a spectral channel
    
    # Preference for photons directly to keep a uniform spectra
    UncohIrradiance = Irradiance*Lph_H             # [phot/s/m²/deltalmbda] Source Irradiance 
    
    # Using Watt as reference and converting in photons: drawback=non uniform spectra
    # L0_w = 7 * 10**(-10)                      # [W/m²/µm] Reference luminance at 1.65µm (Lena)
    # L0_w = 11.38 * 10**(-10)                  # [W/m²/µm] Reference luminance at 1.63µm (Bessel)
    # Lw_H = L0_w*10**(-0.4*magH)                        # Definition of the magnitude
    # UncohIrradiance_w = luminance*Lw_H*delta_wav / (h_*c_/spectra*1e6)          # [phot/s/m²/deltalmbda]


    filepath = Obs.Filepath
    if not os.path.exists(filepath):
        raise Exception(f&#34;{filepath} doesn&#39;t exist.&#34;)
    
    with fits.open(filepath) as hdu:
        ArrayParams = hdu[0].header
        NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
        ArrayName = ArrayParams[&#39;NAME&#39;]
        TelData = hdu[1].data
        BaseData = hdu[2].data
        
        TelNames = TelData[&#39;TelNames&#39;]
        TelCoordinates = TelData[&#39;TelCoordinates&#39;]
        TelTransmissions = TelData[&#39;TelTransmissions&#39;]
        TelSurfaces = TelData[&#39;TelSurfaces&#39;]
        BaseNames = BaseData[&#39;BaseNames&#39;]
        BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
        
    NB = NA**2
    NC = (NA-2)*(NA-1)
    
    # Transportation of the star light into the interferometer
    Throughput = np.reshape(TelSurfaces*TelTransmissions,[1,NA])
    ThroughputMatrix = np.sqrt(np.dot(np.transpose(Throughput), Throughput))
    ThroughputMatrix = ThroughputMatrix.reshape([1,NB])
    # Matrix where the element at the (ia*NA+iap) position is Ta*Tap
    # UncohIrradianceAfterTelescopes = np.dot(np.diag(TelTransmissions),np.transpose(UncohIrradiance))
        
    BaseNorms = np.linalg.norm(BaseCoordinates, axis=1)
    
    # Projection of the base on the (u,v) plane
    BaseNorms = get_Bproj(np.array(BaseNorms), Obs.AltAz[0])
    
    VisObj = np.zeros([NW,NB])*1j       # Object Visibility [normalised]
    CohIrradiance = np.zeros([NW,NB])*1j        # Source coherent Irradiance [phot/s/m²/deltalmbda]    
      
    # UncohIrradianceAfterTelescopes = UncohIrradiance*TelTransmissions*TelSurfaces
    

    if Target.Name == &#39;Unresolved&#39;:
        VisObj = np.ones([NW,NB])
        CPObj = np.zeros([NW,NC])
        
    elif Target.Name == &#39;Manual&#39;:
        phi = np.zeros([NW,NB])
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                phi[:,ia*NA+iap] = Target.Phases[ib]
                phi[:,iap*NA+ia] = -Target.Phases[ib]
        VisObj = np.exp(1j*phi)
        # VisObj = np.repeat(VisObj[np.newaxis,:],NW,axis=0)
        
        bispectrum = np.zeros([NW,NC])*1j
        for ia in range(NA):
            for iap in range(ia+1,NA):
                for iapp in range(iap+1,NA):
                    ci1 = VisObj[:,ia*NA+iap]
                    ci2 = VisObj[:,iap*NA+iapp]
                    ci3 = VisObj[:,iapp*NA+ia]
                    ic = poskfai(ia,iap,iapp,NA)
                    bispectrum[:,ic] = ci1*ci2*ci3
        CPObj = np.angle(bispectrum)
        
    else:           # Van-Cittert theorem visibility
        visibilities = VanCittert(spectra, Obs, Target,display=display)
        
        
        bispectrum = np.zeros([NW,NC])*1j
        
        for ia in range(NA):
            VisObj[:,ia*(NA+1)] = np.ones(NW)
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                VisObj[:,ia*NA+iap] = visibilities[:,ib]
                VisObj[:,iap*NA+ia] = np.conj(visibilities[:,ib])
                for iapp in range(iap+1,NA):
                    cs1 = VisObj[:,ia*NA+iap]     # Coherent flux (ia,iap) 
                    cs2 = VisObj[:,iap*NA+iapp]  # Coherent flux (iap,iapp) 
                    cs3 = VisObj[:,iapp*NA+ia] # Coherent flux (iapp,ia) 
                    ic = poskfai(ia,iap,iapp,NA) 
                    bispectrum[:,ic]+=cs1*cs2*cs3
                    
        CPObj = np.angle(bispectrum)
        
    for iw in range(NW):    
        CohIrradiance[iw] = UncohIrradiance[iw] * ThroughputMatrix * VisObj[iw]
            
    # hdr = ArrayParams
    hdr = fits.Header()
    
    hdr[&#39;Filepath&#39;] = savingfilepath.split(&#39;/&#39;)[-1]
    hdr[&#39;ARRAY&#39;] = Obs.ArrayName
    hdr[&#39;Target&#39;] = Target.Name
    hdr[&#39;NA&#39;] = NA
    hdr[&#39;NIN&#39;] = NIN
    hdr[&#39;MINWAVE&#39;] = spectra[0]
    hdr[&#39;MAXWAVE&#39;] = spectra[-1]
    hdr[&#39;DWAVE&#39;] = spectra[1] - spectra[0]

    for attr in vars(Target).keys():
        if type(getattr(Target, attr)) is not dict:            
            if attr not in [&#39;Name&#39;,&#39;Filepath&#39;, &#39;Phases&#39;]:
                hdr[attr] = getattr(Target, attr)
        else:
            for key in getattr(Target, attr).keys():
                if key == &#39;Position&#39;:
                    hdr[f&#34;{attr}_alpha&#34;] = getattr(Target, attr)[key][0]
                    hdr[f&#34;{attr}_beta&#34;] = getattr(Target, attr)[key][1]
                else:
                    hdr[f&#34;{attr}_{key}&#34;] = getattr(Target, attr)[key]
                
    for attr in vars(Obs).keys():
        if isinstance(getattr(Obs, attr),
                      (str, int, float, complex, bool,
                       np.floating, np.integer, np.complexfloating,
                       np.bool_)):
            
            if attr != &#39;Filepath&#39;:
                if attr != ArrayName:
                    hdr[attr] = getattr(Obs, attr)
            else:
                hdr[&#39;ArrayFile&#39;] = getattr(Obs, attr).split(&#39;/&#39;)[-1]
        
    
    primary = fits.PrimaryHDU(header=hdr)
    
    im1 = fits.ImageHDU(np.real(VisObj), name=&#39;VReal&#39;)
    im2 = fits.ImageHDU(np.imag(VisObj), name=&#39;VImag&#39;)
    im3 = fits.ImageHDU(np.real(CohIrradiance), name=&#39;CfReal&#39;)
    im4 = fits.ImageHDU(np.imag(CohIrradiance), name=&#39;CfImag&#39;)
    im5 = fits.ImageHDU(CPObj, name=&#39;Closure Phase&#39;)
    
    col1 = fits.Column(name=&#39;WLsampling&#39;, format=&#39;1D&#39;, array=spectra)
    hdu1 = fits.BinTableHDU.from_columns([col1], name=&#39;spectra&#39; )
    
    hdu = fits.HDUList([primary,hdu1,im1,im2,im3,im4,im5])
    
    print(f&#39;Saving file into {savingfilepath}&#39;)
    hdu.writeto(savingfilepath)


    if display:
        plt.figure(config.newfig), plt.title(&#39;Absolute Visibility of the star on different baselines&#39;)
        plt.plot(spectra, np.abs(VisObj[:,0]), label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[0]+TelNames[0],BaseNorms[0]))  
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                plt.plot(spectra, np.abs(VisObj[:,k]), label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[ia]+TelNames[iap],BaseNorms[k]))  
        plt.xlabel(&#39;Wavelengths [µm]&#39;)
        plt.ylabel(&#39;Coherence Degree Module&#39;)
        plt.legend()
        plt.grid()
        plt.show()
        config.newfig+=1
        
        plt.figure(config.newfig), plt.title(&#39;Phase Visibility of the star on different baselines&#39;)
        plt.plot(spectra, np.angle(VisObj[:,0]), label=&#39;{0:}&#39;.format(&#39;Uncoherent flux&#39;))  
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                plt.plot(spectra, np.angle(VisObj[:,k]), label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[ia]+TelNames[iap],BaseNorms[k]))  
        plt.xlabel(&#39;Wavelengths [µm]&#39;)
        plt.ylabel(&#39;Coherence Degree Phase [rad]&#39;)
        plt.ylim([-1.1*np.pi,1.1*np.pi])
        plt.legend()
        plt.grid()
        plt.show()
        config.newfig += 1
    
        plt.figure(config.newfig), plt.title(f&#39;Irradiance of the star&#39;)
        plt.plot(spectra, UncohIrradiance)  
        plt.xlabel(&#39;Wavelengths [µm]&#39;)
        plt.ylabel(&#39;Irradiance [photons/s/m²/µm]&#39;)
        plt.grid()
        plt.show()
        config.newfig += 1
        
        
        plt.figure(config.newfig), plt.title(&#39;Coherent Irradiance of the star&#39;)
        plt.plot(spectra, np.abs(VisObj[:,0])*UncohIrradiance, label=&#39;{0:}&#39;.format(&#39;Uncoherent flux&#39;))  
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                plt.plot(spectra, np.abs(VisObj[:,k])*UncohIrradiance, label=&#39;{0:}:{1:.1f}m&#39;.format(TelNames[ia]+TelNames[iap],BaseNorms[k]))  
        plt.xlabel(&#39;Wavelengths [µm]&#39;)
        plt.ylabel(&#39;Irradiance [photons/s/m²/µm]&#39;)
        plt.legend()
        plt.grid()
        plt.show()
        config.newfig += 1
    
    return CohIrradiance, UncohIrradiance, VisObj, BaseNorms, TelNames</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.generate_spectra"><code class="name flex">
<span>def <span class="ident">generate_spectra</span></span>(<span>lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode='linear_sig')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the micro and macro wavenumbers to use for the simulation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>vector [MW]</code></dt>
<dd>Wavenumbers</dd>
<dt><strong><code>OW</code></strong> :&ensp;<code>int</code></dt>
<dd>Oversampling wavenumbers.</dd>
<dt><strong><code>sigmaband</code></strong> :&ensp;<code>vector [MW]</code>, optional</dt>
<dd>Channel bandwidth</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Way of generating the spectras. The default is 'regular'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Mode needs to be in acceptable values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>[MW*OW] floats</code></dt>
<dd>Micro Wavenumbers.</dd>
<dt><strong><code>sigmaM</code></strong> :&ensp;<code>[MW] floats</code></dt>
<dd>Macro wavenumbers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_spectra(lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode=&#39;linear_sig&#39;):
    &#34;&#34;&#34;
    Returns the micro and macro wavenumbers to use for the simulation

    Parameters
    ----------
    sigma : vector [MW]
        Wavenumbers
    OW : int
        Oversampling wavenumbers.
    sigmaband : vector [MW], optional
        Channel bandwidth
    mode : string, optional
        Way of generating the spectras. The default is &#39;regular&#39;.

    Raises
    ------
    ValueError
        Mode needs to be in acceptable values.

    Returns
    -------
    sigma : [MW*OW] floats
        Micro Wavenumbers.
    sigmaM : [MW] floats
        Macro wavenumbers.

    &#34;&#34;&#34;
    possible_modes = [&#39;linear_wl&#39;,&#39;linear_sig&#39;]
    
    if R:
        if MW:
            raise Exception(&#34;MW can&#39;t be given with R.&#34;)
        deltalmbda = np.mean([lmbda1,lmbda2])/R
        MW = int(round((lmbda2-lmbda1)/deltalmbda))
        
    elif not MW:
        raise Exception(&#34;MW or R must be given.&#34;)
    
    if mode == &#39;linear_sig&#39;:
        sig1, sig2 = np.min([1/lmbda1,1/lmbda2]), np.max([1/lmbda1,1/lmbda2])
        sigma = np.linspace(sig1, sig2, MW)
        spectra = np.sort(1/sigma)

        deltasig = sigma[1] - sigma[0]
        # sigmaband = spectraband*spectra**(-2)
        
        sigma_os = np.array([])
        for i in range(MW):
            sigbottom = sigma[i]-deltasig/2
            sigtop = sigma[i]+deltasig/2
            sigma_temp = np.linspace(sigbottom, sigtop, OW)
            sigma_os = np.concatenate((sigma_os,sigma_temp))
        spectra_os = np.sort(1/sigma_os)
        
    elif mode == &#39;linear_wl&#39;:
        spectra_os = np.array([])
        spectra = np.linspace(lmbda1, lmbda2, MW)
        deltalmbda = spectra[1] - spectra[0]
        for i in range(MW):
            wlbottom = spectra[i]-deltalmbda/2
            wltop = spectra[i]+deltalmbda/2
            spectra_temp = np.linspace(wlbottom, wltop, OW)
            spectra_os = np.concatenate((spectra_os,spectra_temp))
    
    else:
        raise ValueError(f&#39;mode={mode}. Unknown mode, needs to be in {possible_modes}.&#39;)
    
    return spectra_os, spectra</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.generate_spectra0"><code class="name flex">
<span>def <span class="ident">generate_spectra0</span></span>(<span>lmbda1, lmbda2, R, sampling='linearsig')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a spectra of a grism of resolution R linearly spaced on wavenumbers
or wavelength</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lmbda1</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimal wavelength.</dd>
<dt><strong><code>lmbda2</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximal wavelength.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>int</code></dt>
<dd>Spectral resolution.</dd>
<dt><strong><code>sampling</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>Method of sampling. The default is 'linearsig'.
OPTIONS:
- 'linearsig': linear in wavenumbers [advised]
- 'linearlambda': linear in wavelengths</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>spectra</code></strong> :&ensp;<code>ARRAY 1D</code></dt>
<dd>Ascending order.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>ARRAY 1D</code></dt>
<dd>Descending order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_spectra0(lmbda1,lmbda2,R, sampling=&#39;linearsig&#39;):
    &#34;&#34;&#34;
    Generates a spectra of a grism of resolution R linearly spaced on wavenumbers
    or wavelength

    Parameters
    ----------
    lmbda1 : float
        Minimal wavelength.
    lmbda2 : float
        Maximal wavelength.
    R : int
        Spectral resolution.
    sampling : TYPE, optional
        Method of sampling. The default is &#39;linearsig&#39;.
        OPTIONS:
            - &#39;linearsig&#39;: linear in wavenumbers [advised]
            - &#39;linearlambda&#39;: linear in wavelengths

    Returns
    -------
    spectra : ARRAY 1D
        Ascending order.
    sigma : ARRAY 1D
        Descending order.

    &#34;&#34;&#34;
    
    if sampling == &#39;linearsig&#39;:
        sigma1 = 1/lmbda2
        sigma2 = 1/lmbda1
        deltasig = np.min([sigma1,sigma2])/R
        sigma = np.arange(sigma1,sigma2,deltasig)
        sigma = np.sort(sigma)[::-1]
        spectra = 1/sigma
        
    elif sampling == &#39;linearlambda&#39;:
        deltalmbda = np.min([lmbda1,lmbda2])/R
        spectra = np.arange(lmbda1, lmbda2, deltalmbda)
        sigma = 1/spectra
        
    return spectra, sigma</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.get_Bproj"><code class="name flex">
<span>def <span class="ident">get_Bproj</span></span>(<span>baseline, theta)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates projected bases acording to the viewed angle in radian</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>baseline</code></strong> :&ensp;<code>float [meter]</code></dt>
<dd>Distance between telescopes in meters.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float [radian]</code></dt>
<dd>Angle viewed by the base (depend on declination and azimuth).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Bproj</code></strong> :&ensp;<code>float [meter]</code></dt>
<dd>Projected base.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_Bproj(baseline, theta):
    &#34;&#34;&#34;
    Calculates projected bases acording to the viewed angle in radian

    Parameters
    ----------
    baseline : float [meter]
        Distance between telescopes in meters.
    theta : float [radian]
        Angle viewed by the base (depend on declination and azimuth).
        
    Returns
    -------
    Bproj : float [meter]
        Projected base.

    &#34;&#34;&#34;
    
    Bproj = baseline * np.sin(theta)
    return Bproj</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.get_CfDisturbance"><code class="name flex">
<span>def <span class="ident">get_CfDisturbance</span></span>(<span>DisturbanceFile, spectra, timestamps)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_CfDisturbance(DisturbanceFile, spectra, timestamps):
    from . import simu
    
    with fits.open(DisturbanceFile) as hdu:
        RealCf = hdu[&#39;RealCf&#39;].data
        ImagCf = hdu[&#39;ImagCf&#39;].data
        FileCoherentFlux = RealCf + 1j*ImagCf
        CfDisturbance = FileCoherentFlux
        
        PistonDisturbance = hdu[&#39;Piston&#39;].data
        TransmissionDisturbance = hdu[&#39;Transmission&#39;].data
        
        filetimestamps = hdu[&#39;TimeSampling&#39;].data[&#39;timestamps&#39;]
        filespectra = hdu[&#39;SpectralSampling&#39;].data[&#39;spectra&#39;]
        
        try:
            simu.DisturbancePSD = hdu[&#39;Last tel PSD&#39;].data
            simu.FreqSampling = hdu[&#39;Frequency sampling&#39;].data
            simu.DisturbanceFilter = hdu[&#39;Disturbance Filter&#39;].data
            print(&#39;Disturbance PSD present in FITSfile.&#39;)
        except:
            print(&#39;No Disturbance PSD in FITSfile.&#39;)
            
    # Interpolate on the time axis   
    newobservables = []
    for observable in [CfDisturbance, PistonDisturbance, TransmissionDisturbance]:
        f = interpolate.interp1d(filetimestamps,observable, axis=0)
        newobservables.append(f(timestamps))
        
    
    TempCfDisturbance, PistonDisturbance, TempTransmissionDisturbance = newobservables
    
    # Interpolate on the spectral axis (Piston is not chromatic)
    newobservables = []
    for observable in [TempCfDisturbance, TempTransmissionDisturbance]:
        f = interpolate.interp1d(filespectra,observable, axis=1)
        newobservables.append(f(spectra))
    
    CfDisturbance, TransmissionDisturbance = newobservables

    return CfDisturbance, PistonDisturbance, TransmissionDisturbance</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.get_CfObj"><code class="name flex">
<span>def <span class="ident">get_CfObj</span></span>(<span>filepath, spectra)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads data of an observation contained in a FITSfile.
Adapt the spectral sampling to the FS spectral sampling.
Return it</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>CohIrradiance</code></strong> :&ensp;<code>ARRAY[NW,NB]</code></dt>
<dd>Coherence Flux of the object in photons/s.</dd>
<dt><strong><code>ClosurePhase</code></strong> :&ensp;<code>ARRAY[NW,NC]</code></dt>
<dd>Closure Phases of the object in radian.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_CfObj(filepath, spectra):
    &#34;&#34;&#34;
    Reads data of an observation contained in a FITSfile.
    Adapt the spectral sampling to the FS spectral sampling.
    Return it

    Parameters
    ----------
    filepath : TYPE
        DESCRIPTION.
    spectra : TYPE
        DESCRIPTION.

    Returns
    -------
    CohIrradiance : ARRAY[NW,NB]
        Coherence Flux of the object in photons/s.
    ClosurePhase : ARRAY[NW,NC]
        Closure Phases of the object in radian.

    &#34;&#34;&#34;

    fileexists = os.path.exists(filepath)
    if not fileexists:
        raise Exception(f&#34;{filepath} doesn&#39;t exists.&#34;)          
    with fits.open(filepath) as hdu:

        ObsParams = hdu[0].header
        WLsampling = hdu[&#39;SPECTRA&#39;].data[&#39;WLsampling&#39;]
        
        real = hdu[&#39;VReal&#39;].data
        imag = hdu[&#39;VImag&#39;].data

        ComplexVisObj = real + imag*1j
        
        real = hdu[&#39;CfReal&#39;].data
        imag = hdu[&#39;CfImag&#39;].data

        CoherentIrradiance = real + imag*1j
        NW, NB = CoherentIrradiance.shape
        NA = int(np.sqrt(NB))
        NC = (NA-2)*(NA-1)
        ClosurePhase = np.zeros([NW,NC])
        for ia in range(NA):
            for iap in range(ia+1,NA):
                for iapp in range(iap+1,NA):
                    ic = poskfai(ia,iap,iapp,NA)
                    ci1 = CoherentIrradiance[:,ia*NA+iap]
                    ci2 = CoherentIrradiance[:,iap*NA+iapp]
                    ci3 = CoherentIrradiance[:,iapp*NA+ia]
                    ClosurePhase[:,ic] = np.angle(ci1*ci2*ci3)
        # ClosurePhase = hdu[&#39;Closure Phase&#39;].data
        
        f = interpolate.interp1d(WLsampling, CoherentIrradiance, axis=0)
        
        CoherentIrradiance = f(spectra)
        
    return CoherentIrradiance, ClosurePhase</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.get_array"><code class="name flex">
<span>def <span class="ident">get_array</span></span>(<span>name, getcoords=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the coordinates, baselines and base names of a given array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>STRING</code></dt>
<dd>Name of the array.</dd>
<dt><strong><code>getcoords</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If True, add the array coordinates to the output.
The default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NameError</code></dt>
<dd>Name must be 'CHARA'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>TelNames</code></strong> :&ensp;<code>[NA] list strings</code></dt>
<dd>Names of the telescopes</dd>
<dt><strong><code>BaseNames</code></strong> :&ensp;<code>[NB] strings</code></dt>
<dd>Name of each baseline.</dd>
<dt><strong><code>BaseNorms</code></strong> :&ensp;<code>[NB] floats [meter]</code></dt>
<dd>Baselines.</dd>
<dt><strong><code>coords</code></strong>, <strong><code>OPTIONAL</code></strong> :&ensp;<code>[NA,3] FLOAT ARRAY [meter]</code></dt>
<dd>Coordinates of the array, following the format:
(XOFFSET,YOFFSET,ZOFFSET) where:
XOFFSET - East offset in microns from S1
YOFFSET - North offset in microns from S1
ZOFFSET - vertical (+ is up) offset in microns from S1,,)
Take S1 as reference.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_array(name,getcoords=False):
    &#34;&#34;&#34;
    Returns the coordinates, baselines and base names of a given array

    Parameters
    ----------
    name : STRING
        Name of the array.
    getcoords : BOOLEAN, optional
        If True, add the array coordinates to the output.
        The default is False.

    Raises
    ------
    NameError
        Name must be &#39;CHARA&#39;.

    Returns
    -------
    TelNames : [NA] list strings
        Names of the telescopes
    BaseNames : [NB] strings
        Name of each baseline.
    BaseNorms : [NB] floats [meter]
        Baselines.
    coords, OPTIONAL: [NA,3] FLOAT ARRAY [meter]
        Coordinates of the array, following the format:
            (XOFFSET,YOFFSET,ZOFFSET) where:
                XOFFSET - East offset in microns from S1
                YOFFSET - North offset in microns from S1
                ZOFFSET - vertical (+ is up) offset in microns from S1,,)
        Take S1 as reference.
    
    &#34;&#34;&#34;
    
    print(name)
    if name == &#39;CHARA&#39;:         
            
        #official coordinates in [µm]
        coords = np.array([[125333989.819,305932632.737,-5909735.735],\
                                 [70396607.118,269713282.258,-2796743.645],\
                                     [0,0,0],\
                                         [-5746854.437,33580641.636,636719.086],\
                                             [-175073332.211,216320434.499,-10791111.235],\
                                                 [-69093582.796,199334733.235,467336.023]])
        coords=coords*1e-6      # [m]
        
    else:
        raise NameError(&#39;Array name must be &#34;CHARA&#34;&#39;)
        
    NA = np.shape(coords)[0]
    
    TelNames = [&#39;E1&#39;,&#39;E2&#39;,&#39;S1&#39;,&#39;S2&#39;,&#39;W1&#39;,&#39;W2&#39;]
    BaseNames = []
    BaseNorms =[]
    config.BasesVectors = np.array([])
    for ia in range(NA):
        for iap in range(NA):
            
            BaseNames.append(str(TelNames[ia]+TelNames[iap]))
            BaseNorms.append(np.sqrt((coords[ia,0]-coords[iap,0])**2 + \
                                    (coords[ia,1]-coords[iap,1])**2 + \
                                  (coords[ia,2]-coords[iap,2])**2))
               
            
    if getcoords:
        return TelNames, BaseNames, BaseNorms, coords
        
    config.BasesVectors
    return TelNames, BaseNames, BaseNorms</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.get_subarray"><code class="name flex">
<span>def <span class="ident">get_subarray</span></span>(<span>pup_used, dsp_all, TelNames, base)</span>
</code></dt>
<dd>
<div class="desc"><p>From the visibility matrix of the whole array (dependant on the object)
returns, the visibility matrix of the array made of the given pupils.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pup_used</code></strong> :&ensp;<code>string LIST [NA]</code></dt>
<dd>Names of the pupils of the subarray.</dd>
<dt><strong><code>dsp_all</code></strong> :&ensp;<code>float [NW,NA0**2]</code></dt>
<dd>The visibility matrix of the whole array.</dd>
<dt><strong><code>TelNames</code></strong> :&ensp;<code>string LIST [NA0]</code></dt>
<dd>Names of the pupils composing the whole array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dsp</code></strong> :&ensp;<code>float [NW,NA**2]</code></dt>
<dd>The visibility matrix of the whole array.</dd>
<dt><strong><code>base</code></strong> :&ensp;<code>string list [NA**2]</code></dt>
<dd>Base names of the subarray.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subarray(pup_used, dsp_all, TelNames, base):
    &#34;&#34;&#34;
    From the visibility matrix of the whole array (dependant on the object)
    returns, the visibility matrix of the array made of the given pupils.

    Parameters
    ----------
    pup_used : string LIST [NA]
        Names of the pupils of the subarray.
    dsp_all : float [NW,NA0**2]
        The visibility matrix of the whole array.
    TelNames : string LIST [NA0]
        Names of the pupils composing the whole array.

    Returns
    -------
    dsp : float [NW,NA**2]
        The visibility matrix of the whole array.
    base : string list [NA**2]
        Base names of the subarray.

    &#34;&#34;&#34;
    
    NA = len(pup_used)
    NA0 = len(TelNames)
    NW = np.shape(dsp_all)[0]
    dsp = np.zeros([NW,NA**2])
    tmp = base
    base=[]
    for ia in range(NA):
        a = TelNames.index(pup_used[ia])
        # dsp[:,ia*(NA+1)] = dsp_all[:,a*(NA0+1)]
        # base.append(tmp[a*(NA0+1)])
        for iap in range(NA):
            k = ia*NA+iap
            ap = TelNames.index(pup_used[iap])
            kp = a*NA0+ap
            dsp[:,k] = dsp_all[:,kp]
            base.append(tmp[kp])
    # import pdb; pdb.set_trace()
   
    return dsp, base, NA</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.get_visibility"><code class="name flex">
<span>def <span class="ident">get_visibility</span></span>(<span>alpha, baseline, spectra, model='disk')</span>
</code></dt>
<dd>
<div class="desc"><p>Using the Bessel expression of the visibility of a centered circular star,
returns the spectral absolute visibility curve of a centered star of
angular diameter alpha as seen with the given baseline distance.
Replaced by VanCittert function that calculates complex visibilities
with a more realistic calculation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float [radian]</code></dt>
<dd>Angular diameter</dd>
<dt><strong><code>base</code></strong> :&ensp;<code>float [meter]</code></dt>
<dd>Baseline</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>[MW] floats [µm]</code></dt>
<dd>Wavelength.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>The model of the object. The default is 'disk'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>[MW]</code></dt>
<dd>Spectral visibilities of the object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_visibility(alpha, baseline, spectra, model=&#39;disk&#39;):
    &#34;&#34;&#34;
    Using the Bessel expression of the visibility of a centered circular star,
    returns the spectral absolute visibility curve of a centered star of 
    angular diameter alpha as seen with the given baseline distance.
    Replaced by VanCittert function that calculates complex visibilities
    with a more realistic calculation.

    Parameters
    ----------
    alpha : float [radian]
        Angular diameter
    base : float [meter]
        Baseline
    spectra : [MW] floats [µm]
        Wavelength.
    model : string, optional
        The model of the object. The default is &#39;disk&#39;.

    Returns
    -------
    V : [MW]
        Spectral visibilities of the object.

    &#34;&#34;&#34;
    spectra = spectra*1e-6
    if model == &#39;disk&#39;:
        if base == 0:
            V = 1
        else:
            V = np.abs(2*jv(1, np.pi*alpha*baseline/spectra)/(np.pi*alpha*baseline/spectra))

    return V</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.info_array"><code class="name flex">
<span>def <span class="ident">info_array</span></span>(<span>array, band)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the transmission efficiencies of the CHARA interferometer in the
expected bands: so far, R and H.
Gives the same transmission for all telescopes.
Take into account:
- Telescope mirror transmission
- Injection loss: in fibers
- Strehl ratio:
- Beam splitters - Part of the flux is used for:
- For AO in R band
- For image control in R band
- For photometry calibration in R band</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>STRING</code></dt>
<dd>Array name.</dd>
<dt><strong><code>band</code></strong> :&ensp;<code>STRING</code></dt>
<dd>Observation band: H or R.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If array is not CHARA.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>transmission</code></strong> :&ensp;<code>FLOAT</code></dt>
<dd>Total transmission.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info_array(array, band):
    &#34;&#34;&#34;
    Stores the transmission efficiencies of the CHARA interferometer in the
    expected bands: so far, R and H.
    Gives the same transmission for all telescopes.
    Take into account:
        - Telescope mirror transmission
        - Injection loss: in fibers
        - Strehl ratio: 
        - Beam splitters - Part of the flux is used for:
            - For AO in R band
            - For image control in R band
            - For photometry calibration in R band

    Parameters
    ----------
    array : STRING
        Array name.
    band : STRING
        Observation band: H or R.

    Raises
    ------
    ValueError
        If array is not CHARA.

    Returns
    -------
    transmission : FLOAT
        Total transmission.

    &#34;&#34;&#34;
    if array == &#39;chara&#39;: # information in SPICA JOSAA paper
        if band == &#39;H&#39;:     
            T_tel = 0.1
            T_inj = 0.65
            T_strehl = 0.8
            T_BS = 1            # No beam splitter in H ? OA?
        if band == &#39;R&#39;:
            T_tel = 0.03
            T_inj = 0.5
            T_strehl = 0.8
            T_BS = 0.88         # Transmission beam-splitter before injection
        
        # Diameter of a telescope and collecting surface [meter²]
        diameter = 1                            
        surface = np.pi*diameter**2/4            
        
        surface = 0.74 #MAM thesis - diameter=1m and occultation=0.25m
                                
    else:
        raise ValueError(&#39;So far, there is data for &#34;chara&#34; only.&#39;)
        
    transmission = T_tel*T_inj*T_strehl*T_BS

    return transmission, surface</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.oversample_wv"><code class="name flex">
<span>def <span class="ident">oversample_wv</span></span>(<span>spectra, OW, spectraband=[], mode='linear_sig')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the micro and macro wavenumbers to use for the simulation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>vector [MW]</code></dt>
<dd>Wavenumbers</dd>
<dt><strong><code>OW</code></strong> :&ensp;<code>int</code></dt>
<dd>Oversampling wavenumbers.</dd>
<dt><strong><code>sigmaband</code></strong> :&ensp;<code>vector [MW]</code>, optional</dt>
<dd>Channel bandwidth</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Way of generating the spectras. The default is 'regular'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Mode needs to be in acceptable values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>[MW*OW] floats</code></dt>
<dd>Micro Wavenumbers.</dd>
<dt><strong><code>sigmaM</code></strong> :&ensp;<code>[MW] floats</code></dt>
<dd>Macro wavenumbers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oversample_wv(spectra, OW, spectraband=[], mode=&#39;linear_sig&#39;):

# def oversample_wv(lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode=&#39;linear_sig&#39;):
    &#34;&#34;&#34;
    Returns the micro and macro wavenumbers to use for the simulation

    Parameters
    ----------
    sigma : vector [MW]
        Wavenumbers
    OW : int
        Oversampling wavenumbers.
    sigmaband : vector [MW], optional
        Channel bandwidth
    mode : string, optional
        Way of generating the spectras. The default is &#39;regular&#39;.

    Raises
    ------
    ValueError
        Mode needs to be in acceptable values.

    Returns
    -------
    sigma : [MW*OW] floats
        Micro Wavenumbers.
    sigmaM : [MW] floats
        Macro wavenumbers.

    &#34;&#34;&#34;
    possible_modes = [&#39;linear_wl&#39;,&#39;linear_sig&#39;]
    
    
    MW = len(spectra)
    
    spectra = np.sort(spectra)
    sigma = np.sort(1/spectra)
    
    
    if len(spectraband)==0:
        spectraband = np.zeros_like(spectra)
        sigmaband = np.zeros_like(spectra)
        for i in range(1,MW):
            spectraband[i] = spectra[i] - spectra[i-1]
            sigmaband[i] = sigma[i] - sigma[i-1]
        spectraband[0] = spectraband[1]
        sigmaband[0] = sigmaband[1]
    
    if mode == &#39;linear_sig&#39;:
        sigma = np.sort(1/spectra)
        sigmaband = spectraband*spectra**(-2)
        
        sigma_os = np.array([])
        for i in range(MW):
            sigbottom = sigma[i]-sigmaband[i]/2
            sigtop = sigma[i]+sigmaband[i]/2
            sigma_temp = np.linspace(sigbottom, sigtop, OW)
            sigma_os = np.concatenate((sigma_os,sigma_temp))
        spectra_os = np.sort(1/sigma_os)
        
    elif mode == &#39;linear_wl&#39;:
        spectra_os = np.array([])
        for i in range(MW):
            wlbottom = spectra[i]-spectraband[i]/2
            wltop = spectra[i]+spectraband[i]/2
            spectra_temp = np.linspace(wlbottom, wltop, OW)
            spectra_os = np.concatenate((spectra_os,spectra_temp))
    
    else:
        raise ValueError(f&#39;mode={mode}. Unknown mode, needs to be in {possible_modes}.&#39;)
    
    return spectra_os, spectra</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.posk"><code class="name flex">
<span>def <span class="ident">posk</span></span>(<span>ia, iap, N)</span>
</code></dt>
<dd>
<div class="desc"><p>k-Position of the OPD[ia,iap] for non redundant combination of two pupils in
a total of N pupils</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ia</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>iap</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>iapp</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>Integer</code></dt>
<dd>Number of telescopes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Integer</code></dt>
<dd>k-position on the most logical order:
for 6T: 01,02,03,04,05,12,13,14,15,23,24,25,34,35,45</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def posk(ia,iap,N):
    &#34;&#34;&#34;
    k-Position of the OPD[ia,iap] for non redundant combination of two pupils in
    a total of N pupils

    Parameters
    ----------
    ia : TYPE
        DESCRIPTION.
    iap : TYPE
        DESCRIPTION.
    iapp : TYPE
        DESCRIPTION.
    N : Integer
        Number of telescopes

    Returns
    -------
    Integer
        k-position on the most logical order: 
            for 6T: 01,02,03,04,05,12,13,14,15,23,24,25,34,35,45

    &#34;&#34;&#34;
    
    return int(ia*N-ia*(ia+3)/2+iap-1)</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.poskfai"><code class="name flex">
<span>def <span class="ident">poskfai</span></span>(<span>ia, iap, iapp, N)</span>
</code></dt>
<dd>
<div class="desc"><p>k-Position of the PhaseClosure for non redundant combination of three pupils
in a total of N pupils.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ia</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>iap</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>iapp</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>Integer</code></dt>
<dd>Number of telescopes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Integer</code></dt>
<dd>k-position</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poskfai(ia,iap,iapp,N):
    &#34;&#34;&#34;
    k-Position of the PhaseClosure for non redundant combination of three pupils
    in a total of N pupils.

    Parameters
    ----------
    ia : TYPE
        DESCRIPTION.
    iap : TYPE
        DESCRIPTION.
    iapp : TYPE
        DESCRIPTION.
    N : Integer
        Number of telescopes.

    Returns
    -------
    Integer
        k-position

    &#34;&#34;&#34;
    
    from scipy.special import binom
    k0 = np.sum(binom(np.arange(N-ia,N),2))
    k1 = posk(iap-ia-1,iapp-iap,N-ia)
    
    return int(k0+k1)</code></pre>
</details>
</dd>
<dt id="coh_lib.coh_tools.simu2GRAV"><code class="name flex">
<span>def <span class="ident">simu2GRAV</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simu2GRAV(matrix):
    
    shape = np.shape(matrix)    
    
    if len(shape)==3:    # There&#39;s several wavelengths
        (NW,NP,NB) = shape
        gravV2PM = np.zeros([NW,NP,NB])*1j
        gravP2VM = np.zeros([NW,NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            gravV2PM[:,:,ia] = matrix[:,:,ksim]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1
                
                # Direct and Conjugate coherence vectors
                direct = matrix[:,:,ia*NA+iap]
                conj = matrix[:,:,iap*NA+ia]
                
                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)                    # Real part location
                gravV2PM[:,:,k] = (direct+conj)/2
                k = int(NA*(NA+1)/2 + kp)           # Imaginary part location
                gravV2PM[:,:,k] = (direct-conj)/2/1j
            
        for iw in range(NW):
            gravP2VM[iw,:,:] = np.linalg.pinv(gravV2PM[iw,:,:])
    
    else:        
        (NP,NB) = shape
        gravV2PM = np.zeros([NP,NB])*1j
        gravP2VM = np.zeros([NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            gravV2PM[:,ia] = matrix[:,ksim]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1
                
                # Direct and Conjugate coherence vectors
                direct = matrix[:,ia*NA+iap]
                conj = matrix[:,iap*NA+ia]
                
                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)                    # Real part location
                gravV2PM[:,k] = (direct+conj)/2
                k = int(NA*(NA+1)/2 + kp)           # Imaginary part location
                gravV2PM[:,k] = (direct-conj)/2/1j
        
        gravP2VM = np.linalg.pinv(gravV2PM)
    
    return gravV2PM, gravP2VM</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="coh_lib.coh_tools.Error"><code class="flex name class">
<span>class <span class="ident">Error</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for exceptions in this module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Error(Exception):
    &#34;&#34;&#34;Base class for exceptions in this module.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="coh_lib.coh_tools.InputError" href="#coh_lib.coh_tools.InputError">InputError</a></li>
</ul>
</dd>
<dt id="coh_lib.coh_tools.InputError"><code class="flex name class">
<span>class <span class="ident">InputError</span></span>
<span>(</span><span>expression, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception raised for errors in the input.</p>
<h2 id="attributes">Attributes</h2>
<p>expression &ndash; input expression in which the error occurred
message &ndash; explanation of the error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputError(Error):
    &#34;&#34;&#34;Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    &#34;&#34;&#34;

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="coh_lib.coh_tools.Error" href="#coh_lib.coh_tools.Error">Error</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coh_lib" href="index.html">coh_lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="coh_lib.coh_tools.BBstar" href="#coh_lib.coh_tools.BBstar">BBstar</a></code></li>
<li><code><a title="coh_lib.coh_tools.NB2NIN" href="#coh_lib.coh_tools.NB2NIN">NB2NIN</a></code></li>
<li><code><a title="coh_lib.coh_tools.coh__GRAV2simu" href="#coh_lib.coh_tools.coh__GRAV2simu">coh__GRAV2simu</a></code></li>
<li><code><a title="coh_lib.coh_tools.create_obsfile" href="#coh_lib.coh_tools.create_obsfile">create_obsfile</a></code></li>
<li><code><a title="coh_lib.coh_tools.generate_spectra" href="#coh_lib.coh_tools.generate_spectra">generate_spectra</a></code></li>
<li><code><a title="coh_lib.coh_tools.generate_spectra0" href="#coh_lib.coh_tools.generate_spectra0">generate_spectra0</a></code></li>
<li><code><a title="coh_lib.coh_tools.get_Bproj" href="#coh_lib.coh_tools.get_Bproj">get_Bproj</a></code></li>
<li><code><a title="coh_lib.coh_tools.get_CfDisturbance" href="#coh_lib.coh_tools.get_CfDisturbance">get_CfDisturbance</a></code></li>
<li><code><a title="coh_lib.coh_tools.get_CfObj" href="#coh_lib.coh_tools.get_CfObj">get_CfObj</a></code></li>
<li><code><a title="coh_lib.coh_tools.get_array" href="#coh_lib.coh_tools.get_array">get_array</a></code></li>
<li><code><a title="coh_lib.coh_tools.get_subarray" href="#coh_lib.coh_tools.get_subarray">get_subarray</a></code></li>
<li><code><a title="coh_lib.coh_tools.get_visibility" href="#coh_lib.coh_tools.get_visibility">get_visibility</a></code></li>
<li><code><a title="coh_lib.coh_tools.info_array" href="#coh_lib.coh_tools.info_array">info_array</a></code></li>
<li><code><a title="coh_lib.coh_tools.oversample_wv" href="#coh_lib.coh_tools.oversample_wv">oversample_wv</a></code></li>
<li><code><a title="coh_lib.coh_tools.posk" href="#coh_lib.coh_tools.posk">posk</a></code></li>
<li><code><a title="coh_lib.coh_tools.poskfai" href="#coh_lib.coh_tools.poskfai">poskfai</a></code></li>
<li><code><a title="coh_lib.coh_tools.simu2GRAV" href="#coh_lib.coh_tools.simu2GRAV">simu2GRAV</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="coh_lib.coh_tools.Error" href="#coh_lib.coh_tools.Error">Error</a></code></h4>
</li>
<li>
<h4><code><a title="coh_lib.coh_tools.InputError" href="#coh_lib.coh_tools.InputError">InputError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>