<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cophasing.coh_tools API documentation</title>
<meta name="description" content="Created on Fri Mar
6 16:14:42 2020 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cophasing.coh_tools</code></h1>
</header>
<section id="section-intro">
<p>Created on Fri Mar
6 16:14:42 2020</p>
<p>@author: cpannetier</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Fri Mar  6 16:14:42 2020

@author: cpannetier
&#34;&#34;&#34;

import os, pkg_resources

datadir = &#39;data/&#39;

import numpy as np
from scipy.special import jv,binom
from scipy import interpolate

from astropy.time import Time
from astropy.coordinates import SkyCoord, EarthLocation, AltAz

from .tol_colors import tol_cset # colorblind-riendly and contrastful library
import matplotlib.patches as mpatches
import matplotlib.lines as mlines

from astropy.io import fits

import matplotlib.pyplot as plt

from . import config
import cophasing.decorators as deco

global h_, c_, k_

h_ = 6.626e-34  # Planck&#39;s constant
c_ = 3.0e+8     # Light velocity
k_ = 1.38e-23    # Boltzmann&#39;s constant


colors = tol_cset(&#39;bright&#39;)

SS = 12     # Small size
MS = 14     # Medium size
BS = 16     # Big size
figsize = (16,8)
rcParamsForBaselines = {&#34;font.size&#34;:SS,
       &#34;axes.titlesize&#34;:SS,
       &#34;axes.labelsize&#34;:MS,
       &#34;axes.grid&#34;:True,
       
       &#34;xtick.labelsize&#34;:SS,
       &#34;ytick.labelsize&#34;:SS,
       &#34;legend.fontsize&#34;:SS,
       &#34;figure.titlesize&#34;:BS,
       &#34;figure.constrained_layout.use&#34;: False,
       &#34;figure.figsize&#34;:figsize,
       &#39;figure.subplot.hspace&#39;: 0.05,
       &#39;figure.subplot.wspace&#39;: 0,
       &#39;figure.subplot.left&#39;:0.1,
       &#39;figure.subplot.right&#39;:0.95
       }


class Error(Exception):
    &#34;&#34;&#34;Base class for exceptions in this module.&#34;&#34;&#34;
    pass

class InputError(Error):
    &#34;&#34;&#34;Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    &#34;&#34;&#34;

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message


def BBstar(wav, T):
    &#34;&#34;&#34;
    Returns the spectral luminance of a black-body given its temperature.
    Will be useful to give the shape of the spectra of a star.

    Parameters
    ----------
    wav : [NW] float [meter]
        Wavelength in meter.
    T : float [K]
        Temperature of the Black-Body in Kelvin.

    Returns
    -------
    luminance : [NW] floats [W/s/m²/sr]
        Luminance of the source per steradian.

    &#34;&#34;&#34;
    global h_, c_, k_
    
    a = 2.0*h_*c_**2
    b = h_*c_/(wav*k_*T)
    luminance = a / ( (wav**5) * (np.exp(b) - 1.0) ) # W/m²/sr/µm
    
    # nu = c_/spectra   # Electromagnetic frequency [Hz]
    # a = 2.*h_/c_**2
    # b = h_/k_/T
    # B_sig = a*nu**3/(np.exp(b*nu)-1)  # W/m²/sr/s
    
    return luminance


def info_array(array, band):
    &#34;&#34;&#34;
    Stores the transmission efficiencies of the CHARA interferometer in the
    expected bands: so far, R and H.
    Gives the same transmission for all telescopes.
    Take into account:
        - Telescope mirror transmission
        - Injection loss: in fibers
        - Strehl ratio: 
        - Beam splitters - Part of the flux is used for:
            - For AO in R band
            - For image control in R band
            - For photometry calibration in R band

    Parameters
    ----------
    array : STRING
        Array name.
    band : STRING
        Observation band: H or R.

    Raises
    ------
    ValueError
        If array is not CHARA.

    Returns
    -------
    transmission : FLOAT
        Total transmission.

    &#34;&#34;&#34;
    if array in [&#39;chara&#39;,&#39;CHARA&#39;]: # information in SPICA JOSAA paper
        if band == &#39;H&#39;:     
            T_tel = 0.1
            T_inj = 0.65
            T_strehl = 0.8
            T_BS = 1            # No beam splitter in H ? OA?
        
        if band == &#39;R&#39;:
            T_tel = 0.03
            T_inj = 0.5
            T_strehl = 0.8
            T_BS = 0.88         # Transmission beam-splitter before injection
        
        # Diameter of a telescope and collecting surface [meter²]
        diameter = 1                            
        surface = np.pi*diameter**2/4            
        
        surface = 0.74 #MAM thesis - diameter=1m and occultation=0.25m
                                
    else:
        raise ValueError(&#39;So far, there is data for &#34;chara&#34; only.&#39;)
        
    transmission = T_tel*T_inj*T_strehl*T_BS

    return transmission, surface
    

def get_array(name=&#39;&#39;,band=&#39;H&#39;,getcoords=False,
              verbose=False):
    &#34;&#34;&#34;
    Returns the coordinates, baselines and base names of a given array

    Parameters
    ----------
    name : STRING
        Name of the array.
    getcoords : BOOLEAN, optional
        If True, add the array coordinates to the output.
        The default is False.

    Raises
    ------
    NameError
        Name must be &#39;CHARA&#39;.

    Returns
    -------
    TelNames : [NA] list strings
        Names of the telescopes
    BaseNames : [NB] strings
        Name of each baseline.
    BaseNorms : [NB] floats [meter]
        Baselines.
    coords, OPTIONAL: [NA,3] FLOAT ARRAY [meter]
        Coordinates of the array, following the format:
            (XOFFSET,YOFFSET,ZOFFSET) where:
                XOFFSET - East offset in microns from S1
                YOFFSET - North offset in microns from S1
                ZOFFSET - vertical (+ is up) offset in microns from S1,,)
        Take S1 as reference.
    
    &#34;&#34;&#34;
    
    class Interferometer:
        def __init__(self):
            pass
    InterfArray = Interferometer()
    
    if &#34;fits&#34; in name:
        filepath = name
        if not os.path.exists(filepath):
            try:
                if verbose:
                    print(&#34;Looking for the interferometer file into the package&#39;s data&#34;)
                filepath = pkg_resources.resource_stream(__name__,filepath)
            except:
                raise Exception(f&#34;{filepath} doesn&#39;t exist.&#34;)

        with fits.open(filepath) as hdu:
            ArrayParams = hdu[0].header
            NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
            InterfArray.NA = NA
            InterfArray.NIN = NIN
            TelData = hdu[1].data
            BaseData = hdu[2].data
        
            InterfArray.TelNames = TelData[&#39;TelNames&#39;]
            InterfArray.TelCoordinates = TelData[&#39;TelCoordinates&#39;]
            InterfArray.TelTransmissions = TelData[&#39;TelTransmissions&#39;]
            InterfArray.TelSurfaces = TelData[&#39;TelSurfaces&#39;]
            InterfArray.BaseNames = BaseData[&#39;BaseNames&#39;]
            InterfArray.BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
            
        InterfArray.BaseNorms = np.linalg.norm(InterfArray.BaseCoordinates[:,:2],axis=1)
    
        
    elif name == &#39;CHARA&#39;:         
            
        #official coordinates in [µm]
        TelCoordinates= np.array([[125333989.819,305932632.737,-5909735.735],\
                                 [70396607.118,269713282.258,-2796743.645],\
                                     [0,0,0],\
                                         [-5746854.437,33580641.636,636719.086],\
                                             [-175073332.211,216320434.499,-10791111.235],\
                                                 [-69093582.796,199334733.235,467336.023]])
        TelCoordinates=TelCoordinates*1e-6      # [m]
        
        NA = np.shape(TelCoordinates)[0]
        
        TelNames = [&#39;E1&#39;,&#39;E2&#39;,&#39;S1&#39;,&#39;S2&#39;,&#39;W1&#39;,&#39;W2&#39;]
        BaseNames = []
        BaseCoordinates =[]

        for ia in range(NA):
            for iap in range(ia+1,NA):
                BaseNames.append(str(TelNames[ia]+TelNames[iap]))
                BaseCoordinates.append([TelCoordinates[ia,0]-TelCoordinates[iap,0],
                                        TelCoordinates[ia,1]-TelCoordinates[iap,1],
                                        TelCoordinates[ia,2]-TelCoordinates[iap,2]])
        BaseCoordinates = np.array(BaseCoordinates)        
        BaseNorms = np.linalg.norm(BaseCoordinates[:,:2],axis=1)

        InterfArray.NA = NA
        InterfArray.TelNames=TelNames
        InterfArray.BaseNorms=BaseNorms
        InterfArray.BaseNames = BaseNames
        InterfArray.TelCoordinates = TelCoordinates
        InterfArray.BaseCoordinates = BaseCoordinates
        
        transmission, surface = info_array(name,band)
        InterfArray.TelSurfaces = np.ones(NA)*surface
        InterfArray.TelTransmissions = np.ones(NA)*transmission
        
    else:
        raise Exception(&#34;For defining the array, you must give a file \
or a name (currently only CHARA is available).&#34;)
        
    return InterfArray
    

def get_Bproj(baseline, theta):
    &#34;&#34;&#34;
    Calculates projected bases according to the viewed angle in radian

    Parameters
    ----------
    baseline : float [meter]
        Distance between telescopes in meters.
    theta : float [radian]
        Angle viewed by the base (depend on declination and azimuth).
        
    Returns
    -------
    Bproj : float [meter]
        Projected base.

    &#34;&#34;&#34;
    
    Bproj = baseline * np.sin(theta)
    return Bproj


def get_visibility(alpha, baseline, spectra, model=&#39;disk&#39;):
    &#34;&#34;&#34;
    Using the Bessel expression of the visibility of a centered circular star,
    returns the spectral absolute visibility curve of a centered star of 
    angular diameter alpha as seen with the given baseline distance.
    Replaced by VanCittert function that calculates complex visibilities
    with a more realistic calculation.

    Parameters
    ----------
    alpha : float [radian]
        Angular diameter
    base : float [meter]
        Baseline
    spectra : [MW] floats [µm]
        Wavelength.
    model : string, optional
        The model of the object. The default is &#39;disk&#39;.

    Returns
    -------
    V : [MW]
        Spectral visibilities of the object.

    &#34;&#34;&#34;
    spectra = spectra*1e-6
    if model == &#39;disk&#39;:
        if baseline == 0:
            V = 1
        else:
            V = np.abs(2*jv(1, np.pi*alpha*baseline/spectra)/(np.pi*alpha*baseline/spectra))

    return V


#@deco.timer
def VanCittert(spectra, Obs, Target, plottrace=60, display=False,
               savedir=&#39;&#39;,ext=&#39;pdf&#39;,verbose=False):
    &#34;&#34;&#34;
    Create the Coherent flux matrix of an object in the (u,v) plane according
    to:
        - the Observation parameters: array, date and star coords.
        - the Science object: angular diameters, positions, relative luminosity


    Parameters
    ----------
    spectra : TYPE
        DESCRIPTION.
    starname : TYPE, optional
        DESCRIPTION. The default is &#39;Deneb&#39;.
    angdiameters : TYPE, optional
        DESCRIPTION. The default is (0.3,0.3).
    relative_L : TYPE, optional
        DESCRIPTION. The default is (1,1).
    display : TYPE, optional
        DESCRIPTION. The default is False.

    Returns
    -------
    visibilities : ARRAY [NW,NIN]*1j
        DESCRIPTION.

    &#34;&#34;&#34;
        
    if (len(savedir)) and (not os.path.exists(savedir)):
        os.makedirs(savedir)
        
    if verbose:
        print(&#34;Calculation of object&#39;s visibilities from Van Cittert theorem\n ...&#34;)

    # Relative positions of the two stars
    pos_star1 = Target.Star1[&#39;Position&#39;]
    angular_diameter1 = Target.Star1[&#39;AngDiameter&#39;]
    H1 = Target.Star1[&#39;Hmag&#39;]
    
    BinaryObject = True
    try:
        pos_star2 = Target.Star2[&#39;Position&#39;]
        angular_diameter2 = Target.Star2[&#39;AngDiameter&#39;]
        H2 = Target.Star2[&#39;Hmag&#39;]
    except:
        if verbose:
            print(&#39;Simple centered star1&#39;)
        BinaryObject = False
        
        # angular_diameter2 = angular_diameter1
        # H2 = 0
        
    # pos_star1 = np.array([1,-1])
    # pos_star2 = np.array([-1,1])
    
    # BinaryObject = (type(angdiameters) == tuple)
    
    if BinaryObject:
        # Calculation of a relative luminosity
        (luminosity1,luminosity2) = (10**(-0.4*H1),10**(-0.4*H2))
        # (angular_diameter1,angular_diameter2) = angdiameters
        
        # Pixel unit luminance ratio between both stars
        LuminanceRatio = luminosity1/angular_diameter1*angular_diameter2/luminosity2
    # else:
    #     # angular_diameter1 = angdiameters
    #     # angular_diameter2 = angdiameters
    #     luminosity1 = 1
    #     # luminosity2 = 0
    #     # pos_star1 = np.array([0,0])
    
    
    # Npix = 1024
    # thetamax = 10
    # dtheta = 2*thetamax/Npix
    
    # dtheta must well sample the smallest star
    #if BinaryObject:
    #    dtheta = np.min((angular_diameter1,angular_diameter2))/5
    #else:
    #    dtheta = angular_diameter1/5
        
    du = 0.005
    Npix = 5000     #2*int(thetamax/dtheta)
    dtheta = 1/(du*Npix)   # 0.04mrad
    
    thetamax = dtheta*Npix/2

    obj_plane = np.zeros([Npix,Npix])
    
    coords = (np.arange(Npix)- Npix/2)*dtheta
    (alpha,beta) = np.meshgrid(coords,-coords)
    dist1 = np.sqrt((alpha-pos_star1[0])**2 + (beta-pos_star1[1])**2)
    obj_plane[dist1&lt;angular_diameter1/2] = 1
    NpixStar1 = np.sum(obj_plane)
    
    if BinaryObject:
        dist2 = np.sqrt((alpha-pos_star2[0])**2 + (beta-pos_star2[1])**2)
        obj_plane[dist2&lt;angular_diameter2] = 1/LuminanceRatio
        
    
    # Normalisation of the luminosity, with first star as reference
    obj_plane = obj_plane/NpixStar1

    Nticks = 7
    ticks = np.linspace(0,Npix,Nticks)
        
    if display:            
        fig = plt.figure(config.newfig, figsize=(16,9))
        (ax1,ax2,ax3) = fig.subplots(ncols=3)
        
        spaceticks = (ticks-round(Npix/2))*dtheta
        spaceticks = spaceticks.round(decimals=1)
        
        ax1.set_title(&#39;Object in direct plane&#39;)
        ax1.imshow(obj_plane)
        ax1.set_xticks(ticks) ; ax1.set_xticklabels(spaceticks)
        ax1.set_yticks(ticks) ; ax1.set_yticklabels(-spaceticks)
        ax1.set_xlabel(&#39;\u03B1 [mas]&#39;)
        ax1.set_ylabel(&#39;\u03B2 [mas]&#39;)
    
    # Van-Cittert theorem (calculation of the visibility)
    
    uv_plane = np.fft.ifftshift(np.fft.fft2(np.fft.fftshift(obj_plane)))
    uv_plane /= np.max(np.abs(uv_plane))
    
    # (u,v) sampling
    freqs = np.fft.fftshift(np.fft.fftfreq(Npix, dtheta))
    dfreq = freqs[1] - freqs[0]
    (ucoords,vcoords) = np.meshgrid(freqs, -freqs)
    freqticks = (ticks-round(Npix/2))*dfreq
    freqticks = freqticks.round(decimals=1)
    
    if display:        

        ax2.set_title(&#39;Module of the visibility&#39;)
        ax2.imshow(np.abs(uv_plane),vmin=0,vmax=1)
        ax2.set_xticks(ticks) ; ax2.set_xticklabels(freqticks)
        ax2.set_yticks(ticks) ; ax2.set_yticklabels(-freqticks)
        ax2.set_xlabel(&#39;u [mas-1]&#39;)
        ax2.set_ylabel(&#39;v [mas-1]&#39;)
        
        ax3.set_title(&#39;Phase of the visibility&#39;)
        ax3.imshow(np.angle(uv_plane),vmin=-np.pi,vmax=np.pi)
        ax3.set_xticks(ticks) ; ax3.set_xticklabels(freqticks)
        ax3.set_yticks(ticks) ; ax3.set_yticklabels(-freqticks)
        ax3.set_xlabel(&#39;u [mas-1]&#39;)
        ax3.set_ylabel(&#39;v [mas-1]&#39;)
        
        fig.show()
        config.newfig+=1
    
    &#34;&#34;&#34;
    Projection of the interferometer on the (u,v) plane
    &#34;&#34;&#34;
    
    # Get telescopes coordinates and names
    InterfArray = get_array(config.Name, getcoords=True)    
    
    TelNames = InterfArray.TelNames
    CHARAcoords = InterfArray.TelCoordinates
    basecoords = InterfArray.BaseCoordinates
    
    CHARAcoords *= 1e6          # Convert to [µm]
    basecoords *= 1e6          # Convert to [µm]
    
    NA = len(CHARAcoords)
    
    CHARAaltaz = np.zeros([NA,2])
    for ia in range(NA):
        if np.linalg.norm(CHARAcoords[ia]) == 0:
            CHARAaltaz[ia,0] = 0
            CHARAaltaz[ia,1] = 0    
        else:
            CHARAaltaz[ia,1] = np.arctan(CHARAcoords[ia,0]/CHARAcoords[ia,1])
            CHARAaltaz[ia,0] = np.arcsin(CHARAcoords[ia,2]/np.linalg.norm(CHARAcoords[ia]))
    
    NIN = int(NA*(NA-1)/2)
    basealtaz = np.zeros([NIN,2])       # Altazimuthal coordinates of the baselines [radians]
    basedist = np.zeros([NIN,1])        # Baselines lengths in [µm]
    basecoords = np.zeros([NIN,3])      # Baselines coordinates [µm]
    basenames = []                      # Baselines names [string]
    
    for ia in range(NA):
        for iap in range(ia+1,NA):
            ib = int(ia*NA-ia*(ia+3)/2+iap-1)
            
            basealtaz[ib] = CHARAaltaz[iap]-CHARAaltaz[ia]
            
            basenames.append(TelNames[ia]+TelNames[iap])
            basecoords[ib] = CHARAcoords[iap] - CHARAcoords[ia]
            basedist[ib] = np.linalg.norm(basecoords[ib])
    
    
    # First case: the name of the object has been given. We search it in Simbad
    # database and its AltAzimutal coordinates if a Date has been given.
    if Target.Name not in (&#39;Simple&#39;,&#39;Binary&#39;,&#39;Unresolved&#39;) and (&#39;AltAz&#39; not in vars(Obs)):
        starttime = Time(Obs.DATE)
        if verbose:
            print(f&#34;Observation date: {Obs.DATE}&#34;)
    
        starcoords = SkyCoord.from_name(Target.Name)
        ArrayLocation=EarthLocation.of_site(Obs.ArrayName)
        staraltaz = starcoords.transform_to(AltAz(obstime=starttime,location=ArrayLocation))
        
        (altitude, azimuth) = (staraltaz.alt.radian,staraltaz.az.radian)
        Obs.AltAz = (180/np.pi*altitude, 180/np.pi*azimuth)
        
    else:
        (altitude, azimuth) = (theta*np.pi/180 for theta in Obs.AltAz)
        if verbose:
            print(f&#34;User defined {Target.Name} object with AltAz={Obs.AltAz}&#34;)
        
        
    
    &#34;&#34;&#34;
    Altazimuthal coordinates definition:
        - azimuth: angular distance between the intersection of the target meridian with 
        the horizon and the north horizon: East = 90° Azimuth.
        - altitude: angular distance between the horizon and the target, along its meridian.
    
    CHARA coordinates definition:
        - X: toward East
        - Y: toward North
        - Z: toward Zenith
    &#34;&#34;&#34;
    
    
    # Coordinates of the (u,v) plane in the (E,N,Z) referential
    u_Ep = np.array([np.cos(azimuth),np.sin(azimuth),0])
    u_Np = np.array([np.sin(altitude)*np.sin(azimuth),np.sin(altitude)*np.cos(azimuth),np.cos(altitude)])
    u_Zp = np.array([np.cos(altitude)*np.sin(azimuth),np.cos(altitude)*np.cos(azimuth),np.sin(altitude)])
    
    
    # Projection baselines on the target&#39;s (u,v) plane
    B_Ep = np.dot(basecoords, np.transpose(u_Ep))
    B_Np = -np.dot(basecoords, np.transpose(u_Np))
    B_Zp = np.dot(basecoords, np.transpose(u_Zp))
    
    # baselines = np.transpose(basedist)*np.sin(altitude-basealtaz[:,0])
    
    if isinstance(spectra,(float,int)):
        spectra = [spectra]
    
    NW = len(spectra)
    
    # Projection baselines on the u,v coordinates (oriented with the star north-east)
    chara_uv = np.zeros([NW,NIN,2])
    for iw in range(NW):
        lmbda=spectra[iw]
        chara_uv[iw,:,0] = B_Ep/lmbda
        chara_uv[iw,:,1] = B_Np/lmbda
    
    # Conversion functions
    mas2rad = lambda mas : 1/3600*1e-3*np.pi/180*mas
    rad2mas = lambda rad : 3600*1e3*180/np.pi*rad

    #Convert (u,v) plane from radian to mas
    chara_uv_direct = 1/chara_uv
    chara_uv_direct_mas = rad2mas(chara_uv_direct)
    chara_uv = 1/chara_uv_direct_mas
    
    # Return the complex visibility vector of the source
    visibilities = np.zeros([NW,NIN])*1j
    for ib in range(NIN):
        for iw in range(NW):     
            ub=chara_uv[iw,ib,0] ; vb=chara_uv[iw,ib,1]
            Nu = int(round(ub/dfreq)+Npix/2)
            Nv = int(round(vb/dfreq)+Npix/2)
            visibilities[iw,ib] = uv_plane[Nu,Nv]
        
    UVcoords = (ucoords,vcoords)
    #UVcoordsMeters = [1/mas2rad(1/coord)*np.median(lmbda) for coord in UVcoords]
    
    if verbose:
        print(&#34;Visibilities calculated.&#34;)
    
    
    if display:         # Display (u,v) plane with interferometer projections (first wavelength)
        
        if &#39;active_ich&#39; in config.FS.keys():
            active_ich = config.FS[&#39;active_ich&#39;]
            PhotSNR = config.FS[&#39;PhotometricSNR&#39;]
        else:
            active_ich=np.ones(NIN)
            PhotSNR = np.ones(NIN)
            
        actindNIN = np.array(active_ich)==1
        actind = np.concatenate([actindNIN[::-1], actindNIN])
        
        PhotometricSNR = np.concatenate([PhotSNR[::-1],PhotSNR])
        
        if verbose:
            print(f&#39;Plot CHARA (u,v) coverage on figure {config.newfig}&#39;)    
        chara_uv_complete = np.concatenate((chara_uv[NW//2], -chara_uv[NW//2]),axis=0)
        
        uvmax = np.max(chara_uv_complete/dfreq)+10
        
        Ndisplay = 2*int(uvmax+10)
        
        uv_crop = uv_plane[(Npix-Ndisplay)//2:(Npix+Ndisplay)//2,(Npix-Ndisplay)//2:(Npix+Ndisplay)//2]
        chara_plot = chara_uv_complete/dfreq+Ndisplay/2
        
        Nticks = 11
        ticks = np.linspace(0,Ndisplay-1,Nticks)
        freqticks = (ticks+1-round(Ndisplay/2))*dfreq
        freqticks = freqticks.round(decimals=1)
        # Display the Visibility and the interferometer baselines on the (u,v) plane
        fig = plt.figure(config.newfig)
        ax = fig.subplots()
        fig.suptitle(&#39;(u,v) coverage&#39;)
        im=ax.imshow(np.abs(uv_crop),vmin=0,vmax=1)
        
        ax.scatter(chara_plot[actind,0], chara_plot[actind,1], marker=&#39;x&#39;, s=50*np.sqrt(PhotometricSNR[actind]),linewidth=1, color=&#39;firebrick&#39;)
        ax.scatter(chara_plot[actind==False,0], chara_plot[actind==False,1], marker=&#39;x&#39;, s=50, linewidth=1,color=&#39;black&#39;)
        plt.xticks(ticks,freqticks)
        plt.yticks(ticks,-freqticks)
        ax.set_xlabel(&#39;u (W-E) [$mas^{-1}$]&#39;)
        ax.set_ylabel(&#39;v (S-N) [$mas^{-1}$]&#39;)
        
        fig.subplots_adjust(right=0.8)
        cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
        fig.colorbar(im, cax=cbar_ax)
        
        config.newfig += 1
        
        
        if len(savedir):
            import time
            timestr = time.strftime(&#34;%Y%m%d-%H%M%S&#34;)
            plt.savefig(savedir+f&#34;UVplane{timestr}.{ext}&#34;)
    
    # if NW==1:
    #     visibilities = visibilities[0]
    
    return visibilities, chara_uv, uv_plane, UVcoords


def create_obsfile(spectra, Obs, Target, savingfilepath=&#39;&#39;,
                   savedir=&#39;&#39;, ext=&#39;pdf&#39;,overwrite=False, display=False,
                   verbose=True):
    &#34;&#34;&#34;
    Creates the coherent flux matrix of the object at the entrance of the 
    fringe sensor and save it into a fitsfile.
    It takes into account:
        - star spectral distribution (BlackBody approx, or flat)
        - Array transmission
        - Visibility on the different baselines
    
    These parameters are given by the objects Obs and Target.

    Parameters
    ----------
    spectra : FLOAT ARRAY [NW]
        Spectral sampling.
    Obs : OBSERVATION CLASS OBJECT
        Contains the information on the interferometer and other things.
    Target : OBJECT CLASS OBJECT
        Contains the information on the object.
    savingfilepath : STRING, optional
        File name. The default is &#39;&#39;.
    overwrite : BOOLEAN, optional
        If True, overwrite the existing file. The default is False.
    display : BOOLEAN, optional
        If True, display some plots. The default is False.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    CohIrradiance : COMPLEX ARRAY [NW,NB]
        Spectral photon distribution including visibility and star photometry
        on all baselines. [ph/s].
    UncohIrradiance : FLOAT ARRAY [NW]
        Spectral photon distribution [pht/s/telescope/µm] of the star without visibility..
    VisObj : COMPLEX ARRAY [NW,NB]
        Visibility of the object, normalised between 0 and 1.
    BaseNorms : FLOAT ARRAY [NIN or NB ?]
        Norm of the different baselines.
    TelNames : STRING ARRAY [NA]
        Names of the telescopes.
    &#34;&#34;&#34;

    # spectra = 1/sigma     # [µm] Wavelengths
    NW = len(spectra)     # [int] Wavelengths number
    
    # First case: Temperature of the first star is given
    # We compute a BlackBody model
    if &#39;T&#39; in Target.Star1.keys():    
        T=Target.Star1[&#39;T&#39;]
        Irradiance = BBstar(spectra*1e-6, T)       # Create BB star model in wavelengths    
        Irradiance = Irradiance[::-1]             # (Reverse) the spectra according to sigmas
        norm = np.mean(Irradiance[(spectra&gt;=1.4)*(spectra&lt;=1.75)])    # Normalization of the flux on the whole H band
        Irradiance/=norm

    else:
        Irradiance=np.ones_like(spectra)
        
    magH = Target.Star1[&#39;Hmag&#39;]
    # Luminance according to apparent magnitude    
    
    L0_ph = 93.3e8        # Photons.m-2.s-1.µm-1 at 1.63µm
    
    Lph_H = L0_ph*10**(-0.4*magH)
    
    # Preference for photons directly to keep a uniform spectra
    UncohIrradiance = Irradiance*Lph_H             # [phot/s/m²/µm] Source Irradiance 
    
    # Using Watt as reference and converting in photons: drawback=non uniform spectra
    # L0_w = 7 * 10**(-10)                      # [W/m²/µm] Reference luminance at 1.65µm (Lena)
    # L0_w = 11.38 * 10**(-10)                  # [W/m²/µm] Reference luminance at 1.63µm (Bessel)
    # Lw_H = L0_w*10**(-0.4*magH)                        # Definition of the magnitude
    # UncohIrradiance_w = luminance*Lw_H / (h_*c_/spectra*1e6)          # [phot/s/m²/µm]

    filepath = Obs.Filepath
    if not os.path.exists(filepath):
        raise Exception(f&#34;{filepath} doesn&#39;t exist.&#34;)
    
    with fits.open(filepath) as hdu:
        ArrayParams = hdu[0].header
        NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
        ArrayName = ArrayParams[&#39;NAME&#39;]
        TelData = hdu[1].data
        BaseData = hdu[2].data
        
        TelNames = TelData[&#39;TelNames&#39;]
        TelCoordinates = TelData[&#39;TelCoordinates&#39;]
        TelTransmissions = TelData[&#39;TelTransmissions&#39;]
        TelSurfaces = TelData[&#39;TelSurfaces&#39;]
        BaseNames = BaseData[&#39;BaseNames&#39;]
        BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
        
        
    InterfArray = get_array(name=filepath)
    
    NB = NA**2
    NC = int(binom(NA,3))
    
    # Transportation of the star light into the interferometer
    Throughput = np.reshape(InterfArray.TelSurfaces*InterfArray.TelTransmissions,[1,NA])
    ThroughputMatrix = np.sqrt(np.dot(np.transpose(Throughput), Throughput))
    ThroughputMatrix = ThroughputMatrix.reshape([1,NB])
    # Matrix where the element at the (ia*NA+iap) position is Ta*Tap
    # UncohIrradianceAfterTelescopes = np.dot(np.diag(TelTransmissions),np.transpose(UncohIrradiance))
    
    # Projection of the base on the (u,v) plane
    #BaseNorms = get_Bproj(np.array(InterfArray.BaseNorms), Obs.AltAz[0])
    
    VisObj = np.zeros([NW,NB])*1j               # Object Visibility [normalised]
    CohIrradiance = np.zeros([NW,NB])*1j        # Source coherent Irradiance [phot/s/m²/deltalmbda]    
      
    # UncohIrradianceAfterTelescopes = UncohIrradiance*TelTransmissions*TelSurfaces
    

    if Target.Name == &#39;Unresolved&#39;:
        VisObj = np.ones([NW,NB])
        CPObj = np.zeros([NW,NC])
        
    elif Target.Name == &#39;Manual&#39;:
        phi = np.zeros([NW,NB])
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                phi[:,ia*NA+iap] = Target.Phases[ib]
                phi[:,iap*NA+ia] = -Target.Phases[ib]
        VisObj = np.exp(1j*phi)
        # VisObj = np.repeat(VisObj[np.newaxis,:],NW,axis=0)
        
        bispectrum = np.zeros([NW,NC])*1j
        for ia in range(NA):
            for iap in range(ia+1,NA):
                for iapp in range(iap+1,NA):
                    ci1 = VisObj[:,ia*NA+iap]
                    ci2 = VisObj[:,iap*NA+iapp]
                    ci3 = VisObj[:,iapp*NA+ia]
                    ic = poskfai(ia,iap,iapp,NA)
                    bispec = ci1*ci2*ci3
                    bispec[np.abs(bispec)&lt;0.05] = 0
                    bispectrum[:,ic] = bispec
        
    else:           # Van-Cittert theorem visibility
        visibilities,_,_,_ = VanCittert(spectra, Obs, Target,
                                        display=display, savedir=savedir, ext=ext)
        
        bispectrum = np.zeros([NW,NC])*1j
        
        for ia in range(NA):
            VisObj[:,ia*(NA+1)] = np.ones(NW)
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                VisObj[:,ia*NA+iap] = visibilities[:,ib]
                VisObj[:,iap*NA+ia] = np.conj(visibilities[:,ib])
                for iapp in range(iap+1,NA):
                    cs1 = VisObj[:,ia*NA+iap]     # Coherent flux (ia,iap) 
                    cs2 = VisObj[:,iap*NA+iapp]  # Coherent flux (iap,iapp) 
                    cs3 = VisObj[:,iapp*NA+ia] # Coherent flux (iapp,ia) 
                    ic = poskfai(ia,iap,iapp,NA) 
                    bispectrum[:,ic]+=cs1*cs2*cs3
                    
        CPObj = np.angle(bispectrum)
        
    for iw in range(NW):    
        CohIrradiance[iw] = UncohIrradiance[iw] * ThroughputMatrix * VisObj[iw]

    BaseNorms, TelNames = InterfArray.BaseNorms, InterfArray.TelNames
    
    if display:
        from . import config
        
        fig = plt.figure(&#34;Visibility of the star&#34;,figsize=(12,9))
        linestyles=[]
        (ax1,ax2,ax5),(ax3,ax4,ax6) = fig.subplots(nrows=2,ncols=3,gridspec_kw={&#39;width_ratios&#39;:[3,3,1]})
        
        gs=ax3.get_gridspec()
        ax3.remove() ; ax4.remove()
        # Add a unique axe on the last row
        ax3 = fig.add_subplot(gs[1,:])
        
        ax5.axis(&#39;off&#39;) ; ax6.axis(&#39;off&#39;)
        
        ax1.set_title(&#39;|V|&#39;)
        ax2.set_title(&#39;arg(V)&#39;)
        ax3.set_title(&#39;Coherent Irradiance $\Gamma$&#39;)
        
        ax1.plot(spectra, np.abs(VisObj[:,0]),color=&#39;red&#39;)
        ax3.plot(spectra, UncohIrradiance,color=&#39;red&#39;)  # Same for all baselines
        linestyles.append(mlines.Line2D([],[],
                                        color=&#39;red&#39;,
                                        label=f&#34;Uncoherent flux&#34;))

        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                if ib&lt;8:
                    cl=colors[ib] ; ls=&#39;solid&#39;
                else:
                    cl=colors[ib-8] ; ls=&#39;--&#39;
                ax1.plot(spectra, np.abs(VisObj[:,ib]),
                         color=cl,linestyle=ls)
                ax2.plot(spectra, np.angle(VisObj[:,ib]),
                         color=cl,linestyle=ls)
                ax3.plot(spectra, np.abs(CohIrradiance[:,ib]),
                         color=cl,linestyle=ls)
                linestyles.append(mlines.Line2D([],[],
                                                color=cl,linestyle=ls,
                                                label=f&#34;{BaseNames[ib]}:{round(BaseNorms[ib])}m&#34;))
        
        ax1.set_ylim(0,1.1) ; ax2.set_ylim(-np.pi,np.pi)
        ax1.set_xlabel(&#39;Wavelengths [µm]&#39;)
        ax2.set_xlabel(&#39;Wavelengths [µm]&#39;)
        ax3.set_xlabel(&#39;Wavelengths [µm]&#39;)
        
        ax5.legend(handles=linestyles, loc=&#39;upper right&#39;)
        
        ax3.set_ylabel(&#39;Coherent Irradiance \n [photons/s/m²/µm]&#39;)
        ax1.grid(True);ax2.grid(True);ax3.grid(True)
        
        config.newfig+=1       
        
        
    if savingfilepath==&#39;no&#39;:
        if verbose:
            print(&#34;Not saving the data.&#34;)
        return CohIrradiance, UncohIrradiance, VisObj, BaseNorms, TelNames

    else:
        fileexists = os.path.exists(savingfilepath)
        if fileexists:
            if verbose:
                print(f&#39;{savingfilepath} already exists.&#39;)
            if overwrite:
                os.remove(savingfilepath)
            else:
                if verbose:
                    print(&#34;The file already exists and you didn&#39;t ask to overwrite it. I don&#39;t save the file.&#34;)          
                return CohIrradiance, UncohIrradiance, VisObj, BaseNorms, TelNames
    
        filedir = &#39;/&#39;.join(savingfilepath.split(&#39;/&#39;)[:-1])+&#39;/&#39;

    
        if not os.path.exists(filedir):
            os.makedirs(filedir)
        
        
        # hdr = ArrayParams
        hdr = fits.Header()
        
        hdr[&#39;Filepath&#39;] = savingfilepath.split(&#39;/&#39;)[-1]
        hdr[&#39;ARRAY&#39;] = Obs.ArrayName
        hdr[&#39;AltAz&#39;] = Obs.AltAz
        hdr[&#39;Target&#39;] = Target.Name
        hdr[&#39;NA&#39;] = NA
        hdr[&#39;NIN&#39;] = NIN
        hdr[&#39;MINWAVE&#39;] = spectra[0]
        hdr[&#39;MAXWAVE&#39;] = spectra[-1]
        hdr[&#39;DWAVE&#39;] = spectra[1] - spectra[0]
    
        for attr in vars(Target).keys():
            if type(getattr(Target, attr)) is not dict:    
                if attr not in [&#39;Name&#39;,&#39;Filepath&#39;, &#39;Phases&#39;]:
                    hdr[attr] = getattr(Target, attr)
            else:
                for key in getattr(Target, attr).keys():
                    if key == &#39;Position&#39;:
                        hdr[f&#34;{attr}_alpha&#34;] = getattr(Target, attr)[key][0]
                        hdr[f&#34;{attr}_beta&#34;] = getattr(Target, attr)[key][1]
                    else:
                        hdr[f&#34;{attr}_{key}&#34;] = getattr(Target, attr)[key]
                    
        for attr in vars(Obs).keys():
            if isinstance(getattr(Obs, attr),
                          (str, int, float, complex, bool,
                           np.floating, np.integer, np.complexfloating,
                           np.bool_)):
                
                if attr != &#39;Filepath&#39;:
                    if attr != ArrayName:
                        hdr[attr] = getattr(Obs, attr)
                else:
                    hdr[&#39;ArrayFile&#39;] = getattr(Obs, attr).split(&#39;/&#39;)[-1]
            
        
        primary = fits.PrimaryHDU(header=hdr)
        
        im1 = fits.ImageHDU(np.real(VisObj), name=&#39;VReal&#39;)
        im2 = fits.ImageHDU(np.imag(VisObj), name=&#39;VImag&#39;)
        im3 = fits.ImageHDU(np.real(CohIrradiance), name=&#39;CfReal&#39;)
        im4 = fits.ImageHDU(np.imag(CohIrradiance), name=&#39;CfImag&#39;)
        im5 = fits.ImageHDU(CPObj, name=&#39;Closure Phase&#39;)
        
        col1 = fits.Column(name=&#39;WLsampling&#39;, format=&#39;1D&#39;, array=spectra)
        hdu1 = fits.BinTableHDU.from_columns([col1], name=&#39;spectra&#39; )
        
        hdu = fits.HDUList([primary,hdu1,im1,im2,im3,im4,im5])
        
        if verbose:
            print(f&#39;Saving file into {savingfilepath}&#39;)
        hdu.writeto(savingfilepath)
    
    return CohIrradiance, UncohIrradiance, VisObj, BaseNorms, TelNames

def create_CfObj(spectra,Obs,Target,InterfArray,R=140):
    &#34;&#34;&#34;
    Returns the coherent flux (photometries and mutual intensities) of the
    object along the given spectra for the given interferometric array.

    Parameters
    ----------
    spectra : ARRAY
        Spectral sampling.
    Obs : OBS CLASS OBJECT
        Contains information on the object position in the sky.
    Target : TARGET CLASS OBJECT
        Contains information on the target geometry, magnitude, etc...
    InterfArray : INTERFARRAY CLASS OBJECT
        Contains information on the interferometer geometry, transmission, etc...

    Returns
    -------
    CoherentFluxObject : ARRAY [MW,NB]
        Coherent flux sorted like follows:
            - 0 ... NA: photometries
            - NA ... NA+NIN: Real(Cf)
            - NA ... NIN:NB: Imag(Cf)

    &#34;&#34;&#34;
    
    MeanWavelength = np.mean(spectra)
    if hasattr(spectra, &#34;__len__&#34;):
        MW=len(spectra)
        MultiWavelength=True
    else:
        MultiWavelength=False
        spectra=np.array([spectra])
        MW=1

    
    VisObject, _,_,_=VanCittert(spectra,Obs,Target)
    mag = Target.Star1[&#39;SImag&#39;]
    # Luminance according to apparent magnitude
    Irradiance = np.ones_like(spectra)
    L0_ph = 702e8        # Photons.m-2.s-1.µm-1 at 0.7µm
    Lph_H = L0_ph*10**(-0.4*mag)
    
    if MultiWavelength:
        delta_wav = np.abs(spectra[0]-spectra[1])
    else:
        delta_wav = MeanWavelength/R
        
    UncohIrradiance = Irradiance*Lph_H*delta_wav             # [phot/m²/deltalmbda/s] Source Irradiance 

    Throughput = InterfArray.TelSurfaces*InterfArray.TelTransmissions
    
    NA=len(Throughput)
    NB=NA**2 ; NIN = int(NA*(NA-1)/2)
    
    CoherentFluxObject = np.zeros([MW,NB])
    for ia in range(NA):
        CoherentFluxObject[:,ia] = Throughput[ia]*UncohIrradiance
    
    for ia in range(NA):
        for iap in range(ia+1,NA):
            ib = posk(ia,iap,NA)
            CoherentFluxObject[:,NA+ib] = np.sqrt(CoherentFluxObject[:,ia]*CoherentFluxObject[:,iap])*np.real(VisObject[:,ib])
            CoherentFluxObject[:,NA+NIN+ib] = np.sqrt(CoherentFluxObject[:,ia]*CoherentFluxObject[:,iap])*np.imag(VisObject[:,ib])

    return CoherentFluxObject

def get_ObsInformation(ObservationFile,verbose=False):
    
    from .config import ScienceObject, Observation
    from astropy.io import fits
    
    if not os.path.exists(ObservationFile):
        try:
            if verbose:
                print(&#34;Looking for the observation file into the package&#39;s data&#34;)
            ObservationFile = pkg_resources.resource_stream(__name__, ObservationFile)
        except:
            raise Exception(f&#34;{ObservationFile} doesn&#39;t exist.&#34;)
            
    hdul = fits.open(ObservationFile)
    hdr=hdul[&#39;PRIMARY&#39;].header
    
    Target = ScienceObject()
    Obs = Observation()
    
    Objects = list(dict.fromkeys([x[4] for x in hdr.keys() if &#39;Star&#39; in x]))
    for No in Objects:
        currentobject = f&#34;Star{No}&#34;
        attributes = [x.split(&#39;_&#39;)[1] for x in hdr.keys() if currentobject in x]
        StarCharacteristics={}
        for attr in attributes:
            if attr==&#39;alpha&#39;:
                if &#39;Position&#39; not in StarCharacteristics.keys():
                    StarCharacteristics[&#39;Position&#39;]=[0,0]
                StarCharacteristics[&#39;Position&#39;][0]=hdr[currentobject+f&#34;_{attr}&#34;]
            elif attr==&#39;beta&#39;:
                if &#39;Position&#39; not in StarCharacteristics.keys():
                    StarCharacteristics[&#39;Position&#39;]=(0,0)
                StarCharacteristics[&#39;Position&#39;][1]=hdr[currentobject+f&#34;_{attr}&#34;]
            else:
                StarCharacteristics[attr]=hdr[currentobject+f&#34;_{attr}&#34;]
                #setattr(dico,attr,hdr[currentobject+f&#34;_{attr}&#34;])
        setattr(Target, f&#34;Star{No}&#34;,StarCharacteristics)
    
    Target.Name = hdr[&#39;TARGET&#39;]
    Obs.ArrayName = hdr[&#39;ARRAY&#39;]
    Obs.Filepath = hdr[&#39;Filepath&#39;]
    for key,val in hdr.items():
        if key not in [&#39;TARGET&#39;,&#39;ARRAY&#39;]:
            setattr(Obs,key,val)   
        
    return Obs, Target


def get_CfObj(filepath, spectra,verbose=False):
    &#34;&#34;&#34;
    Reads data of an observation contained in a FITSfile.
    Adapt the spectral sampling to the FS spectral sampling.
    The coherent and uncoherent flux are given in Photons/µm/second at 
    the entrance of the fringe-sensor
    Return the interpolated coherent flux.

    Parameters
    ----------
    filepath : STRING
        Filepath of the file that contains target information.
    spectra : LIST or ARRAY
        Spectral sampling of the output data (for interpolation).

    Returns
    -------
    FinalCoherentIrradiance, FinalComplexVisObj, ClosurePhase
    
    FinalCoherentIrradiance : ARRAY[NW,NB]
        Coherence Flux of the object in photons/s.
        
    FinalComplexVisObj:
        Complex degree of mutual coherence. (between 0 and 1)
        
    ClosurePhase : ARRAY[NW,NC]
        Closure phases of the object in radian.
    &#34;&#34;&#34;

    fileexists = os.path.exists(filepath)
    if not fileexists:
        try:
            if verbose:
                print(&#34;Looking for the observation file into the package&#39;s data&#34;)
            filepath = pkg_resources.resource_stream(__name__,filepath)
        except:
            raise Exception(f&#34;{filepath} doesn&#39;t exists.&#34;)          
            
    with fits.open(filepath) as hdu:

        ObsParams = hdu[0].header
        WLsampling = hdu[&#39;SPECTRA&#39;].data[&#39;WLsampling&#39;]
        
        realV = hdu[&#39;VReal&#39;].data
        imagV = hdu[&#39;VImag&#39;].data
        
        realCf = hdu[&#39;CfReal&#39;].data
        imagCf = hdu[&#39;CfImag&#39;].data


    f = interpolate.interp1d(WLsampling, realCf, axis=0)
    NewRealCf = f(spectra)
    f = interpolate.interp1d(WLsampling, imagCf, axis=0)
    NewImagCf = f(spectra)
    NewImagCf[np.abs(NewImagCf)&lt;np.abs(NewRealCf)*1e-6]=0
    CoherentIrradiance = NewRealCf + NewImagCf*1j
    
    f = interpolate.interp1d(WLsampling, realV, axis=0)
    NewRealV = f(spectra)
    f = interpolate.interp1d(WLsampling, imagV, axis=0)
    NewImagV = f(spectra)
    NewImagV[np.abs(NewImagV)&lt;np.abs(NewRealV)*1e-6]=0
    ComplexVisObj = NewRealV + NewImagV*1j
    
    if isinstance(spectra,float):
        NW=1
        NBfile=len(CoherentIrradiance)
    else:
        NW, NBfile = CoherentIrradiance.shape
    NAfile = int(np.sqrt(NBfile))

    from .config import NA, NB, NC
    
    if NW!=1:
        ClosurePhase = np.zeros([NW,NC])
        FinalCoherentIrradiance = np.zeros([NW,NB])*1j
        FinalComplexVisObj = np.zeros([NW,NB])*1j

        for ia in range(NA):
            for iap in range(NA):
                ib = ia*NA+iap                    
                FinalCoherentIrradiance[:,ib] = CoherentIrradiance[:,ia*NAfile+iap]
                FinalComplexVisObj[:,ib] = ComplexVisObj[:,ia*NAfile+iap]
                
    else:
        ClosurePhase = np.zeros([NC])
        FinalCoherentIrradiance = np.zeros([NB])*1j
        FinalComplexVisObj = np.zeros([NB])*1j
        for ia in range(NA):
            for iap in range(NA):
                ib = ia*NA+iap
                FinalCoherentIrradiance[ib] = CoherentIrradiance[ia*NAfile+iap]
                FinalComplexVisObj[ib] = ComplexVisObj[ia*NAfile+iap]
                
                        
    if NA &lt; 3:
        return FinalCoherentIrradiance, FinalComplexVisObj
    
    else:
        if NW!=1:
            for ia in range(NA):
                for iap in range(ia+1,NA):
                    for iapp in range(iap+1,NA):
                        ic = poskfai(ia,iap,iapp,NA)
                        ci1 = CoherentIrradiance[:,ia*NAfile+iap]
                        ci2 = CoherentIrradiance[:,iap*NAfile+iapp]
                        ci3 = CoherentIrradiance[:,iapp*NAfile+ia]
                        ClosurePhase[:,ic] = np.angle(ci1*ci2*ci3)
        else:
            for ia in range(NA):
                for iap in range(ia+1,NA):
                    for iapp in range(iap+1,NA):
                        ic = poskfai(ia,iap,iapp,NA)
                        ci1 = CoherentIrradiance[ia*NAfile+iap]
                        ci2 = CoherentIrradiance[iap*NAfile+iapp]
                        ci3 = CoherentIrradiance[iapp*NAfile+ia]
                        ClosurePhase[ic] = np.angle(ci1*ci2*ci3)
        
    return FinalCoherentIrradiance, FinalComplexVisObj, ClosurePhase


def get_infos(file,verbose=False):
    
    if not os.path.exists(file):
        try:
            if verbose:
                print(&#34;Looking for the disturbance file into the package&#39;s data&#34;)
            file = pkg_resources.resource_stream(__name__,file)
        except:
            raise Exception(f&#34;{file} doesn&#39;t exist.&#34;)
    
    with fits.open(file) as hdu:
        hdr = hdu[0].header
        dt = hdr[&#39;DT&#39;]
        NT = hdr[&#39;NT&#39;]
        piston = hdu[&#39;Piston&#39;].data
        transmission = hdu[&#39;transmission&#39;].data
        filetimestamps = np.arange(NT)*dt
        filelmbdas = hdu[&#39;LambdaSampling&#39;].data[&#39;lambdas&#39;]
        try:
            PSD = hdu[&#39;Last tel PSD&#39;].data
            Filter = hdu[&#39;Disturbance Filter&#39;].data
            
            df = hdr[&#39;df&#39;]
            NF = len(PSD)
            FreqSampling = np.arange(NF)*df
            
        except:
            FreqSampling = np.zeros(NT); PSD = np.zeros(NT); Filter = np.zeros(NT)

    return filetimestamps,filelmbdas, piston, transmission, FreqSampling, PSD, Filter,hdr
    
    
def get_CfDisturbance(DisturbanceFile, spectra, timestamps,verbose=False):
    
    from .config import piston_average,NA,NB
    NT = len(timestamps) ; NW = len(spectra)
    
    if &#39;fits&#39; not in DisturbanceFile:
        if DisturbanceFile == &#39;NoDisturbance&#39;:
            PistonDisturbance = np.zeros([NT,NA])
            TransmissionDisturbance = np.ones([NT,NW,NA])
            
        elif DisturbanceFile == &#39;Foreground&#39;:
            Lc = config.FS[&#39;R&#39;]*config.PDspectra
            PistonDisturbance = np.zeros([NT,NA])
            for ia in range(NA):  # décoherencing of all telescopes
                PistonDisturbance[:,ia]=(ia-2)*2*Lc
            TransmissionDisturbance = np.ones([NT,NW,NA])
            
        elif DisturbanceFile == &#39;CophasedThenForeground&#39;:
            Lc = config.FS[&#39;R&#39;]*config.PDspectra
            PistonDisturbance = np.zeros([NT,NA])
            for ia in range(NA):  # décoherencing of all telescopes from it=100.
                PistonDisturbance[100:,ia]=(ia-2)*2*Lc
            TransmissionDisturbance = np.ones([NT,NW,NA])
    
        else:
            raise Exception(&#34;DisturbanceFile doesn&#39;t correspond to any valid case.&#34;)
    
    else:
        filetimestamps, filespectra, PistonDisturbance, TransmissionDisturbance,_,_,_,_ = get_infos(DisturbanceFile)
    
        PistonDisturbance = PistonDisturbance[:,:NA]
        TransmissionDisturbance = TransmissionDisturbance[:,:,:NA]
    
        # Interpolate on the time axis   
        newobservables = []
        for observable in [PistonDisturbance, TransmissionDisturbance]:
            f = interpolate.interp1d(filetimestamps,observable, axis=0, bounds_error=False, fill_value=(observable[0],observable[-1]))
            newobservables.append(f(timestamps))
            
        
        PistonDisturbance, TempTransmissionDisturbance = newobservables
        
        # Interpolate transmission on the spectral axis (Piston is not chromatic)    
        f = interpolate.interp1d(filespectra*1e6,TempTransmissionDisturbance, axis=1, bounds_error=False,fill_value=(TempTransmissionDisturbance[:,0,:],TempTransmissionDisturbance[:,-1,:]))
        TransmissionDisturbance = np.abs(f(spectra))

    if piston_average==1:
        if verbose:
            print(&#34;We subtract to the piston of each telescope its first value&#34;)
        PistonDisturbance = PistonDisturbance-PistonDisturbance[0]
    if piston_average==2:
        if verbose:
            print(&#34;We subtract the average of first piston to the piston of all telescopes.&#34;)
        PistonDisturbance = PistonDisturbance-np.mean(PistonDisturbance[0])
    elif piston_average==3:
        if verbose:
            print(&#34;We subtract to the piston of each telescope its temporal average.&#34;)
        PistonDisturbance = PistonDisturbance-np.mean(PistonDisturbance, axis=0)
        
    CfDisturbance = np.zeros([NT,NW,NB])*1j
    from cophasing import skeleton
    for it in range(NT):
        CfDisturbance[it,:,:] = skeleton.coh__pis2coh(PistonDisturbance[it,:], 1/spectra, ampl=np.sqrt(TransmissionDisturbance[it,:]))


    return CfDisturbance, PistonDisturbance, TransmissionDisturbance
    

def get_subarray(pup_used, dsp_all, TelNames, base):
    &#34;&#34;&#34;
    From the visibility matrix of the whole array (dependant on the object),
    returns the visibility matrix of the array made of the given pupils.

    Parameters
    ----------
    pup_used : string LIST [NA]
        Names of the pupils of the subarray.
    dsp_all : float [NW,NA0**2]
        The visibility matrix of the whole array.
    TelNames : string LIST [NA0]
        Names of the pupils composing the whole array.

    Returns
    -------
    dsp : float [NW,NA**2]
        The visibility matrix of the whole array.
    base : string list [NA**2]
        Base names of the subarray.

    &#34;&#34;&#34;
    
    NA = len(pup_used)
    NA0 = len(TelNames)
    NW = np.shape(dsp_all)[0]
    dsp = np.zeros([NW,NA**2])
    tmp = base
    base=[]
    for ia in range(NA):
        a = TelNames.index(pup_used[ia])
        # dsp[:,ia*(NA+1)] = dsp_all[:,a*(NA0+1)]
        # base.append(tmp[a*(NA0+1)])
        for iap in range(NA):
            k = ia*NA+iap
            ap = TelNames.index(pup_used[iap])
            kp = a*NA0+ap
            dsp[:,k] = dsp_all[:,kp]
            base.append(tmp[kp])
    # import pdb; pdb.set_trace()
   
    return dsp, base, NA
    

def generate_spectra0(lmbda1,lmbda2,R, sampling=&#39;linearsig&#39;):
    &#34;&#34;&#34;
    Generates a spectra of a grism of resolution R linearly spaced on wavenumbers
    or wavelength

    Parameters
    ----------
    lmbda1 : float
        Minimal wavelength.
    lmbda2 : float
        Maximal wavelength.
    R : int
        Spectral resolution.
    sampling : TYPE, optional
        Method of sampling. The default is &#39;linearsig&#39;.
        OPTIONS:
            - &#39;linearsig&#39;: linear in wavenumbers [advised]
            - &#39;linearlambda&#39;: linear in wavelengths

    Returns
    -------
    spectra : ARRAY 1D
        Ascending order.
    sigma : ARRAY 1D
        Descending order.

    &#34;&#34;&#34;
    
    if sampling == &#39;linearsig&#39;:
        sigma1 = 1/lmbda2
        sigma2 = 1/lmbda1
        deltasig = np.min([sigma1,sigma2])/R
        sigma = np.arange(sigma1,sigma2,deltasig)
        sigma = np.sort(sigma)[::-1]
        spectra = 1/sigma
        
    elif sampling == &#39;linearlambda&#39;:
        deltalmbda = np.min([lmbda1,lmbda2])/R
        spectra = np.arange(lmbda1, lmbda2, deltalmbda)
        sigma = 1/spectra
        
    return spectra, sigma


def generate_spectra(lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode=&#39;linear_sig&#39;):
    &#34;&#34;&#34;
    Returns the micro and macro wavenumbers to use for the simulation

    Parameters
    ----------
    sigma : vector [MW]
        Wavenumbers
    OW : int
        Oversampling wavenumbers.
    sigmaband : vector [MW], optional
        Channel bandwidth
    mode : string, optional
        Way of generating the spectras. The default is &#39;regular&#39;.

    Raises
    ------
    ValueError
        Mode needs to be in acceptable values.

    Returns
    -------
    sigma : [MW*OW] floats
        Micro Wavenumbers.
    sigmaM : [MW] floats
        Macro wavenumbers.

    &#34;&#34;&#34;
    possible_modes = [&#39;linear_wl&#39;,&#39;linear_sig&#39;]
    
    if R:
        if MW:
            raise Exception(&#34;MW can&#39;t be given with R.&#34;)
        deltalmbda = np.mean([lmbda1,lmbda2])/R
        MW = int(round((lmbda2-lmbda1)/deltalmbda))
        
    elif not MW:
        raise Exception(&#34;MW or R must be given.&#34;)
    
    if mode == &#39;linear_sig&#39;:
        sig1, sig2 = np.min([1/lmbda1,1/lmbda2]), np.max([1/lmbda1,1/lmbda2])
        sigma = np.linspace(sig1, sig2, MW)
        spectra = np.sort(1/sigma)

        deltasig = sigma[1] - sigma[0]
        # sigmaband = spectraband*spectra**(-2)
        
        sigma_os = np.array([])
        for i in range(MW):
            sigbottom = sigma[i]-deltasig/2
            sigtop = sigma[i]+deltasig/2
            sigma_temp = np.linspace(sigbottom, sigtop, OW+1)[1:]
            sigma_os = np.concatenate((sigma_os,sigma_temp))
        spectra_os = np.sort(1/sigma_os)
        
    elif mode == &#39;linear_wl&#39;:
        spectra_os = np.array([])
        spectra = np.linspace(lmbda1, lmbda2, MW)
        deltalmbda = spectra[1] - spectra[0]
        for i in range(MW):
            wlbottom = spectra[i]-deltalmbda/2
            wltop = spectra[i]+deltalmbda/2
            spectra_temp = np.linspace(wlbottom, wltop, OW+1)[1:]
            spectra_os = np.concatenate((spectra_os,spectra_temp))
    
    else:
        raise ValueError(f&#39;mode={mode}. Unknown mode, needs to be in {possible_modes}.&#39;)
    
    return spectra_os, spectra


def oversample_wv(spectra, OW, spectraband=[], mode=&#39;linear_sig&#39;):

# def oversample_wv(lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode=&#39;linear_sig&#39;):
    &#34;&#34;&#34;
    Returns the micro and macro wavenumbers to use for the simulation

    Parameters
    ----------
    spectra : vector [MW]
        Wavelengths
    OW : int
        Oversampling wavenumbers.
    spectraband : vector [MW], optional
        Channel bandwidth
    mode : string, optional
        Way of generating the spectras. The default is &#39;linear_sig&#39;.

    Raises
    ------
    ValueError
        Mode needs to be in acceptable values.

    Returns
    -------
    spectra_os : [MW*OW] floats
        Oversampled micro Wavelengths.
    spectra : [MW] floats
        Macro Wavelengths.

    &#34;&#34;&#34;
    possible_modes = [&#39;linear_wl&#39;,&#39;linear_sig&#39;]
    
    
    MW = len(spectra)
    
    spectra = np.sort(spectra)
    sigma = np.sort(1/spectra)
    
    
    if len(spectraband)==0:
        spectraband = np.zeros_like(spectra)
        sigmaband = np.zeros_like(spectra)
        for i in range(1,MW):
            spectraband[i] = spectra[i] - spectra[i-1]
            sigmaband[i] = sigma[i] - sigma[i-1]
        spectraband[0] = spectraband[1]
        sigmaband[0] = sigmaband[1]
    
    if mode == &#39;linear_sig&#39;:
        sigma = np.sort(1/spectra)
        sigmaband = spectraband*spectra**(-2)
        
        sigma_os = np.array([])
        for i in range(MW):
            sigbottom = sigma[i]-sigmaband[i]/2
            sigtop = sigma[i]+sigmaband[i]/2
            sigma_temp = np.linspace(sigbottom, sigtop, OW)
            sigma_os = np.concatenate((sigma_os,sigma_temp))
        spectra_os = np.sort(1/sigma_os)
        
    elif mode == &#39;linear_wl&#39;:
        spectra_os = np.array([])
        for i in range(MW):
            wlbottom = spectra[i]-spectraband[i]/2
            wltop = spectra[i]+spectraband[i]/2
            spectra_temp = np.linspace(wlbottom, wltop, OW)
            spectra_os = np.concatenate((spectra_os,spectra_temp))
    
    else:
        raise ValueError(f&#39;mode={mode}. Unknown mode, needs to be in {possible_modes}.&#39;)
    
    return spectra_os, spectra



def coh__GRAV2simu(gravmatrix):
    &#34;&#34;&#34;
    Adapt the GRAVITY&#39;s matrix formalism in the simulator one

    Parameters
    ----------
    matrix : TYPE
        DESCRIPTION.

    Returns
    -------
    simuV2PM : TYPE
        DESCRIPTION.
    simuP2VM : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;    
    shape = np.shape(gravmatrix)
    
    if len(shape)==3:    # It&#39;s a V2PM
        (NW,NP,NB) = shape
        simuV2PM = np.zeros([NW,NP,NB])*1j
        simuP2VM = np.zeros([NW,NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            simuV2PM[:,:,ksim] = gravmatrix[:,:,ia]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1

                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)
                Real = gravmatrix[:,:,k]
                k = int(NA*(NA+1)/2 + kp)
                Imag = gravmatrix[:,:,k]
                
                # Direct and Conjugate coherence vectors
                ksim = ia*NA+iap
                simuV2PM[:,:,ksim] = 1/2*(Real + Imag*1j)
                ksim = iap*NA+ia          # 
                simuV2PM[:,:,ksim] = 1/2*(Real - Imag*1j)
        
        for iw in range(NW):
            simuP2VM[iw,:,:] = np.linalg.pinv(simuV2PM[iw,:,:])
        
    else:
        (NP,NB) = shape
        simuV2PM = np.zeros([NP,NB])*1j
        simuP2VM = np.zeros([NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            simuV2PM[:,ksim] = gravmatrix[:,ia]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1

                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)
                Real = gravmatrix[:,k]
                k = int(NA*(NA+1)/2 + kp)
                Imag = gravmatrix[:,k]
                
                # Direct and Conjugate coherence vectors
                ksim = ia*NA+iap
                simuV2PM[:,ksim] = 1/2*(Real + Imag*1j)
                ksim = iap*NA+ia          # 
                simuV2PM[:,ksim] = 1/2*(Real - Imag*1j)
        
        simuP2VM = np.linalg.pinv(simuV2PM)
        
    return simuV2PM, simuP2VM



def simu2GRAV(simumatrix, direction=&#39;v2pm&#39;):
    
    Ndim = np.ndim(simumatrix)
    
    if direction==&#39;p2vm&#39;:
        # Invert the second and third axis: for having the same code for both situations
        if Ndim==2:
            simumatrix = np.transpose(simumatrix)
        elif Ndim ==3:
            simumatrix = np.transpose(simumatrix, [0,2,1])  
        
    shape = np.shape(simumatrix)    
    
    if Ndim==3:    # There&#39;s several wavelengths
        NW,NP,NB = shape
        GRAVmatrix = np.zeros([NW,NP,NB])
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            GRAVmatrix[:,:,ia] = np.real(simumatrix[:,:,ksim])
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1
                
                # Direct and Conjugate coherence vectors
                direct = simumatrix[:,:,ia*NA+iap]
                # conj = simumatrix[:,:,iap*NA+ia]
                
                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)                    # Real part location
                GRAVmatrix[:,:,k] = np.real(direct)
                k = int(NA*(NA+1)/2 + kp)           # Imaginary part location
                GRAVmatrix[:,:,k] = np.imag(direct)
        
    else:        # Ndim == 2
        NP,NB = shape
        GRAVmatrix = np.zeros([NP,NB])
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            GRAVmatrix[:,ia] = np.real(simumatrix[:,ksim])
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1
                
                # Direct and Conjugate coherence vectors
                direct = simumatrix[:,ia*NA+iap]
                # conj = simumatrix[:,iap*NA+ia]
                
                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)                    # Real part location
                GRAVmatrix[:,k] = np.real(direct)
                k = int(NA*(NA+1)/2 + kp)           # Imaginary part location
                GRAVmatrix[:,k] = np.imag(direct)
            
    if direction==&#39;p2vm&#39;:
        # Put back the axis at the right locations
        if Ndim==2:
            GRAVmatrix = np.transpose(GRAVmatrix)
        elif Ndim ==3:
            GRAVmatrix = np.transpose(GRAVmatrix, [0,2,1]) 
        
    return GRAVmatrix


def sortmatrix(matrix,ich,ABCDindex,direction=&#39;v2pm&#39;):
    &#34;&#34;&#34;
    From the known sorting of the baselines and modulations, reorder the pixels
    to get the conventional ordering: 12, 13, ...,23, ...,46,56

    Parameters
    ----------
    matrix : [NW,NP,NB] or [NW,NB,NP] ARRAY
        V2PM or P2VM.
    ich : [NINx2] INT ARRAY
        INterferometric channels.
    ABCDindex : [Nmod] INT ARRAY
        Positions of the ABCD modulations. 
        For example, if BDAC then ABCDindex=[2,0,3,1]
    direction : STRING, optional
        v2pm or p2vm. The default is &#39;v2pm&#39;.

    Returns
    -------
    matrix_sorted : FLOAT ARRAY
        Same size as matrix, but reordered.

    &#34;&#34;&#34;
    if direction==&#39;v2pm&#39;:
        NW,NP,NB=np.shape(matrix)
    else:
        NW,NB,NP = np.shape(matrix)
        
    NA=int(np.sqrt(NB))
    Nmod=len(ABCDindex) ; NIN = len(ich)
    baseline_sorted = np.zeros_like(matrix)
    
    if np.ndim(ich) == 1:
        ichtemp = ich
        ich = np.zeros([len(ich), 2])
        for ib in range(len(ichtemp)):
            ich[ib] = [char for char in str(ichtemp[ib])]
    
    for ib in range(NIN):
        # Sort the positions in the conventional order
        detectorpositions = range(ib*Nmod,(ib+1)*Nmod)
        ia, iap = ich[ib]-1
        ibn = posk(ia,iap,NA)
        conventionalpositions = range(ibn*Nmod,(ibn+1)*Nmod)
        
        if direction==&#39;v2pm&#39;:
            baseline_sorted[:,conventionalpositions,:] = matrix[:,detectorpositions,:]
        else:
            baseline_sorted[:,:,conventionalpositions] = matrix[:,:,detectorpositions]
        
    matrix_sorted = np.zeros_like(matrix)
    
    # Sort the ABCD modulations
    for ib in range(NIN):
        for k in range(Nmod):
            if direction==&#39;v2pm&#39;:
                matrix_sorted[:,ib*Nmod+k,:] = baseline_sorted[:,ib*Nmod+ABCDindex[k],:]
            else:
                matrix_sorted[:,:,ib*Nmod+k] = baseline_sorted[:,:,ib*Nmod+ABCDindex[k]]

    return matrix_sorted

def studyP2VM(*args,savedir=&#39;&#39;,ext=&#39;pdf&#39;,nfig=0):
    &#34;&#34;&#34;
    Show the V2PM and the V2PM with grids that enable to see clearly the baselines

    Parameters
    ----------
    nfig : TYPE, optional
        DESCRIPTION. The default is 0.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    # Load data
    v2pm = config.FS[&#39;V2PMgrav&#39;]
    p2vm = config.FS[&#39;P2VMgrav&#39;]
    
    NW,NP,NB = np.shape(v2pm)
    NA = int(np.sqrt(NB))
    NIN = NA*(NA-1)//2
    ich=config.FS[&#39;ich&#39;]
    
    if &#39;NMod&#39; in config.FS.keys():
        pairwise=True
        Modulation = config.FS[&#39;Modulation&#39;]
        ABCDindex = config.FS[&#39;ABCDind&#39;]
        Nmod=config.FS[&#39;NMod&#39;]
        v2pm_sorted = sortmatrix(v2pm, ich, ABCDindex)
        p2vm_sorted = sortmatrix(p2vm, ich, ABCDindex, direction=&#39;p2vm&#39;)
    else:
        pairwise=False
        v2pm_sorted = np.copy(v2pm)
        p2vm_sorted = np.copy(p2vm)
    
    conventionalorder=[]
    for ia in range(1,NA+1):
        for iap in range(ia+1,NA+1):
            conventionalorder.append(f&#34;{ia}{iap}&#34;)
    
    
    &#34;&#34;&#34;Photometries and phaseshifts&#34;&#34;&#34;
    if pairwise:
        photometries = np.zeros([NW,NIN,Nmod,2])
        phases = np.zeros([NW,NIN,Nmod]) ; normphasors = np.zeros([NW,NIN,Nmod])
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib=posk(ia,iap,NA)
                for k in range(Nmod):
                    photometries[:,ib,k,0] = v2pm_sorted[:,Nmod*ib+k,ia]*100
                    photometries[:,ib,k,1] = v2pm_sorted[:,Nmod*ib+k,iap]*100
                    R = v2pm_sorted[:,Nmod*ib+k,NA+ib] ; I = v2pm_sorted[:,Nmod*ib+k,NA+NIN+ib] 
                    phases[:,ib,k] = np.arctan2(I,R) ; normphasors[:,ib,k] = np.sqrt(R**2+I**2)
        
        ModuleCoherentFlux = normphasors/2
    
    
    &#34;&#34;&#34; Noise propagation&#34;&#34;&#34;
    photons = 1e3
    # Coherent vector of a perfectly coherent pair of fields.
    CoherentFlux = np.zeros([NW,NB])
    CoherentFlux[:,:NA+NIN]=photons # In Cassaing formalism: N=photons ; C=photons ; S=0
    
    DetectionCoherent = np.zeros([NW,NP])
    for iw in range(NW):
        DetectionCoherent[iw] = np.dot(v2pm_sorted[iw], CoherentFlux[iw])
    
    QuadratureCoherentFlux = np.zeros([NW,NB])
    QuadratureCoherentFlux[:,:NA] = photons
    QuadratureCoherentFlux[:,NA+NIN:] = photons # In Cassaing formalism: N=photons ; C=0 ; S=photons
    
    DetectionQuadrature = np.zeros([NW,NP])
    for iw in range(NW):
        DetectionQuadrature[iw] = np.dot(v2pm_sorted[iw], QuadratureCoherentFlux[iw])
    
    # Covariance matrix
    CovMatrixCoherent = np.zeros([NW,NB,NB])
    CovMatrixQuadrature = np.zeros([NW,NB,NB])
    
    for iw in range(NW):
        CovMatrixCoherent[iw] = np.dot(p2vm_sorted[iw], np.dot(np.diag(DetectionCoherent[iw]),np.transpose(p2vm_sorted[iw])))
        CovMatrixQuadrature[iw] = np.dot(p2vm_sorted[iw], np.dot(np.diag(DetectionQuadrature[iw]),np.transpose(p2vm_sorted[iw])))
            
    if pairwise:
        dico = {&#39;v2pm_sorted&#39;:v2pm_sorted, 
                &#39;p2vm_sorted&#39;:p2vm_sorted, 
                &#39;photometries&#39;:photometries, 
                &#39;phases&#39;:phases,
                &#39;CovMatrixCoherent&#39;:CovMatrixCoherent, 
                &#39;CovMatrixQuadrature&#39;:CovMatrixQuadrature}
    else:
        dico = {&#39;v2pm_sorted&#39;:v2pm_sorted, 
                &#39;p2vm_sorted&#39;:p2vm_sorted,
                &#39;CovMatrixCoherent&#39;:CovMatrixCoherent, 
                &#39;CovMatrixQuadrature&#39;:CovMatrixQuadrature}
        
    
    if (&#39;p2vm&#39; in args) or (&#39;displayall&#39; in args):
        mod = v2pm_sorted[0]
        
        newfig=nfig
        fig = plt.figure(&#39;V2PM &amp; P2VM&#39;,clear=True)
        fig.suptitle(&#34;V2PM and P2VM&#34;)
        
        ax1,ax2 = fig.subplots(ncols=2)
        ax1.set_title(&#34;V2PM&#34;)
        ax2.set_title(&#34;P2VM&#34;)
        
        &#34;&#34;&#34;Show the V2PM matrix&#34;&#34;&#34;
        
        ax1.imshow(mod)
        
        xticks=[] ; xticklabels=[]
        xticks.append(NA//2-1) ; xticklabels.append(&#39;Photometries&#39;)
        x = NA-0.5 ; xticks.append(NA+NIN//2-1) ; xticklabels.append(&#39;Real parts&#39;)
        ax1.axvline(x = x, color = &#39;w&#39;, linestyle = &#39;-&#39;)
        x = NA+NIN-0.5 ; xticks.append(NA+3*NIN//2-1) ; xticklabels.append(&#39;Imaginary parts&#39;)
        ax1.axvline(x = NA+NIN-0.5, color = &#39;w&#39;, linestyle = &#39;-&#39;)
    
        for ia in range(1,NA-1):
            ib = posk(ia,ia+1,NA)
            ax1.axvline(x = x, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax1.axvline(x = x, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
        
        if pairwise:
            for ib in range(NIN):
                ax1.axhline(y = ib*Nmod-0.5, color = &#39;w&#39;, linestyle = &#39;-&#39;)
            
            ax1.set_yticks(np.arange(NIN)*Nmod+Nmod//2-.5)
            ax1.set_yticklabels(conventionalorder)
            ax1.set_ylabel(&#39;Pixels sorted in ABCD&#39;)
            
            
        else:
            ax1.axhline(y = NA, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            
            ax1.set_yticks([NA//2, (NA+NP)//2])
            ax1.set_yticklabels([&#39;Photometries&#39;, &#39;Interferogram&#39;])
            
        
        ax1.set_xlabel(&#34;Coherent flux&#34;)
        ax1.set_xticks(xticks)
        ax1.set_xticklabels(xticklabels, rotation=45)
        ax1.xaxis.set_ticks_position(&#39;none&#39;)
    
    
        &#34;&#34;&#34; Show the P2VM &#34;&#34;&#34;
    
        demod = p2vm_sorted[0]
        
        ax2.imshow(demod)
        
        # Create a Rectangle patch
        # rect = Rectangle((-0.5,11.5),1,1,linewidth=1,edgecolor=&#39;r&#39;,facecolor=&#39;none&#39;)
        yticks=[] ; yticklabels=[]
        yticks=[] ; yticklabels=[]
        yticks.append(NA//2) ; yticklabels.append(&#39;Photometries&#39;)
        y = NA-0.5 ; yticks.append(y) ; yticklabels.append(&#39;Real parts&#39;)
        ax2.axhline(y = y, color = &#39;w&#39;, linestyle = &#39;-&#39;)
        y = NA+0.5 ; yticks.append(y) ; yticklabels.append(&#39;B1#&#39;)
        y = NA+NIN-0.5 ; yticks.append(y) ; yticklabels.append(&#39;Imaginary parts&#39;)
        ax2.axhline(y = NA+NIN-0.5, color = &#39;w&#39;, linestyle = &#39;-&#39;)
        y = NA+NIN+0.5 ; yticks.append(y) ; yticklabels.append(&#39;B1#&#39;)
        for ia in range(1,NA-1):
            ib = posk(ia,ia+1,NA)
            y = NA+ib-0.5 ; yticks.append(y+0.5) ; yticklabels.append(f&#39;B{ia+1}#&#39;)
            ax2.axhline(y = y, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            y = NA+NIN+ib-0.5 ; yticks.append(y+0.5) ; yticklabels.append(f&#39;B{ia+1}#&#39;)
            ax2.axhline(y = y, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
        
        
        if pairwise:
            for ib in range(NIN):
                ax2.axvline(x = ib*Nmod-0.5, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
                
            ax2.set_xticks(np.arange(NIN)*Nmod+Nmod//2-.5)
            ax2.set_xticklabels(conventionalorder,rotation=45)
            ax2.set_xlabel(&#39;Pixels sorted in ABCD&#39;)
            
        else:
            ax2.axvline(x = NA, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.set_xticks([NA,(NA+NP)//2])
            ax2.set_xticklabels([&#39;Photometries&#39;, &#39;Interferogram&#39;], rotation=45)
        
        ax2.yaxis.tick_right()
        ax2.set_yticks(yticks)
        ax2.set_yticklabels(yticklabels)
        ax1.yaxis.set_ticks_position(&#39;none&#39;)
        ax2.yaxis.set_ticks_position(&#39;none&#39;)
        ax1.xaxis.set_ticks_position(&#39;none&#39;)
        ax2.xaxis.set_ticks_position(&#39;none&#39;)

        ax1.grid(False)
        ax2.grid(False)
    
# =============================================================================
#     Photometry and phaseshifts repartition in the P2VM
# =============================================================================
    
    # colors = tol_cset(&#39;bright&#39;)

    # newfig+=1
    # fig=plt.figure(newfig, clear=True)
    # fig.suptitle(&#34;Photometry repartitions and phaseshift of the beams&#34;)
    # ax1,ax2,ax3,ax4 = fig.subplots(nrows=4,gridspec_kw={&#39;height_ratios&#39;: [.2,1,.2,1]})
    
    # photometries = np.zeros([NW,NIN,Nmod,2])
    # phases = np.zeros([NW,NIN,Nmod])
    # normphasors = np.zeros([NW,NIN,Nmod])
    # for ia in range(NA):
    #     for iap in range(ia+1,NA):
    #         ib=posk(ia,iap,NA)
    #         for k in range(Nmod):
    #             photometries[:,ib,k,0] = v2pm_sorted[:,4*ib+k,ia]*100
    #             photometries[:,ib,k,1] = v2pm_sorted[:,4*ib+k,iap]*100
    #             R = v2pm_sorted[:,4*ib+k,NA+ib] ; I = v2pm_sorted[:,4*ib+k,NA+NIN+ib] 
    #             phases[:,ib,k] = np.arctan2(I,R) ; normphasors = np.sqrt(R**2+I**2)
                
    # NINtemp = NIN//2+1
    # xtop = np.arange(NINtemp)  # the label locations
    # xbot = np.arange(NINtemp,NIN)
    # width=0.8
    # barwidth=width/8
    # bar_patches1=[] ; bar_patches2=[]
    # bar_patches1.append(mpatches.Patch(facecolor=&#39;gray&#39;,edgecolor=&#39;black&#39;,hatch=&#39;///&#39;,label=&#34;First beam&#34;))
    # bar_patches1.append(mpatches.Patch(facecolor=&#39;gray&#39;,edgecolor=&#39;black&#39;, label=&#34;Second beam&#34;))
    # for k in range(Nmod):
        
    #     firstbar_pos = xtop-width/2+barwidth/2
    #     rects1 = ax2.bar(firstbar_pos + 2*k*barwidth, photometries[0,:NINtemp,k,0], 
    #                      barwidth, hatch=&#39;///&#39;,color=colors[k],edgecolor=&#39;black&#39;).patches
    #     rects2 = ax2.bar(firstbar_pos + (2*k+1)*barwidth, photometries[0,:NINtemp,k,1], 
    #                      barwidth, color=colors[k],edgecolor=&#39;black&#39;).patches
    #     rects_moy1 = ax2.bar(firstbar_pos + (2*k+1/2)*barwidth, np.mean(photometries[0,:NINtemp,k,:],axis=-1), 
    #                      barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;--&#39;).patches
    #     rects3 = ax1.bar(firstbar_pos + 2*k*barwidth+barwidth/2, phases[0,:NINtemp,k], 
    #                          barwidth,color=colors[k],edgecolor=&#39;black&#39;)
    #     firstbar_pos = xbot-width/2+barwidth/2
    #     rects4 = ax4.bar(firstbar_pos + 2*k*barwidth, photometries[0,NINtemp:,k,0],
    #                      barwidth, hatch=&#39;///&#39;,color=colors[k],edgecolor=&#39;black&#39;).patches
    #     rects5 = ax4.bar(firstbar_pos + (2*k+1)*barwidth, photometries[0,NINtemp:,k,1],
    #                      barwidth,color=colors[k],edgecolor=&#39;black&#39;).patches
    #     rects_moy2 = ax4.bar(firstbar_pos + (2*k+1/2)*barwidth, np.mean(photometries[0,NINtemp:,k,:],axis=-1), 
    #                      barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;--&#39;).patches
    #     rects6 = ax3.bar(firstbar_pos + 2*k*barwidth+barwidth/2, phases[0,NINtemp:,k], 
    #                          barwidth,color=colors[k],edgecolor=&#39;black&#39;)
        
    #     # rects1 = ax2.patches[:NINtemp] ; rects2 = ax2.patches[NINtemp:2*NINtemp]
    #     # rects_moy = ax2.patches[2*NINtemp:]
        
    #     for rect1,rect2,rect_moy in zip(rects1,rects2,rects_moy1):
    #         height = np.max([rect1.get_height(),rect2.get_height(),rect_moy.get_height()])
    #         ax2.text(rect_moy.get_x() + rect_moy.get_width() / 2, height+0.1, round(height,1),
    #                 ha=&#39;center&#39;, va=&#39;bottom&#39;)
            
    #     for rect1,rect2,rect_moy in zip(rects4,rects5,rects_moy2):
    #         height = np.max([rect1.get_height(),rect2.get_height(),rect_moy.get_height()])
    #         ax4.text(rect_moy.get_x() + rect_moy.get_width() / 2, height+0.1, round(height,1),
    #                 ha=&#39;center&#39;, va=&#39;bottom&#39;)
    #         # ax4.text(rect.get_x() + rect.get_width() / 2, height + 5, height,
    #         #         ha=&#39;center&#39;, va=&#39;bottom&#39;)
            
    #     bar_patches2.append(mpatches.Patch(color=colors[k],label=&#34;ABCD&#34;[k]))
    #     # rects3 = ax1.bar(x - width/2+0.25, photometries[0,:NINtemp,0,0], barwidth, label=&#39;C&#39;,color=&#39;b&#39;)
    #     # rects4 = ax1.bar(x - width/2+0.35, photometries[0,:NINtemp,0,1], barwidth, label=&#39;D&#39;,color=&#39;g&#39;)
    
    # # ax1.bar_label(rects1)
    # # ax1.bar_label(rects2)
    # # xlim = (xtop[0]-width , xtop[-1]+width)
        
    # # ax3.plot(npxtop,0.12*np.ones_like(xtop), color=&#39;black&#39;, label=&#34;Phase&#34;)
    # # ax3.hlines(0.12, xlim[0],xlim[1], color=&#39;black&#39;, label=&#34;Phase&#34;)
    # # ax3.hlines(0.08, xlim[0],xlim[1], color=&#39;black&#39;, label=&#34;Phase&#34;)
    # # ax3.hlines(0.16, xlim[0],xlim[1], color=&#39;black&#39;, label=&#34;Phase&#34;)
    # # ax3.plot(phases[0,NINtemp:,])
    
    
    # xticklabels=[]
    # for ia in range(NA):
    #     for iap in range(ia+1,NA):
    #         xticklabels.append(f&#34;B{ia+1}{iap+1}&#34;)
    
    # ax2.set_xticks(xtop)
    # ax2.set_xticklabels(xticklabels[:NINtemp])
    
    # ax2.set_ylim(0,10)
    # ax4.set_ylim(0,10)
    
    # ax1.set_ylim(-np.pi,np.pi)
    # ax1.grid()

    # ax3.set_ylim(-np.pi,np.pi)
    # ax3.grid()
    # ax4.set_xticks(xbot)
    # ax4.set_xticklabels(xticklabels[NINtemp:])
    
    # first_legend = ax4.legend(handles=bar_patches2, loc=&#39;lower right&#39;)
    # ax4.add_artist(first_legend)
    # ax4.legend(handles=bar_patches1, loc=&#39;upper right&#39;)
    
    
    # ax1.set_ylabel(&#34;Phase [rad]&#34;)
    # ax2.set_ylabel(&#34;Transmission&#34;)
    
    # # ax4.bar_label(rects4, label_type=&#39;center&#39;)
    
    # fig.show()
    
    if (&#39;repartition&#39; in args) or (&#39;displayall&#39; in args):
        
        #plt.rcParams.update(rcParamsForBaselines)
        SS = 12     # Small size
        MS = 14     # Medium size
        BS = 16     # Big size
        figsize = (16,12)
        rcParamsForRepartitions = {&#34;font.size&#34;:SS,
                &#34;axes.titlesize&#34;:SS,
                &#34;axes.labelsize&#34;:SS,
                &#34;axes.grid&#34;:True,
               
                &#34;xtick.labelsize&#34;:SS,
                &#34;ytick.labelsize&#34;:SS,
                &#34;legend.fontsize&#34;:SS,
                &#34;figure.titlesize&#34;:BS,
                # &#34;figure.constrained_layout.use&#34;: False,
                &#34;figure.dpi&#34;:300,
                &#34;figure.figsize&#34;:figsize
                # &#39;figure.subplot.hspace&#39;: 0.05,
                # &#39;figure.subplot.wspace&#39;: 0,
                # &#39;figure.subplot.left&#39;:0.1,
                # &#39;figure.subplot.right&#39;:0.95
                }

        plt.rcParams.update(rcParamsForRepartitions)
        
        if pairwise:
            newfig+=1
            fig=plt.figure(newfig, clear=True)
            fig.suptitle(&#34;Photometry repartitions and phaseshift of the beams&#34;)
            (ax1,ax3),(ax2,ax4) = fig.subplots(nrows=2, ncols=2,gridspec_kw={&#39;width_ratios&#39;: [9,1]})
                        
            NINtemp = NIN//2+1
            xtop = np.arange(NINtemp)  # the label locations
            xbot = np.arange(NINtemp,NIN)
            
            width=0.8
            barwidth=width/8
            
            ax1_firstbar_positions = xtop-width/2+barwidth/2
            ax2_firstbar_positions = xbot-width/2+barwidth/2
            
            bar_patches1=[] ; bar_patches2=[]
            bar_patches1.append(mpatches.Patch(facecolor=&#39;gray&#39;,edgecolor=&#39;black&#39;,hatch=&#39;///&#39;,label=&#34;First beam&#34;))
            bar_patches1.append(mpatches.Patch(facecolor=&#39;gray&#39;,edgecolor=&#39;black&#39;, label=&#34;Second beam&#34;))
            
            linestyles=[]
            linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                            linestyle=&#39;--&#39;,label=&#39;Average flux&#39;))    
            linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                            linestyle=&#39;:&#39;,label=&#39;Coherent flux&#39;))
                
            for k in range(Nmod):
                
                rects1 = ax1.bar(ax1_firstbar_positions + 2*k*barwidth, photometries[0,:NINtemp,k,0], 
                                 barwidth, hatch=&#39;///&#39;,color=colors[k],edgecolor=&#39;black&#39;).patches
                rects2 = ax1.bar(ax1_firstbar_positions + (2*k+1)*barwidth, photometries[0,:NINtemp,k,1], 
                                 barwidth, color=colors[k],edgecolor=&#39;black&#39;).patches
                rects_moy1 = ax1.bar(ax1_firstbar_positions + (2*k+1/2)*barwidth, np.mean(photometries[0,:NINtemp,k,:],axis=-1), 
                                 barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;--&#39;).patches
                rects_coh1 = ax1.bar(ax1_firstbar_positions + (2*k+1/2)*barwidth, ModuleCoherentFlux[0,:NINtemp,k]*100, 
                                 barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;:&#39;).patches
                
                rects4 = ax2.bar(ax2_firstbar_positions + 2*k*barwidth, photometries[0,NINtemp:,k,0],
                                 barwidth, hatch=&#39;///&#39;,color=colors[k],edgecolor=&#39;black&#39;).patches
                rects5 = ax2.bar(ax2_firstbar_positions + (2*k+1)*barwidth, photometries[0,NINtemp:,k,1],
                                 barwidth,color=colors[k],edgecolor=&#39;black&#39;).patches
                rects_moy2 = ax2.bar(ax2_firstbar_positions + (2*k+1/2)*barwidth, np.mean(photometries[0,NINtemp:,k,:],axis=-1), 
                                 barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;--&#39;).patches
                rects_coh2 = ax2.bar(ax2_firstbar_positions + (2*k+1/2)*barwidth, ModuleCoherentFlux[0,NINtemp:,k]*100, 
                                 barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;:&#39;).patches
                
                for rect1,rect2,rect_moy in zip(rects1,rects2,rects_moy1):
                    height = np.max([rect1.get_height(),rect2.get_height(),rect_moy.get_height()])
                    # ax1.text(rect_moy.get_x() + rect_moy.get_width() / 2, height+0.1, round(height,1),
                    #         ha=&#39;center&#39;, va=&#39;bottom&#39;)
                    
                for rect1,rect2,rect_moy in zip(rects4,rects5,rects_moy2):
                    height = np.max([rect1.get_height(),rect2.get_height(),rect_moy.get_height()])
                    # ax2.text(rect_moy.get_x() + rect_moy.get_width() / 2, height+0.1, round(height,1),
                    #         ha=&#39;center&#39;, va=&#39;bottom&#39;)
                    
                bar_patches2.append(mpatches.Patch(color=colors[k],label=&#34;ABCD&#34;[k]))
            
            ax1_xmin,ax1_xmax = ax1.get_xlim() ; ax2_xmin,ax2_xmax = ax2.get_xlim()
            ax1_ymin,ax1_ymax = ax1.get_ylim() ; ax2_ymin,ax2_ymax = ax2.get_ylim()
            ax1_normalised_width = 1/(ax1_ymax-ax1_ymin)*width*.7
            ax1_normalised_height = 1/(ax1_ymax-ax1_ymin)*width
            ax2_normalised_width = 1/(ax1_ymax-ax1_ymin)*width*.7
            ax2_normalised_height = 1/(ax1_ymax-ax1_ymin)*width
            ax1_bottomleft = 1/(ax1_xmax-ax1_xmin)*(ax1_firstbar_positions+barwidth/2-ax1_xmin)
            ax2_bottomleft = 1/(ax2_xmax-ax2_xmin)*(ax2_firstbar_positions+barwidth/2-ax2_xmin)
            
            for ib in range(NINtemp):
                subpos=(ax1_bottomleft[ib],0.75,ax1_normalised_width,ax1_normalised_height)#firstbar_pos[0] + 2*k*barwidth,
                label = True if ib==0 else False
                ax=add_subplot_axes(ax1,subpos,polar=True,label=label)
                if label:
                    ax.xaxis.label.set_size(2)
                    ax.yaxis.label.set_size(2)
                ax.set_ylim(0,1)
                for k in range(Nmod):
                    phase = phases[0,ib,k] ; norm = normphasors[0,ib,k]/np.max(normphasors[0,ib,:])
                    ax.arrow(phase, 0, 0, norm, width = 0.05,
                             edgecolor=colors[k],facecolor = colors[k], lw = 2, zorder = 5,length_includes_head=True)
                    
                # ax.set_thetagrids(phases[0,ib,:]*180/np.pi,labels=np.round(phases[0,ib,:]*180/np.pi))
            for ib in range(NIN-NINtemp):
                subpos=(ax2_bottomleft[ib],0.75,ax2_normalised_width,ax2_normalised_height)#firstbar_pos[0] + 2*k*barwidth,
                label = False
                ax=add_subplot_axes(ax2,subpos,polar=True,label=label)
                ax.set_ylim(0,1)
                
                for k in range(Nmod):
                    phase = phases[0,NINtemp+ib,k] ; norm = normphasors[0,NINtemp+ib,k]/np.max(normphasors[0,NINtemp+ib,:])
                    ax.arrow(phase, 0, 0, norm, width = 0.05,
                             edgecolor=colors[k],facecolor = colors[k], lw = 2, zorder = 5,length_includes_head=True)
            
            xticklabels=[]
            for ia in range(NA):
                for iap in range(ia+1,NA):
                    xticklabels.append(f&#34;B{ia+1}{iap+1}&#34;)
            
            ax1.set_xticks(xtop)
            ax1.set_xticklabels(xticklabels[:NINtemp])
            
            ax1.set_ylim(0,14)
            ax2.set_ylim(0,14)
            
            ax2.set_xticks(xbot)
            ax2.set_xticklabels(xticklabels[NINtemp:])
            
            # Set legend on ax3 and ax4    
            ax3.axis(&#34;off&#34;); ax4.axis(&#34;off&#34;)
            ax3.legend(handles=bar_patches1+bar_patches2+linestyles, loc=&#39;upper left&#39;)
            
            
            # ax1.set_ylabel(&#34;Phase [rad]&#34;)
            ax1.set_ylabel(&#34;Transmission \n[%]&#34;)
            ax2.set_ylabel(&#34;Transmission \n[%]&#34;)
            ax1.grid(False)
            ax2.grid(False)
            
            if len(savedir):
                fig.savefig(savedir+f&#34;PICrepartition.{ext}&#34;)
            
            fig.show()
    
        plt.rcParams.update(plt.rcParamsDefault)
    
    
# =============================================================================
#     Noise propagation through the matrix
# =============================================================================
    
    if (&#39;noise&#39; in args) or (&#39;displayall&#39; in args):

        newfig+=1
        fig = plt.figure(&#39;Noise propagation&#39;, clear=True)
        fig.suptitle(&#34;Covariance matrices in photon noise regime (1000photons)&#34;)
        ax1, ax2 = fig.subplots(ncols=2)
        ax1.set_title(&#39;Covariance matrix when cophased&#39;)
        ax2.set_title(&#39;Covariance matrix when phase in quadrature&#39;)
        
        ax1.imshow(CovMatrixCoherent[0])
        ax2.imshow(CovMatrixQuadrature[0])
        
        xticks=[] ; xticklabels=[]
        xticks.append(NA//2) ; xticklabels.append(&#39;Photometries&#39;)
        x = NA-0.5 ; xticks.append(NA+NIN//2) ; xticklabels.append(&#39;Real parts&#39;)
        ax1.axvline(x = x, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axvline(x = x, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        # x = NA+0.5 ; xticks.append(x) ; xticklabels.append(&#39;B1X&#39;)
        x = NA+NIN-0.5 ; xticks.append(NA+3*NIN//2) ; xticklabels.append(&#39;Imaginary parts&#39;)
        ax1.axvline(x = NA+NIN-0.5, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axvline(x = NA+NIN-0.5, color = &#39;k&#39;, linestyle = &#39;-&#39;)
            
        yticks=[] ; yticklabels=[]
        yticks.append(-0.5) ; yticklabels.append(&#39;Photometries&#39;)
        y = NA-0.5 ; yticks.append(y) ; yticklabels.append(&#39;Real parts&#39;)
        ax1.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax1.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        y = NA+0.5 ; yticks.append(y) ; yticklabels.append(&#39;B1X&#39;)
        y = NA+NIN-0.5 ; yticks.append(y) ; yticklabels.append(&#39;Imaginary parts&#39;)
        ax1.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax1.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        y = NA+NIN+0.5 ; yticks.append(y) ; yticklabels.append(&#39;B1X&#39;)
        for ia in range(1,NA-1):
            ib = posk(ia,ia+1,NA)
            y = NA+ib-0.5 ; yticks.append(y) ; yticklabels.append(f&#39;B{ia+1}X&#39;)
            ax1.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax1.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            y = NA+NIN+ib-0.5 ; yticks.append(y) ; yticklabels.append(f&#39;B{ia+1}X&#39;)
            ax1.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax1.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
    
        ax1.set_yticks(xticks)
        # ax1.set_yticklabels(xticklabels)
        ax1.set_yticks(yticks)
        ax1.set_yticklabels(yticklabels)
    
        ax2.set_yticklabels([])
        # ax2.set_yticks(xticks)
        # ax2.set_yticklabels(xticklabels)
        # ax2.set_yticks(yticks)
        # ax2.set_yticklabels(yticklabels)
    
        ax1.set_xticks(xticks) ; ax1.set_xticklabels(xticklabels)
        ax2.set_xticks(xticks) ; ax2.set_xticklabels(xticklabels)
        ax1.grid(False)
        ax2.grid(False)

        
    return dico



def poskfai(ia,iap,iapp,N):
    &#34;&#34;&#34;
    k-Position of the PhaseClosure for non redundant combination of three pupils
    in a total of N pupils.

    Parameters
    ----------
    ia : TYPE
        DESCRIPTION.
    iap : TYPE
        DESCRIPTION.
    iapp : TYPE
        DESCRIPTION.
    N : Integer
        Number of telescopes.

    Returns
    -------
    Integer
        k-position

    &#34;&#34;&#34;
    
    from scipy.special import binom
    k0 = np.sum(binom(np.arange(N-ia,N),2))
    k1 = posk(iap-ia-1,iapp-iap,N-ia)
    
    return int(k0+k1)


def posk(ia,iap,N):
    &#34;&#34;&#34;
    k-Position of the OPD[ia,iap] for non redundant combination of two pupils in
    a total of N pupils

    Parameters
    ----------
    ia : TYPE
        DESCRIPTION.
    iap : TYPE
        DESCRIPTION.
    iapp : TYPE
        DESCRIPTION.
    N : Integer
        Number of telescopes

    Returns
    -------
    Integer
        k-position on the most logical order: 
            for 6T: 01,02,03,04,05,12,13,14,15,23,24,25,34,35,45

    &#34;&#34;&#34;
    
    return int(ia*N-ia*(ia+3)/2+iap-1)

def NB2NIN(vector):
    &#34;&#34;&#34;
    Get a vector (resp.array) of shape NB=NA² (resp. [NW,NB]).
    Returns it on a non-redundant form of length NIN=NA(NA-1)/2 sorted as follow:
        12,..,1NA,23,..,2NA,34,..,3NA,..,(NA-1)(NA)

    Parameters
    ----------
    vector : FLOAT COMPLEX ARRAY [NB] or [NW,NB]
        Vector of general complex coherences.

    Returns
    -------
    ninvec : FLOAT COMPLEX ARRAY [NIN] or [NW,NIN]
        Complex Vector of non-redundant mutual coherences.
    &#34;&#34;&#34;

    if vector.ndim==2:
        NW,NB = vector.shape
    else:
        NB = len(vector)
        
    NA = int(np.sqrt(NB))
    NIN = int(NA*(NA-1)/2)
    
    if vector.ndim==2:
        ninvec = np.zeros([NW,NIN])*1j
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                ninvec[:,k] = vector[:,ia*NA+iap]
    else:
        ninvec = np.zeros([NIN])*1j
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                ninvec[k] = vector[ia*NA+iap]
    
    return ninvec


def makeA2P(descr, modulator, verbose=False,clean_up=False):
    &#34;&#34;&#34;Builds an A2P matrix from a high-level description descr of the FTchip.
       descr (NIN,2) gives for each baseline (order 01,02,..,12,13,...) the amplitude ratio for pups 1 &amp; 2&#34;&#34;&#34;
    
    
    descr = np.array(descr) # Make sure it is an array so that the indexation works well
    nb_in=len(descr)
    
    NA=int(round((1+np.sqrt(1+8*nb_in))/2)) # inversion analytique de la ligne suivante
    NIN=NA*(NA-1)//2
    if NIN != nb_in:
        if verbose:
            print(&#39;Taille descr bizarre, attendu=&#39;,NIN)
        
    NQ = np.shape(modulator)[0] ; NP=NIN*NQ
    if NQ==4:
        alphabet = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]
    elif NQ==2:
        alphabet = [&#39;A&#39;,&#39;C&#39;]
    
    conventional_ich = []
    for ia in range(NA):
        for iap in range(ia+1,NA):
            for iq in range(NQ):
                conventional_ich.append((int(f&#34;{ia+1}{iap+1}&#34;),alphabet[iq]))
    
    ich = conventional_ich

    A2Pgen=np.zeros((NIN,NQ,NA),dtype=complex) #(base_out=[ia,iap],ABCD,ia_in)
    active_ich=[1]*NIN
    ib=0
    for ia in range(NA):
        for iap in range(ia+1,NA):
            A2Pgen[ib,:,ia ]=modulator[:,0]*descr[ib,0]
            A2Pgen[ib,:,iap]=modulator[:,1]*descr[ib,1]
            if not descr[ib,0]*descr[ib,1]:
                active_ich[ib]=0        # This baseline is not measured
            ib+=1
            
    A2P=np.reshape(A2Pgen,(NP,NA))
    lightA2P=np.copy(A2P)
    
    if clean_up:
        inc=0
        for ip in range(NP):
            if (A2P[ip,:] == np.zeros(NA)).all():
                lightA2P = np.delete(lightA2P, ip-inc, axis=0) # Remove the line at position ip because it doesn&#39;t receive any flux
                del ich[ip-inc]
                inc+=1

    return lightA2P, ich, active_ich


def MakeV2PfromA2P(Amat):
    NP,NA = Amat.shape
    NB=NA**2
    Bmat = np.zeros([NP,NB])*1j
    for ip in range(NP):
        for ia in range(NA):
            for iap in range(NA):
                k = ia*NA+iap
                Bmat[ip, k] = Amat[ip,ia]*np.transpose(np.conjugate(Amat[ip,iap]))

    return Bmat



def check_nrj(A2P):
    &#34;&#34;&#34;
    Checks if a (NP,NA) A2P matrix is normalized.
    If it is normalised, it means the PIC it accounts for conserves energy.
    &#34;&#34;&#34;
    
    A2Pmod2=A2P*np.conj(A2P)
    nrjpup=np.real(np.sum(A2Pmod2,axis=0))   # Somme du carré des éléments de chaque ligne --&gt; vecteur de dimension NA
    if (nrjpup &gt; 1+1e-15).any():             # Check si la somme des carrés de tous les éléments est inférieure à 1.
        T = np.sum(nrjpup)/len(nrjpup)    
        print(f&#39;Pb: A2P is not normalized, transmission is {round(T*100)}%&#39;)
        print(f&#34;Detail: {nrjpup}&#34;)
        
    elif (nrjpup &lt; 1-1e-15).any():
        T = np.sum(nrjpup)/len(nrjpup)
        print(f&#34;The PIC absorbs {round((1-T)*100)}% of energy&#34;)
        print(f&#34;Detail: {nrjpup}&#34;)
        
    return

def check_semiunitary(A2P):
    &#34;&#34;&#34;
    Check if the A2P matrix is pseudo-inversible and if it absorbs, or not, energy.
    &#34;&#34;&#34;
    
    Rank = np.linalg.rank(A2P)
    
    if not Rank == np.shape(A2P)[1]:
        print(f&#34;The matrix is not semi-unitary&#34;)
    
    
    # Not sure about that.
    # u,s,vh = np.linalg.svd(A2P)
    
    # if not (s&lt;=1).all():   # Check if all singular values are lower than 1
    #     print(f&#34;The matrix creates energy.&#34;)
        
    # elif not (s==1).all(): # Check if all singular values are equal to 1
    #     print(f&#34;The matrix absorbs energy.&#34;)
    
    return

def check_cp(gd):
    
    NIN=len(gd) ; 
    NA = int(1/2+np.sqrt(1/4+2*NIN))
    NC=int(binom(NA,3)/2)

    cp=np.zeros(NC)
    for iap in range(1,NA):
        for iapp in range(iap+1,NA):
            ib1=posk(0,iap,NA); ib2=posk(iap,iapp,NA);ib3=posk(0,iapp,NA)
            ic=poskfai(0,iap,iapp,NA)
            cp[ic]=gd[ib1]+gd[ib2]-gd[ib3]
    return cp

def add_subplot_axes(ax,rect,polar=False,label=False,facecolor=&#39;w&#39;):
    fig = plt.gcf()
    box = ax.get_position()
    width = box.width
    height = box.height
    inax_position  = ax.transAxes.transform(rect[0:2])
    transFigure = ax.figure.transFigure.inverted()
    infig_position = transFigure.transform(inax_position)
    x = infig_position[0]
    y = infig_position[1]
    width *= rect[2]
    height = width*box.width/box.height
    # height *= rect[3]  # &lt;= Typo was here
    subax = fig.add_axes([x,y,width,height],polar=polar)
    subax.set_rticks([])
    
    if label:
        subax.set_xticks([0,np.pi/2,np.pi,3*np.pi/2])
    else:
        subax.set_thetagrids([0,90,180,270],labels=[])
    # x_labelsize = subax.get_xticklabels()[0].get_size()
    # y_labelsize = subax.get_yticklabels()[0].get_size()
    # x_labelsize *= rect[2]**0.5
    # y_labelsize *= rect[3]**0.5
    # subax.xaxis.set_tick_params(labelsize=x_labelsize)
    # subax.yaxis.set_tick_params(labelsize=y_labelsize)
    return subax


def setaxelim(ax, xdata=[],ydata=[],xmargin=0.1,ymargin=0.1, ylim_min=[0,0], **kwargs):
    
    if len(xdata):
        xmin = (1+xmargin)*np.min(xdata) ; xmax = (1+xmargin)*np.max(xdata)
        ax.set_xlim([xmin,xmax])
        
    if len(ydata):
        if not &#39;ymin&#39; in kwargs.keys():
            ymin = (1+ymargin)*np.min(ydata)
        else:
            ymin=kwargs[&#39;ymin&#39;]
        
        ymax = (1+ymargin)*np.max(ydata)
        
        ydown_min, yup_min = ylim_min
        if yup_min !=0:
            ymax = np.max([ymax,yup_min])
        if ydown_min !=0:
            ymin = np.min([ymin,ydown_min])
        
        ax.set_ylim([ymin,ymax])
        
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cophasing.coh_tools.BBstar"><code class="name flex">
<span>def <span class="ident">BBstar</span></span>(<span>wav, T)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the spectral luminance of a black-body given its temperature.
Will be useful to give the shape of the spectra of a star.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wav</code></strong> :&ensp;<code>[NW] float [meter]</code></dt>
<dd>Wavelength in meter.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float [K]</code></dt>
<dd>Temperature of the Black-Body in Kelvin.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>luminance</code></strong> :&ensp;<code>[NW] floats [W/s/m²/sr]</code></dt>
<dd>Luminance of the source per steradian.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BBstar(wav, T):
    &#34;&#34;&#34;
    Returns the spectral luminance of a black-body given its temperature.
    Will be useful to give the shape of the spectra of a star.

    Parameters
    ----------
    wav : [NW] float [meter]
        Wavelength in meter.
    T : float [K]
        Temperature of the Black-Body in Kelvin.

    Returns
    -------
    luminance : [NW] floats [W/s/m²/sr]
        Luminance of the source per steradian.

    &#34;&#34;&#34;
    global h_, c_, k_
    
    a = 2.0*h_*c_**2
    b = h_*c_/(wav*k_*T)
    luminance = a / ( (wav**5) * (np.exp(b) - 1.0) ) # W/m²/sr/µm
    
    # nu = c_/spectra   # Electromagnetic frequency [Hz]
    # a = 2.*h_/c_**2
    # b = h_/k_/T
    # B_sig = a*nu**3/(np.exp(b*nu)-1)  # W/m²/sr/s
    
    return luminance</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.MakeV2PfromA2P"><code class="name flex">
<span>def <span class="ident">MakeV2PfromA2P</span></span>(<span>Amat)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MakeV2PfromA2P(Amat):
    NP,NA = Amat.shape
    NB=NA**2
    Bmat = np.zeros([NP,NB])*1j
    for ip in range(NP):
        for ia in range(NA):
            for iap in range(NA):
                k = ia*NA+iap
                Bmat[ip, k] = Amat[ip,ia]*np.transpose(np.conjugate(Amat[ip,iap]))

    return Bmat</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.NB2NIN"><code class="name flex">
<span>def <span class="ident">NB2NIN</span></span>(<span>vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a vector (resp.array) of shape NB=NA² (resp. [NW,NB]).
Returns it on a non-redundant form of length NIN=NA(NA-1)/2 sorted as follow:
12,..,1NA,23,..,2NA,34,..,3NA,..,(NA-1)(NA)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vector</code></strong> :&ensp;<code>FLOAT COMPLEX ARRAY [NB]</code> or <code>[NW,NB]</code></dt>
<dd>Vector of general complex coherences.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ninvec</code></strong> :&ensp;<code>FLOAT COMPLEX ARRAY [NIN]</code> or <code>[NW,NIN]</code></dt>
<dd>Complex Vector of non-redundant mutual coherences.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NB2NIN(vector):
    &#34;&#34;&#34;
    Get a vector (resp.array) of shape NB=NA² (resp. [NW,NB]).
    Returns it on a non-redundant form of length NIN=NA(NA-1)/2 sorted as follow:
        12,..,1NA,23,..,2NA,34,..,3NA,..,(NA-1)(NA)

    Parameters
    ----------
    vector : FLOAT COMPLEX ARRAY [NB] or [NW,NB]
        Vector of general complex coherences.

    Returns
    -------
    ninvec : FLOAT COMPLEX ARRAY [NIN] or [NW,NIN]
        Complex Vector of non-redundant mutual coherences.
    &#34;&#34;&#34;

    if vector.ndim==2:
        NW,NB = vector.shape
    else:
        NB = len(vector)
        
    NA = int(np.sqrt(NB))
    NIN = int(NA*(NA-1)/2)
    
    if vector.ndim==2:
        ninvec = np.zeros([NW,NIN])*1j
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                ninvec[:,k] = vector[:,ia*NA+iap]
    else:
        ninvec = np.zeros([NIN])*1j
        for ia in range(NA):
            for iap in range(ia+1,NA):
                k = posk(ia,iap,NA)
                ninvec[k] = vector[ia*NA+iap]
    
    return ninvec</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.VanCittert"><code class="name flex">
<span>def <span class="ident">VanCittert</span></span>(<span>spectra, Obs, Target, plottrace=60, display=False, savedir='', ext='pdf', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the Coherent flux matrix of an object in the (u,v) plane according
to:
- the Observation parameters: array, date and star coords.
- the Science object: angular diameters, positions, relative luminosity</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spectra</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>starname</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 'Deneb'.</dd>
<dt><strong><code>angdiameters</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is (0.3,0.3).</dd>
<dt><strong><code>relative_L</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is (1,1).</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>visibilities</code></strong> :&ensp;<code>ARRAY [NW,NIN]*1j</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VanCittert(spectra, Obs, Target, plottrace=60, display=False,
               savedir=&#39;&#39;,ext=&#39;pdf&#39;,verbose=False):
    &#34;&#34;&#34;
    Create the Coherent flux matrix of an object in the (u,v) plane according
    to:
        - the Observation parameters: array, date and star coords.
        - the Science object: angular diameters, positions, relative luminosity


    Parameters
    ----------
    spectra : TYPE
        DESCRIPTION.
    starname : TYPE, optional
        DESCRIPTION. The default is &#39;Deneb&#39;.
    angdiameters : TYPE, optional
        DESCRIPTION. The default is (0.3,0.3).
    relative_L : TYPE, optional
        DESCRIPTION. The default is (1,1).
    display : TYPE, optional
        DESCRIPTION. The default is False.

    Returns
    -------
    visibilities : ARRAY [NW,NIN]*1j
        DESCRIPTION.

    &#34;&#34;&#34;
        
    if (len(savedir)) and (not os.path.exists(savedir)):
        os.makedirs(savedir)
        
    if verbose:
        print(&#34;Calculation of object&#39;s visibilities from Van Cittert theorem\n ...&#34;)

    # Relative positions of the two stars
    pos_star1 = Target.Star1[&#39;Position&#39;]
    angular_diameter1 = Target.Star1[&#39;AngDiameter&#39;]
    H1 = Target.Star1[&#39;Hmag&#39;]
    
    BinaryObject = True
    try:
        pos_star2 = Target.Star2[&#39;Position&#39;]
        angular_diameter2 = Target.Star2[&#39;AngDiameter&#39;]
        H2 = Target.Star2[&#39;Hmag&#39;]
    except:
        if verbose:
            print(&#39;Simple centered star1&#39;)
        BinaryObject = False
        
        # angular_diameter2 = angular_diameter1
        # H2 = 0
        
    # pos_star1 = np.array([1,-1])
    # pos_star2 = np.array([-1,1])
    
    # BinaryObject = (type(angdiameters) == tuple)
    
    if BinaryObject:
        # Calculation of a relative luminosity
        (luminosity1,luminosity2) = (10**(-0.4*H1),10**(-0.4*H2))
        # (angular_diameter1,angular_diameter2) = angdiameters
        
        # Pixel unit luminance ratio between both stars
        LuminanceRatio = luminosity1/angular_diameter1*angular_diameter2/luminosity2
    # else:
    #     # angular_diameter1 = angdiameters
    #     # angular_diameter2 = angdiameters
    #     luminosity1 = 1
    #     # luminosity2 = 0
    #     # pos_star1 = np.array([0,0])
    
    
    # Npix = 1024
    # thetamax = 10
    # dtheta = 2*thetamax/Npix
    
    # dtheta must well sample the smallest star
    #if BinaryObject:
    #    dtheta = np.min((angular_diameter1,angular_diameter2))/5
    #else:
    #    dtheta = angular_diameter1/5
        
    du = 0.005
    Npix = 5000     #2*int(thetamax/dtheta)
    dtheta = 1/(du*Npix)   # 0.04mrad
    
    thetamax = dtheta*Npix/2

    obj_plane = np.zeros([Npix,Npix])
    
    coords = (np.arange(Npix)- Npix/2)*dtheta
    (alpha,beta) = np.meshgrid(coords,-coords)
    dist1 = np.sqrt((alpha-pos_star1[0])**2 + (beta-pos_star1[1])**2)
    obj_plane[dist1&lt;angular_diameter1/2] = 1
    NpixStar1 = np.sum(obj_plane)
    
    if BinaryObject:
        dist2 = np.sqrt((alpha-pos_star2[0])**2 + (beta-pos_star2[1])**2)
        obj_plane[dist2&lt;angular_diameter2] = 1/LuminanceRatio
        
    
    # Normalisation of the luminosity, with first star as reference
    obj_plane = obj_plane/NpixStar1

    Nticks = 7
    ticks = np.linspace(0,Npix,Nticks)
        
    if display:            
        fig = plt.figure(config.newfig, figsize=(16,9))
        (ax1,ax2,ax3) = fig.subplots(ncols=3)
        
        spaceticks = (ticks-round(Npix/2))*dtheta
        spaceticks = spaceticks.round(decimals=1)
        
        ax1.set_title(&#39;Object in direct plane&#39;)
        ax1.imshow(obj_plane)
        ax1.set_xticks(ticks) ; ax1.set_xticklabels(spaceticks)
        ax1.set_yticks(ticks) ; ax1.set_yticklabels(-spaceticks)
        ax1.set_xlabel(&#39;\u03B1 [mas]&#39;)
        ax1.set_ylabel(&#39;\u03B2 [mas]&#39;)
    
    # Van-Cittert theorem (calculation of the visibility)
    
    uv_plane = np.fft.ifftshift(np.fft.fft2(np.fft.fftshift(obj_plane)))
    uv_plane /= np.max(np.abs(uv_plane))
    
    # (u,v) sampling
    freqs = np.fft.fftshift(np.fft.fftfreq(Npix, dtheta))
    dfreq = freqs[1] - freqs[0]
    (ucoords,vcoords) = np.meshgrid(freqs, -freqs)
    freqticks = (ticks-round(Npix/2))*dfreq
    freqticks = freqticks.round(decimals=1)
    
    if display:        

        ax2.set_title(&#39;Module of the visibility&#39;)
        ax2.imshow(np.abs(uv_plane),vmin=0,vmax=1)
        ax2.set_xticks(ticks) ; ax2.set_xticklabels(freqticks)
        ax2.set_yticks(ticks) ; ax2.set_yticklabels(-freqticks)
        ax2.set_xlabel(&#39;u [mas-1]&#39;)
        ax2.set_ylabel(&#39;v [mas-1]&#39;)
        
        ax3.set_title(&#39;Phase of the visibility&#39;)
        ax3.imshow(np.angle(uv_plane),vmin=-np.pi,vmax=np.pi)
        ax3.set_xticks(ticks) ; ax3.set_xticklabels(freqticks)
        ax3.set_yticks(ticks) ; ax3.set_yticklabels(-freqticks)
        ax3.set_xlabel(&#39;u [mas-1]&#39;)
        ax3.set_ylabel(&#39;v [mas-1]&#39;)
        
        fig.show()
        config.newfig+=1
    
    &#34;&#34;&#34;
    Projection of the interferometer on the (u,v) plane
    &#34;&#34;&#34;
    
    # Get telescopes coordinates and names
    InterfArray = get_array(config.Name, getcoords=True)    
    
    TelNames = InterfArray.TelNames
    CHARAcoords = InterfArray.TelCoordinates
    basecoords = InterfArray.BaseCoordinates
    
    CHARAcoords *= 1e6          # Convert to [µm]
    basecoords *= 1e6          # Convert to [µm]
    
    NA = len(CHARAcoords)
    
    CHARAaltaz = np.zeros([NA,2])
    for ia in range(NA):
        if np.linalg.norm(CHARAcoords[ia]) == 0:
            CHARAaltaz[ia,0] = 0
            CHARAaltaz[ia,1] = 0    
        else:
            CHARAaltaz[ia,1] = np.arctan(CHARAcoords[ia,0]/CHARAcoords[ia,1])
            CHARAaltaz[ia,0] = np.arcsin(CHARAcoords[ia,2]/np.linalg.norm(CHARAcoords[ia]))
    
    NIN = int(NA*(NA-1)/2)
    basealtaz = np.zeros([NIN,2])       # Altazimuthal coordinates of the baselines [radians]
    basedist = np.zeros([NIN,1])        # Baselines lengths in [µm]
    basecoords = np.zeros([NIN,3])      # Baselines coordinates [µm]
    basenames = []                      # Baselines names [string]
    
    for ia in range(NA):
        for iap in range(ia+1,NA):
            ib = int(ia*NA-ia*(ia+3)/2+iap-1)
            
            basealtaz[ib] = CHARAaltaz[iap]-CHARAaltaz[ia]
            
            basenames.append(TelNames[ia]+TelNames[iap])
            basecoords[ib] = CHARAcoords[iap] - CHARAcoords[ia]
            basedist[ib] = np.linalg.norm(basecoords[ib])
    
    
    # First case: the name of the object has been given. We search it in Simbad
    # database and its AltAzimutal coordinates if a Date has been given.
    if Target.Name not in (&#39;Simple&#39;,&#39;Binary&#39;,&#39;Unresolved&#39;) and (&#39;AltAz&#39; not in vars(Obs)):
        starttime = Time(Obs.DATE)
        if verbose:
            print(f&#34;Observation date: {Obs.DATE}&#34;)
    
        starcoords = SkyCoord.from_name(Target.Name)
        ArrayLocation=EarthLocation.of_site(Obs.ArrayName)
        staraltaz = starcoords.transform_to(AltAz(obstime=starttime,location=ArrayLocation))
        
        (altitude, azimuth) = (staraltaz.alt.radian,staraltaz.az.radian)
        Obs.AltAz = (180/np.pi*altitude, 180/np.pi*azimuth)
        
    else:
        (altitude, azimuth) = (theta*np.pi/180 for theta in Obs.AltAz)
        if verbose:
            print(f&#34;User defined {Target.Name} object with AltAz={Obs.AltAz}&#34;)
        
        
    
    &#34;&#34;&#34;
    Altazimuthal coordinates definition:
        - azimuth: angular distance between the intersection of the target meridian with 
        the horizon and the north horizon: East = 90° Azimuth.
        - altitude: angular distance between the horizon and the target, along its meridian.
    
    CHARA coordinates definition:
        - X: toward East
        - Y: toward North
        - Z: toward Zenith
    &#34;&#34;&#34;
    
    
    # Coordinates of the (u,v) plane in the (E,N,Z) referential
    u_Ep = np.array([np.cos(azimuth),np.sin(azimuth),0])
    u_Np = np.array([np.sin(altitude)*np.sin(azimuth),np.sin(altitude)*np.cos(azimuth),np.cos(altitude)])
    u_Zp = np.array([np.cos(altitude)*np.sin(azimuth),np.cos(altitude)*np.cos(azimuth),np.sin(altitude)])
    
    
    # Projection baselines on the target&#39;s (u,v) plane
    B_Ep = np.dot(basecoords, np.transpose(u_Ep))
    B_Np = -np.dot(basecoords, np.transpose(u_Np))
    B_Zp = np.dot(basecoords, np.transpose(u_Zp))
    
    # baselines = np.transpose(basedist)*np.sin(altitude-basealtaz[:,0])
    
    if isinstance(spectra,(float,int)):
        spectra = [spectra]
    
    NW = len(spectra)
    
    # Projection baselines on the u,v coordinates (oriented with the star north-east)
    chara_uv = np.zeros([NW,NIN,2])
    for iw in range(NW):
        lmbda=spectra[iw]
        chara_uv[iw,:,0] = B_Ep/lmbda
        chara_uv[iw,:,1] = B_Np/lmbda
    
    # Conversion functions
    mas2rad = lambda mas : 1/3600*1e-3*np.pi/180*mas
    rad2mas = lambda rad : 3600*1e3*180/np.pi*rad

    #Convert (u,v) plane from radian to mas
    chara_uv_direct = 1/chara_uv
    chara_uv_direct_mas = rad2mas(chara_uv_direct)
    chara_uv = 1/chara_uv_direct_mas
    
    # Return the complex visibility vector of the source
    visibilities = np.zeros([NW,NIN])*1j
    for ib in range(NIN):
        for iw in range(NW):     
            ub=chara_uv[iw,ib,0] ; vb=chara_uv[iw,ib,1]
            Nu = int(round(ub/dfreq)+Npix/2)
            Nv = int(round(vb/dfreq)+Npix/2)
            visibilities[iw,ib] = uv_plane[Nu,Nv]
        
    UVcoords = (ucoords,vcoords)
    #UVcoordsMeters = [1/mas2rad(1/coord)*np.median(lmbda) for coord in UVcoords]
    
    if verbose:
        print(&#34;Visibilities calculated.&#34;)
    
    
    if display:         # Display (u,v) plane with interferometer projections (first wavelength)
        
        if &#39;active_ich&#39; in config.FS.keys():
            active_ich = config.FS[&#39;active_ich&#39;]
            PhotSNR = config.FS[&#39;PhotometricSNR&#39;]
        else:
            active_ich=np.ones(NIN)
            PhotSNR = np.ones(NIN)
            
        actindNIN = np.array(active_ich)==1
        actind = np.concatenate([actindNIN[::-1], actindNIN])
        
        PhotometricSNR = np.concatenate([PhotSNR[::-1],PhotSNR])
        
        if verbose:
            print(f&#39;Plot CHARA (u,v) coverage on figure {config.newfig}&#39;)    
        chara_uv_complete = np.concatenate((chara_uv[NW//2], -chara_uv[NW//2]),axis=0)
        
        uvmax = np.max(chara_uv_complete/dfreq)+10
        
        Ndisplay = 2*int(uvmax+10)
        
        uv_crop = uv_plane[(Npix-Ndisplay)//2:(Npix+Ndisplay)//2,(Npix-Ndisplay)//2:(Npix+Ndisplay)//2]
        chara_plot = chara_uv_complete/dfreq+Ndisplay/2
        
        Nticks = 11
        ticks = np.linspace(0,Ndisplay-1,Nticks)
        freqticks = (ticks+1-round(Ndisplay/2))*dfreq
        freqticks = freqticks.round(decimals=1)
        # Display the Visibility and the interferometer baselines on the (u,v) plane
        fig = plt.figure(config.newfig)
        ax = fig.subplots()
        fig.suptitle(&#39;(u,v) coverage&#39;)
        im=ax.imshow(np.abs(uv_crop),vmin=0,vmax=1)
        
        ax.scatter(chara_plot[actind,0], chara_plot[actind,1], marker=&#39;x&#39;, s=50*np.sqrt(PhotometricSNR[actind]),linewidth=1, color=&#39;firebrick&#39;)
        ax.scatter(chara_plot[actind==False,0], chara_plot[actind==False,1], marker=&#39;x&#39;, s=50, linewidth=1,color=&#39;black&#39;)
        plt.xticks(ticks,freqticks)
        plt.yticks(ticks,-freqticks)
        ax.set_xlabel(&#39;u (W-E) [$mas^{-1}$]&#39;)
        ax.set_ylabel(&#39;v (S-N) [$mas^{-1}$]&#39;)
        
        fig.subplots_adjust(right=0.8)
        cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
        fig.colorbar(im, cax=cbar_ax)
        
        config.newfig += 1
        
        
        if len(savedir):
            import time
            timestr = time.strftime(&#34;%Y%m%d-%H%M%S&#34;)
            plt.savefig(savedir+f&#34;UVplane{timestr}.{ext}&#34;)
    
    # if NW==1:
    #     visibilities = visibilities[0]
    
    return visibilities, chara_uv, uv_plane, UVcoords</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.add_subplot_axes"><code class="name flex">
<span>def <span class="ident">add_subplot_axes</span></span>(<span>ax, rect, polar=False, label=False, facecolor='w')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_subplot_axes(ax,rect,polar=False,label=False,facecolor=&#39;w&#39;):
    fig = plt.gcf()
    box = ax.get_position()
    width = box.width
    height = box.height
    inax_position  = ax.transAxes.transform(rect[0:2])
    transFigure = ax.figure.transFigure.inverted()
    infig_position = transFigure.transform(inax_position)
    x = infig_position[0]
    y = infig_position[1]
    width *= rect[2]
    height = width*box.width/box.height
    # height *= rect[3]  # &lt;= Typo was here
    subax = fig.add_axes([x,y,width,height],polar=polar)
    subax.set_rticks([])
    
    if label:
        subax.set_xticks([0,np.pi/2,np.pi,3*np.pi/2])
    else:
        subax.set_thetagrids([0,90,180,270],labels=[])
    # x_labelsize = subax.get_xticklabels()[0].get_size()
    # y_labelsize = subax.get_yticklabels()[0].get_size()
    # x_labelsize *= rect[2]**0.5
    # y_labelsize *= rect[3]**0.5
    # subax.xaxis.set_tick_params(labelsize=x_labelsize)
    # subax.yaxis.set_tick_params(labelsize=y_labelsize)
    return subax</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.check_cp"><code class="name flex">
<span>def <span class="ident">check_cp</span></span>(<span>gd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_cp(gd):
    
    NIN=len(gd) ; 
    NA = int(1/2+np.sqrt(1/4+2*NIN))
    NC=int(binom(NA,3)/2)

    cp=np.zeros(NC)
    for iap in range(1,NA):
        for iapp in range(iap+1,NA):
            ib1=posk(0,iap,NA); ib2=posk(iap,iapp,NA);ib3=posk(0,iapp,NA)
            ic=poskfai(0,iap,iapp,NA)
            cp[ic]=gd[ib1]+gd[ib2]-gd[ib3]
    return cp</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.check_nrj"><code class="name flex">
<span>def <span class="ident">check_nrj</span></span>(<span>A2P)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a (NP,NA) A2P matrix is normalized.
If it is normalised, it means the PIC it accounts for conserves energy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_nrj(A2P):
    &#34;&#34;&#34;
    Checks if a (NP,NA) A2P matrix is normalized.
    If it is normalised, it means the PIC it accounts for conserves energy.
    &#34;&#34;&#34;
    
    A2Pmod2=A2P*np.conj(A2P)
    nrjpup=np.real(np.sum(A2Pmod2,axis=0))   # Somme du carré des éléments de chaque ligne --&gt; vecteur de dimension NA
    if (nrjpup &gt; 1+1e-15).any():             # Check si la somme des carrés de tous les éléments est inférieure à 1.
        T = np.sum(nrjpup)/len(nrjpup)    
        print(f&#39;Pb: A2P is not normalized, transmission is {round(T*100)}%&#39;)
        print(f&#34;Detail: {nrjpup}&#34;)
        
    elif (nrjpup &lt; 1-1e-15).any():
        T = np.sum(nrjpup)/len(nrjpup)
        print(f&#34;The PIC absorbs {round((1-T)*100)}% of energy&#34;)
        print(f&#34;Detail: {nrjpup}&#34;)
        
    return</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.check_semiunitary"><code class="name flex">
<span>def <span class="ident">check_semiunitary</span></span>(<span>A2P)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the A2P matrix is pseudo-inversible and if it absorbs, or not, energy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_semiunitary(A2P):
    &#34;&#34;&#34;
    Check if the A2P matrix is pseudo-inversible and if it absorbs, or not, energy.
    &#34;&#34;&#34;
    
    Rank = np.linalg.rank(A2P)
    
    if not Rank == np.shape(A2P)[1]:
        print(f&#34;The matrix is not semi-unitary&#34;)
    
    
    # Not sure about that.
    # u,s,vh = np.linalg.svd(A2P)
    
    # if not (s&lt;=1).all():   # Check if all singular values are lower than 1
    #     print(f&#34;The matrix creates energy.&#34;)
        
    # elif not (s==1).all(): # Check if all singular values are equal to 1
    #     print(f&#34;The matrix absorbs energy.&#34;)
    
    return</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.coh__GRAV2simu"><code class="name flex">
<span>def <span class="ident">coh__GRAV2simu</span></span>(<span>gravmatrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Adapt the GRAVITY's matrix formalism in the simulator one</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>simuV2PM</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>simuP2VM</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coh__GRAV2simu(gravmatrix):
    &#34;&#34;&#34;
    Adapt the GRAVITY&#39;s matrix formalism in the simulator one

    Parameters
    ----------
    matrix : TYPE
        DESCRIPTION.

    Returns
    -------
    simuV2PM : TYPE
        DESCRIPTION.
    simuP2VM : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;    
    shape = np.shape(gravmatrix)
    
    if len(shape)==3:    # It&#39;s a V2PM
        (NW,NP,NB) = shape
        simuV2PM = np.zeros([NW,NP,NB])*1j
        simuP2VM = np.zeros([NW,NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            simuV2PM[:,:,ksim] = gravmatrix[:,:,ia]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1

                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)
                Real = gravmatrix[:,:,k]
                k = int(NA*(NA+1)/2 + kp)
                Imag = gravmatrix[:,:,k]
                
                # Direct and Conjugate coherence vectors
                ksim = ia*NA+iap
                simuV2PM[:,:,ksim] = 1/2*(Real + Imag*1j)
                ksim = iap*NA+ia          # 
                simuV2PM[:,:,ksim] = 1/2*(Real - Imag*1j)
        
        for iw in range(NW):
            simuP2VM[iw,:,:] = np.linalg.pinv(simuV2PM[iw,:,:])
        
    else:
        (NP,NB) = shape
        simuV2PM = np.zeros([NP,NB])*1j
        simuP2VM = np.zeros([NB,NP])*1j
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            simuV2PM[:,ksim] = gravmatrix[:,ia]
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1

                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)
                Real = gravmatrix[:,k]
                k = int(NA*(NA+1)/2 + kp)
                Imag = gravmatrix[:,k]
                
                # Direct and Conjugate coherence vectors
                ksim = ia*NA+iap
                simuV2PM[:,ksim] = 1/2*(Real + Imag*1j)
                ksim = iap*NA+ia          # 
                simuV2PM[:,ksim] = 1/2*(Real - Imag*1j)
        
        simuP2VM = np.linalg.pinv(simuV2PM)
        
    return simuV2PM, simuP2VM</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.create_CfObj"><code class="name flex">
<span>def <span class="ident">create_CfObj</span></span>(<span>spectra, Obs, Target, InterfArray, R=140)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the coherent flux (photometries and mutual intensities) of the
object along the given spectra for the given interferometric array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spectra</code></strong> :&ensp;<code>ARRAY</code></dt>
<dd>Spectral sampling.</dd>
<dt><strong><code>Obs</code></strong> :&ensp;<code>OBS CLASS OBJECT</code></dt>
<dd>Contains information on the object position in the sky.</dd>
<dt><strong><code>Target</code></strong> :&ensp;<code>TARGET CLASS OBJECT</code></dt>
<dd>Contains information on the target geometry, magnitude, etc&hellip;</dd>
<dt><strong><code>InterfArray</code></strong> :&ensp;<code>INTERFARRAY CLASS OBJECT</code></dt>
<dd>Contains information on the interferometer geometry, transmission, etc&hellip;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>CoherentFluxObject</code></strong> :&ensp;<code>ARRAY [MW,NB]</code></dt>
<dd>Coherent flux sorted like follows:
- 0 &hellip; NA: photometries
- NA &hellip; NA+NIN: Real(Cf)
- NA &hellip; NIN:NB: Imag(Cf)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_CfObj(spectra,Obs,Target,InterfArray,R=140):
    &#34;&#34;&#34;
    Returns the coherent flux (photometries and mutual intensities) of the
    object along the given spectra for the given interferometric array.

    Parameters
    ----------
    spectra : ARRAY
        Spectral sampling.
    Obs : OBS CLASS OBJECT
        Contains information on the object position in the sky.
    Target : TARGET CLASS OBJECT
        Contains information on the target geometry, magnitude, etc...
    InterfArray : INTERFARRAY CLASS OBJECT
        Contains information on the interferometer geometry, transmission, etc...

    Returns
    -------
    CoherentFluxObject : ARRAY [MW,NB]
        Coherent flux sorted like follows:
            - 0 ... NA: photometries
            - NA ... NA+NIN: Real(Cf)
            - NA ... NIN:NB: Imag(Cf)

    &#34;&#34;&#34;
    
    MeanWavelength = np.mean(spectra)
    if hasattr(spectra, &#34;__len__&#34;):
        MW=len(spectra)
        MultiWavelength=True
    else:
        MultiWavelength=False
        spectra=np.array([spectra])
        MW=1

    
    VisObject, _,_,_=VanCittert(spectra,Obs,Target)
    mag = Target.Star1[&#39;SImag&#39;]
    # Luminance according to apparent magnitude
    Irradiance = np.ones_like(spectra)
    L0_ph = 702e8        # Photons.m-2.s-1.µm-1 at 0.7µm
    Lph_H = L0_ph*10**(-0.4*mag)
    
    if MultiWavelength:
        delta_wav = np.abs(spectra[0]-spectra[1])
    else:
        delta_wav = MeanWavelength/R
        
    UncohIrradiance = Irradiance*Lph_H*delta_wav             # [phot/m²/deltalmbda/s] Source Irradiance 

    Throughput = InterfArray.TelSurfaces*InterfArray.TelTransmissions
    
    NA=len(Throughput)
    NB=NA**2 ; NIN = int(NA*(NA-1)/2)
    
    CoherentFluxObject = np.zeros([MW,NB])
    for ia in range(NA):
        CoherentFluxObject[:,ia] = Throughput[ia]*UncohIrradiance
    
    for ia in range(NA):
        for iap in range(ia+1,NA):
            ib = posk(ia,iap,NA)
            CoherentFluxObject[:,NA+ib] = np.sqrt(CoherentFluxObject[:,ia]*CoherentFluxObject[:,iap])*np.real(VisObject[:,ib])
            CoherentFluxObject[:,NA+NIN+ib] = np.sqrt(CoherentFluxObject[:,ia]*CoherentFluxObject[:,iap])*np.imag(VisObject[:,ib])

    return CoherentFluxObject</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.create_obsfile"><code class="name flex">
<span>def <span class="ident">create_obsfile</span></span>(<span>spectra, Obs, Target, savingfilepath='', savedir='', ext='pdf', overwrite=False, display=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the coherent flux matrix of the object at the entrance of the
fringe sensor and save it into a fitsfile.
It takes into account:
- star spectral distribution (BlackBody approx, or flat)
- Array transmission
- Visibility on the different baselines</p>
<p>These parameters are given by the objects Obs and Target.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spectra</code></strong> :&ensp;<code>FLOAT ARRAY [NW]</code></dt>
<dd>Spectral sampling.</dd>
<dt><strong><code>Obs</code></strong> :&ensp;<code>OBSERVATION CLASS OBJECT</code></dt>
<dd>Contains the information on the interferometer and other things.</dd>
<dt><strong><code>Target</code></strong> :&ensp;<code>OBJECT CLASS OBJECT</code></dt>
<dd>Contains the information on the object.</dd>
<dt><strong><code>savingfilepath</code></strong> :&ensp;<code>STRING</code>, optional</dt>
<dd>File name. The default is ''.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If True, overwrite the existing file. The default is False.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If True, display some plots. The default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>CohIrradiance</code></strong> :&ensp;<code>COMPLEX ARRAY [NW,NB]</code></dt>
<dd>Spectral photon distribution including visibility and star photometry
on all baselines. [ph/s].</dd>
<dt><strong><code>UncohIrradiance</code></strong> :&ensp;<code>FLOAT ARRAY [NW]</code></dt>
<dd>Spectral photon distribution [pht/s/telescope/µm] of the star without visibility..</dd>
<dt><strong><code>VisObj</code></strong> :&ensp;<code>COMPLEX ARRAY [NW,NB]</code></dt>
<dd>Visibility of the object, normalised between 0 and 1.</dd>
<dt><strong><code>BaseNorms</code></strong> :&ensp;<code>FLOAT ARRAY [NIN</code> or <code>NB ?]</code></dt>
<dd>Norm of the different baselines.</dd>
<dt><strong><code>TelNames</code></strong> :&ensp;<code>STRING ARRAY [NA]</code></dt>
<dd>Names of the telescopes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_obsfile(spectra, Obs, Target, savingfilepath=&#39;&#39;,
                   savedir=&#39;&#39;, ext=&#39;pdf&#39;,overwrite=False, display=False,
                   verbose=True):
    &#34;&#34;&#34;
    Creates the coherent flux matrix of the object at the entrance of the 
    fringe sensor and save it into a fitsfile.
    It takes into account:
        - star spectral distribution (BlackBody approx, or flat)
        - Array transmission
        - Visibility on the different baselines
    
    These parameters are given by the objects Obs and Target.

    Parameters
    ----------
    spectra : FLOAT ARRAY [NW]
        Spectral sampling.
    Obs : OBSERVATION CLASS OBJECT
        Contains the information on the interferometer and other things.
    Target : OBJECT CLASS OBJECT
        Contains the information on the object.
    savingfilepath : STRING, optional
        File name. The default is &#39;&#39;.
    overwrite : BOOLEAN, optional
        If True, overwrite the existing file. The default is False.
    display : BOOLEAN, optional
        If True, display some plots. The default is False.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    CohIrradiance : COMPLEX ARRAY [NW,NB]
        Spectral photon distribution including visibility and star photometry
        on all baselines. [ph/s].
    UncohIrradiance : FLOAT ARRAY [NW]
        Spectral photon distribution [pht/s/telescope/µm] of the star without visibility..
    VisObj : COMPLEX ARRAY [NW,NB]
        Visibility of the object, normalised between 0 and 1.
    BaseNorms : FLOAT ARRAY [NIN or NB ?]
        Norm of the different baselines.
    TelNames : STRING ARRAY [NA]
        Names of the telescopes.
    &#34;&#34;&#34;

    # spectra = 1/sigma     # [µm] Wavelengths
    NW = len(spectra)     # [int] Wavelengths number
    
    # First case: Temperature of the first star is given
    # We compute a BlackBody model
    if &#39;T&#39; in Target.Star1.keys():    
        T=Target.Star1[&#39;T&#39;]
        Irradiance = BBstar(spectra*1e-6, T)       # Create BB star model in wavelengths    
        Irradiance = Irradiance[::-1]             # (Reverse) the spectra according to sigmas
        norm = np.mean(Irradiance[(spectra&gt;=1.4)*(spectra&lt;=1.75)])    # Normalization of the flux on the whole H band
        Irradiance/=norm

    else:
        Irradiance=np.ones_like(spectra)
        
    magH = Target.Star1[&#39;Hmag&#39;]
    # Luminance according to apparent magnitude    
    
    L0_ph = 93.3e8        # Photons.m-2.s-1.µm-1 at 1.63µm
    
    Lph_H = L0_ph*10**(-0.4*magH)
    
    # Preference for photons directly to keep a uniform spectra
    UncohIrradiance = Irradiance*Lph_H             # [phot/s/m²/µm] Source Irradiance 
    
    # Using Watt as reference and converting in photons: drawback=non uniform spectra
    # L0_w = 7 * 10**(-10)                      # [W/m²/µm] Reference luminance at 1.65µm (Lena)
    # L0_w = 11.38 * 10**(-10)                  # [W/m²/µm] Reference luminance at 1.63µm (Bessel)
    # Lw_H = L0_w*10**(-0.4*magH)                        # Definition of the magnitude
    # UncohIrradiance_w = luminance*Lw_H / (h_*c_/spectra*1e6)          # [phot/s/m²/µm]

    filepath = Obs.Filepath
    if not os.path.exists(filepath):
        raise Exception(f&#34;{filepath} doesn&#39;t exist.&#34;)
    
    with fits.open(filepath) as hdu:
        ArrayParams = hdu[0].header
        NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
        ArrayName = ArrayParams[&#39;NAME&#39;]
        TelData = hdu[1].data
        BaseData = hdu[2].data
        
        TelNames = TelData[&#39;TelNames&#39;]
        TelCoordinates = TelData[&#39;TelCoordinates&#39;]
        TelTransmissions = TelData[&#39;TelTransmissions&#39;]
        TelSurfaces = TelData[&#39;TelSurfaces&#39;]
        BaseNames = BaseData[&#39;BaseNames&#39;]
        BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
        
        
    InterfArray = get_array(name=filepath)
    
    NB = NA**2
    NC = int(binom(NA,3))
    
    # Transportation of the star light into the interferometer
    Throughput = np.reshape(InterfArray.TelSurfaces*InterfArray.TelTransmissions,[1,NA])
    ThroughputMatrix = np.sqrt(np.dot(np.transpose(Throughput), Throughput))
    ThroughputMatrix = ThroughputMatrix.reshape([1,NB])
    # Matrix where the element at the (ia*NA+iap) position is Ta*Tap
    # UncohIrradianceAfterTelescopes = np.dot(np.diag(TelTransmissions),np.transpose(UncohIrradiance))
    
    # Projection of the base on the (u,v) plane
    #BaseNorms = get_Bproj(np.array(InterfArray.BaseNorms), Obs.AltAz[0])
    
    VisObj = np.zeros([NW,NB])*1j               # Object Visibility [normalised]
    CohIrradiance = np.zeros([NW,NB])*1j        # Source coherent Irradiance [phot/s/m²/deltalmbda]    
      
    # UncohIrradianceAfterTelescopes = UncohIrradiance*TelTransmissions*TelSurfaces
    

    if Target.Name == &#39;Unresolved&#39;:
        VisObj = np.ones([NW,NB])
        CPObj = np.zeros([NW,NC])
        
    elif Target.Name == &#39;Manual&#39;:
        phi = np.zeros([NW,NB])
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                phi[:,ia*NA+iap] = Target.Phases[ib]
                phi[:,iap*NA+ia] = -Target.Phases[ib]
        VisObj = np.exp(1j*phi)
        # VisObj = np.repeat(VisObj[np.newaxis,:],NW,axis=0)
        
        bispectrum = np.zeros([NW,NC])*1j
        for ia in range(NA):
            for iap in range(ia+1,NA):
                for iapp in range(iap+1,NA):
                    ci1 = VisObj[:,ia*NA+iap]
                    ci2 = VisObj[:,iap*NA+iapp]
                    ci3 = VisObj[:,iapp*NA+ia]
                    ic = poskfai(ia,iap,iapp,NA)
                    bispec = ci1*ci2*ci3
                    bispec[np.abs(bispec)&lt;0.05] = 0
                    bispectrum[:,ic] = bispec
        
    else:           # Van-Cittert theorem visibility
        visibilities,_,_,_ = VanCittert(spectra, Obs, Target,
                                        display=display, savedir=savedir, ext=ext)
        
        bispectrum = np.zeros([NW,NC])*1j
        
        for ia in range(NA):
            VisObj[:,ia*(NA+1)] = np.ones(NW)
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                VisObj[:,ia*NA+iap] = visibilities[:,ib]
                VisObj[:,iap*NA+ia] = np.conj(visibilities[:,ib])
                for iapp in range(iap+1,NA):
                    cs1 = VisObj[:,ia*NA+iap]     # Coherent flux (ia,iap) 
                    cs2 = VisObj[:,iap*NA+iapp]  # Coherent flux (iap,iapp) 
                    cs3 = VisObj[:,iapp*NA+ia] # Coherent flux (iapp,ia) 
                    ic = poskfai(ia,iap,iapp,NA) 
                    bispectrum[:,ic]+=cs1*cs2*cs3
                    
        CPObj = np.angle(bispectrum)
        
    for iw in range(NW):    
        CohIrradiance[iw] = UncohIrradiance[iw] * ThroughputMatrix * VisObj[iw]

    BaseNorms, TelNames = InterfArray.BaseNorms, InterfArray.TelNames
    
    if display:
        from . import config
        
        fig = plt.figure(&#34;Visibility of the star&#34;,figsize=(12,9))
        linestyles=[]
        (ax1,ax2,ax5),(ax3,ax4,ax6) = fig.subplots(nrows=2,ncols=3,gridspec_kw={&#39;width_ratios&#39;:[3,3,1]})
        
        gs=ax3.get_gridspec()
        ax3.remove() ; ax4.remove()
        # Add a unique axe on the last row
        ax3 = fig.add_subplot(gs[1,:])
        
        ax5.axis(&#39;off&#39;) ; ax6.axis(&#39;off&#39;)
        
        ax1.set_title(&#39;|V|&#39;)
        ax2.set_title(&#39;arg(V)&#39;)
        ax3.set_title(&#39;Coherent Irradiance $\Gamma$&#39;)
        
        ax1.plot(spectra, np.abs(VisObj[:,0]),color=&#39;red&#39;)
        ax3.plot(spectra, UncohIrradiance,color=&#39;red&#39;)  # Same for all baselines
        linestyles.append(mlines.Line2D([],[],
                                        color=&#39;red&#39;,
                                        label=f&#34;Uncoherent flux&#34;))

        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib = posk(ia,iap,NA)
                if ib&lt;8:
                    cl=colors[ib] ; ls=&#39;solid&#39;
                else:
                    cl=colors[ib-8] ; ls=&#39;--&#39;
                ax1.plot(spectra, np.abs(VisObj[:,ib]),
                         color=cl,linestyle=ls)
                ax2.plot(spectra, np.angle(VisObj[:,ib]),
                         color=cl,linestyle=ls)
                ax3.plot(spectra, np.abs(CohIrradiance[:,ib]),
                         color=cl,linestyle=ls)
                linestyles.append(mlines.Line2D([],[],
                                                color=cl,linestyle=ls,
                                                label=f&#34;{BaseNames[ib]}:{round(BaseNorms[ib])}m&#34;))
        
        ax1.set_ylim(0,1.1) ; ax2.set_ylim(-np.pi,np.pi)
        ax1.set_xlabel(&#39;Wavelengths [µm]&#39;)
        ax2.set_xlabel(&#39;Wavelengths [µm]&#39;)
        ax3.set_xlabel(&#39;Wavelengths [µm]&#39;)
        
        ax5.legend(handles=linestyles, loc=&#39;upper right&#39;)
        
        ax3.set_ylabel(&#39;Coherent Irradiance \n [photons/s/m²/µm]&#39;)
        ax1.grid(True);ax2.grid(True);ax3.grid(True)
        
        config.newfig+=1       
        
        
    if savingfilepath==&#39;no&#39;:
        if verbose:
            print(&#34;Not saving the data.&#34;)
        return CohIrradiance, UncohIrradiance, VisObj, BaseNorms, TelNames

    else:
        fileexists = os.path.exists(savingfilepath)
        if fileexists:
            if verbose:
                print(f&#39;{savingfilepath} already exists.&#39;)
            if overwrite:
                os.remove(savingfilepath)
            else:
                if verbose:
                    print(&#34;The file already exists and you didn&#39;t ask to overwrite it. I don&#39;t save the file.&#34;)          
                return CohIrradiance, UncohIrradiance, VisObj, BaseNorms, TelNames
    
        filedir = &#39;/&#39;.join(savingfilepath.split(&#39;/&#39;)[:-1])+&#39;/&#39;

    
        if not os.path.exists(filedir):
            os.makedirs(filedir)
        
        
        # hdr = ArrayParams
        hdr = fits.Header()
        
        hdr[&#39;Filepath&#39;] = savingfilepath.split(&#39;/&#39;)[-1]
        hdr[&#39;ARRAY&#39;] = Obs.ArrayName
        hdr[&#39;AltAz&#39;] = Obs.AltAz
        hdr[&#39;Target&#39;] = Target.Name
        hdr[&#39;NA&#39;] = NA
        hdr[&#39;NIN&#39;] = NIN
        hdr[&#39;MINWAVE&#39;] = spectra[0]
        hdr[&#39;MAXWAVE&#39;] = spectra[-1]
        hdr[&#39;DWAVE&#39;] = spectra[1] - spectra[0]
    
        for attr in vars(Target).keys():
            if type(getattr(Target, attr)) is not dict:    
                if attr not in [&#39;Name&#39;,&#39;Filepath&#39;, &#39;Phases&#39;]:
                    hdr[attr] = getattr(Target, attr)
            else:
                for key in getattr(Target, attr).keys():
                    if key == &#39;Position&#39;:
                        hdr[f&#34;{attr}_alpha&#34;] = getattr(Target, attr)[key][0]
                        hdr[f&#34;{attr}_beta&#34;] = getattr(Target, attr)[key][1]
                    else:
                        hdr[f&#34;{attr}_{key}&#34;] = getattr(Target, attr)[key]
                    
        for attr in vars(Obs).keys():
            if isinstance(getattr(Obs, attr),
                          (str, int, float, complex, bool,
                           np.floating, np.integer, np.complexfloating,
                           np.bool_)):
                
                if attr != &#39;Filepath&#39;:
                    if attr != ArrayName:
                        hdr[attr] = getattr(Obs, attr)
                else:
                    hdr[&#39;ArrayFile&#39;] = getattr(Obs, attr).split(&#39;/&#39;)[-1]
            
        
        primary = fits.PrimaryHDU(header=hdr)
        
        im1 = fits.ImageHDU(np.real(VisObj), name=&#39;VReal&#39;)
        im2 = fits.ImageHDU(np.imag(VisObj), name=&#39;VImag&#39;)
        im3 = fits.ImageHDU(np.real(CohIrradiance), name=&#39;CfReal&#39;)
        im4 = fits.ImageHDU(np.imag(CohIrradiance), name=&#39;CfImag&#39;)
        im5 = fits.ImageHDU(CPObj, name=&#39;Closure Phase&#39;)
        
        col1 = fits.Column(name=&#39;WLsampling&#39;, format=&#39;1D&#39;, array=spectra)
        hdu1 = fits.BinTableHDU.from_columns([col1], name=&#39;spectra&#39; )
        
        hdu = fits.HDUList([primary,hdu1,im1,im2,im3,im4,im5])
        
        if verbose:
            print(f&#39;Saving file into {savingfilepath}&#39;)
        hdu.writeto(savingfilepath)
    
    return CohIrradiance, UncohIrradiance, VisObj, BaseNorms, TelNames</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.generate_spectra"><code class="name flex">
<span>def <span class="ident">generate_spectra</span></span>(<span>lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode='linear_sig')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the micro and macro wavenumbers to use for the simulation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>vector [MW]</code></dt>
<dd>Wavenumbers</dd>
<dt><strong><code>OW</code></strong> :&ensp;<code>int</code></dt>
<dd>Oversampling wavenumbers.</dd>
<dt><strong><code>sigmaband</code></strong> :&ensp;<code>vector [MW]</code>, optional</dt>
<dd>Channel bandwidth</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Way of generating the spectras. The default is 'regular'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Mode needs to be in acceptable values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>[MW*OW] floats</code></dt>
<dd>Micro Wavenumbers.</dd>
<dt><strong><code>sigmaM</code></strong> :&ensp;<code>[MW] floats</code></dt>
<dd>Macro wavenumbers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_spectra(lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode=&#39;linear_sig&#39;):
    &#34;&#34;&#34;
    Returns the micro and macro wavenumbers to use for the simulation

    Parameters
    ----------
    sigma : vector [MW]
        Wavenumbers
    OW : int
        Oversampling wavenumbers.
    sigmaband : vector [MW], optional
        Channel bandwidth
    mode : string, optional
        Way of generating the spectras. The default is &#39;regular&#39;.

    Raises
    ------
    ValueError
        Mode needs to be in acceptable values.

    Returns
    -------
    sigma : [MW*OW] floats
        Micro Wavenumbers.
    sigmaM : [MW] floats
        Macro wavenumbers.

    &#34;&#34;&#34;
    possible_modes = [&#39;linear_wl&#39;,&#39;linear_sig&#39;]
    
    if R:
        if MW:
            raise Exception(&#34;MW can&#39;t be given with R.&#34;)
        deltalmbda = np.mean([lmbda1,lmbda2])/R
        MW = int(round((lmbda2-lmbda1)/deltalmbda))
        
    elif not MW:
        raise Exception(&#34;MW or R must be given.&#34;)
    
    if mode == &#39;linear_sig&#39;:
        sig1, sig2 = np.min([1/lmbda1,1/lmbda2]), np.max([1/lmbda1,1/lmbda2])
        sigma = np.linspace(sig1, sig2, MW)
        spectra = np.sort(1/sigma)

        deltasig = sigma[1] - sigma[0]
        # sigmaband = spectraband*spectra**(-2)
        
        sigma_os = np.array([])
        for i in range(MW):
            sigbottom = sigma[i]-deltasig/2
            sigtop = sigma[i]+deltasig/2
            sigma_temp = np.linspace(sigbottom, sigtop, OW+1)[1:]
            sigma_os = np.concatenate((sigma_os,sigma_temp))
        spectra_os = np.sort(1/sigma_os)
        
    elif mode == &#39;linear_wl&#39;:
        spectra_os = np.array([])
        spectra = np.linspace(lmbda1, lmbda2, MW)
        deltalmbda = spectra[1] - spectra[0]
        for i in range(MW):
            wlbottom = spectra[i]-deltalmbda/2
            wltop = spectra[i]+deltalmbda/2
            spectra_temp = np.linspace(wlbottom, wltop, OW+1)[1:]
            spectra_os = np.concatenate((spectra_os,spectra_temp))
    
    else:
        raise ValueError(f&#39;mode={mode}. Unknown mode, needs to be in {possible_modes}.&#39;)
    
    return spectra_os, spectra</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.generate_spectra0"><code class="name flex">
<span>def <span class="ident">generate_spectra0</span></span>(<span>lmbda1, lmbda2, R, sampling='linearsig')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a spectra of a grism of resolution R linearly spaced on wavenumbers
or wavelength</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lmbda1</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimal wavelength.</dd>
<dt><strong><code>lmbda2</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximal wavelength.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>int</code></dt>
<dd>Spectral resolution.</dd>
<dt><strong><code>sampling</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>Method of sampling. The default is 'linearsig'.
OPTIONS:
- 'linearsig': linear in wavenumbers [advised]
- 'linearlambda': linear in wavelengths</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>spectra</code></strong> :&ensp;<code>ARRAY 1D</code></dt>
<dd>Ascending order.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>ARRAY 1D</code></dt>
<dd>Descending order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_spectra0(lmbda1,lmbda2,R, sampling=&#39;linearsig&#39;):
    &#34;&#34;&#34;
    Generates a spectra of a grism of resolution R linearly spaced on wavenumbers
    or wavelength

    Parameters
    ----------
    lmbda1 : float
        Minimal wavelength.
    lmbda2 : float
        Maximal wavelength.
    R : int
        Spectral resolution.
    sampling : TYPE, optional
        Method of sampling. The default is &#39;linearsig&#39;.
        OPTIONS:
            - &#39;linearsig&#39;: linear in wavenumbers [advised]
            - &#39;linearlambda&#39;: linear in wavelengths

    Returns
    -------
    spectra : ARRAY 1D
        Ascending order.
    sigma : ARRAY 1D
        Descending order.

    &#34;&#34;&#34;
    
    if sampling == &#39;linearsig&#39;:
        sigma1 = 1/lmbda2
        sigma2 = 1/lmbda1
        deltasig = np.min([sigma1,sigma2])/R
        sigma = np.arange(sigma1,sigma2,deltasig)
        sigma = np.sort(sigma)[::-1]
        spectra = 1/sigma
        
    elif sampling == &#39;linearlambda&#39;:
        deltalmbda = np.min([lmbda1,lmbda2])/R
        spectra = np.arange(lmbda1, lmbda2, deltalmbda)
        sigma = 1/spectra
        
    return spectra, sigma</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.get_Bproj"><code class="name flex">
<span>def <span class="ident">get_Bproj</span></span>(<span>baseline, theta)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates projected bases according to the viewed angle in radian</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>baseline</code></strong> :&ensp;<code>float [meter]</code></dt>
<dd>Distance between telescopes in meters.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float [radian]</code></dt>
<dd>Angle viewed by the base (depend on declination and azimuth).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Bproj</code></strong> :&ensp;<code>float [meter]</code></dt>
<dd>Projected base.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_Bproj(baseline, theta):
    &#34;&#34;&#34;
    Calculates projected bases according to the viewed angle in radian

    Parameters
    ----------
    baseline : float [meter]
        Distance between telescopes in meters.
    theta : float [radian]
        Angle viewed by the base (depend on declination and azimuth).
        
    Returns
    -------
    Bproj : float [meter]
        Projected base.

    &#34;&#34;&#34;
    
    Bproj = baseline * np.sin(theta)
    return Bproj</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.get_CfDisturbance"><code class="name flex">
<span>def <span class="ident">get_CfDisturbance</span></span>(<span>DisturbanceFile, spectra, timestamps, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_CfDisturbance(DisturbanceFile, spectra, timestamps,verbose=False):
    
    from .config import piston_average,NA,NB
    NT = len(timestamps) ; NW = len(spectra)
    
    if &#39;fits&#39; not in DisturbanceFile:
        if DisturbanceFile == &#39;NoDisturbance&#39;:
            PistonDisturbance = np.zeros([NT,NA])
            TransmissionDisturbance = np.ones([NT,NW,NA])
            
        elif DisturbanceFile == &#39;Foreground&#39;:
            Lc = config.FS[&#39;R&#39;]*config.PDspectra
            PistonDisturbance = np.zeros([NT,NA])
            for ia in range(NA):  # décoherencing of all telescopes
                PistonDisturbance[:,ia]=(ia-2)*2*Lc
            TransmissionDisturbance = np.ones([NT,NW,NA])
            
        elif DisturbanceFile == &#39;CophasedThenForeground&#39;:
            Lc = config.FS[&#39;R&#39;]*config.PDspectra
            PistonDisturbance = np.zeros([NT,NA])
            for ia in range(NA):  # décoherencing of all telescopes from it=100.
                PistonDisturbance[100:,ia]=(ia-2)*2*Lc
            TransmissionDisturbance = np.ones([NT,NW,NA])
    
        else:
            raise Exception(&#34;DisturbanceFile doesn&#39;t correspond to any valid case.&#34;)
    
    else:
        filetimestamps, filespectra, PistonDisturbance, TransmissionDisturbance,_,_,_,_ = get_infos(DisturbanceFile)
    
        PistonDisturbance = PistonDisturbance[:,:NA]
        TransmissionDisturbance = TransmissionDisturbance[:,:,:NA]
    
        # Interpolate on the time axis   
        newobservables = []
        for observable in [PistonDisturbance, TransmissionDisturbance]:
            f = interpolate.interp1d(filetimestamps,observable, axis=0, bounds_error=False, fill_value=(observable[0],observable[-1]))
            newobservables.append(f(timestamps))
            
        
        PistonDisturbance, TempTransmissionDisturbance = newobservables
        
        # Interpolate transmission on the spectral axis (Piston is not chromatic)    
        f = interpolate.interp1d(filespectra*1e6,TempTransmissionDisturbance, axis=1, bounds_error=False,fill_value=(TempTransmissionDisturbance[:,0,:],TempTransmissionDisturbance[:,-1,:]))
        TransmissionDisturbance = np.abs(f(spectra))

    if piston_average==1:
        if verbose:
            print(&#34;We subtract to the piston of each telescope its first value&#34;)
        PistonDisturbance = PistonDisturbance-PistonDisturbance[0]
    if piston_average==2:
        if verbose:
            print(&#34;We subtract the average of first piston to the piston of all telescopes.&#34;)
        PistonDisturbance = PistonDisturbance-np.mean(PistonDisturbance[0])
    elif piston_average==3:
        if verbose:
            print(&#34;We subtract to the piston of each telescope its temporal average.&#34;)
        PistonDisturbance = PistonDisturbance-np.mean(PistonDisturbance, axis=0)
        
    CfDisturbance = np.zeros([NT,NW,NB])*1j
    from cophasing import skeleton
    for it in range(NT):
        CfDisturbance[it,:,:] = skeleton.coh__pis2coh(PistonDisturbance[it,:], 1/spectra, ampl=np.sqrt(TransmissionDisturbance[it,:]))


    return CfDisturbance, PistonDisturbance, TransmissionDisturbance</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.get_CfObj"><code class="name flex">
<span>def <span class="ident">get_CfObj</span></span>(<span>filepath, spectra, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads data of an observation contained in a FITSfile.
Adapt the spectral sampling to the FS spectral sampling.
The coherent and uncoherent flux are given in Photons/µm/second at
the entrance of the fringe-sensor
Return the interpolated coherent flux.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>STRING</code></dt>
<dd>Filepath of the file that contains target information.</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>LIST</code> or <code>ARRAY</code></dt>
<dd>Spectral sampling of the output data (for interpolation).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FinalCoherentIrradiance, FinalComplexVisObj, ClosurePhase</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>FinalCoherentIrradiance</code></strong> :&ensp;<code>ARRAY[NW,NB]</code></dt>
<dd>Coherence Flux of the object in photons/s.</dd>
</dl>
<h2 id="finalcomplexvisobj">Finalcomplexvisobj</h2>
<p>Complex degree of mutual coherence. (between 0 and 1)</p>
<p>ClosurePhase : ARRAY[NW,NC]
Closure phases of the object in radian.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_CfObj(filepath, spectra,verbose=False):
    &#34;&#34;&#34;
    Reads data of an observation contained in a FITSfile.
    Adapt the spectral sampling to the FS spectral sampling.
    The coherent and uncoherent flux are given in Photons/µm/second at 
    the entrance of the fringe-sensor
    Return the interpolated coherent flux.

    Parameters
    ----------
    filepath : STRING
        Filepath of the file that contains target information.
    spectra : LIST or ARRAY
        Spectral sampling of the output data (for interpolation).

    Returns
    -------
    FinalCoherentIrradiance, FinalComplexVisObj, ClosurePhase
    
    FinalCoherentIrradiance : ARRAY[NW,NB]
        Coherence Flux of the object in photons/s.
        
    FinalComplexVisObj:
        Complex degree of mutual coherence. (between 0 and 1)
        
    ClosurePhase : ARRAY[NW,NC]
        Closure phases of the object in radian.
    &#34;&#34;&#34;

    fileexists = os.path.exists(filepath)
    if not fileexists:
        try:
            if verbose:
                print(&#34;Looking for the observation file into the package&#39;s data&#34;)
            filepath = pkg_resources.resource_stream(__name__,filepath)
        except:
            raise Exception(f&#34;{filepath} doesn&#39;t exists.&#34;)          
            
    with fits.open(filepath) as hdu:

        ObsParams = hdu[0].header
        WLsampling = hdu[&#39;SPECTRA&#39;].data[&#39;WLsampling&#39;]
        
        realV = hdu[&#39;VReal&#39;].data
        imagV = hdu[&#39;VImag&#39;].data
        
        realCf = hdu[&#39;CfReal&#39;].data
        imagCf = hdu[&#39;CfImag&#39;].data


    f = interpolate.interp1d(WLsampling, realCf, axis=0)
    NewRealCf = f(spectra)
    f = interpolate.interp1d(WLsampling, imagCf, axis=0)
    NewImagCf = f(spectra)
    NewImagCf[np.abs(NewImagCf)&lt;np.abs(NewRealCf)*1e-6]=0
    CoherentIrradiance = NewRealCf + NewImagCf*1j
    
    f = interpolate.interp1d(WLsampling, realV, axis=0)
    NewRealV = f(spectra)
    f = interpolate.interp1d(WLsampling, imagV, axis=0)
    NewImagV = f(spectra)
    NewImagV[np.abs(NewImagV)&lt;np.abs(NewRealV)*1e-6]=0
    ComplexVisObj = NewRealV + NewImagV*1j
    
    if isinstance(spectra,float):
        NW=1
        NBfile=len(CoherentIrradiance)
    else:
        NW, NBfile = CoherentIrradiance.shape
    NAfile = int(np.sqrt(NBfile))

    from .config import NA, NB, NC
    
    if NW!=1:
        ClosurePhase = np.zeros([NW,NC])
        FinalCoherentIrradiance = np.zeros([NW,NB])*1j
        FinalComplexVisObj = np.zeros([NW,NB])*1j

        for ia in range(NA):
            for iap in range(NA):
                ib = ia*NA+iap                    
                FinalCoherentIrradiance[:,ib] = CoherentIrradiance[:,ia*NAfile+iap]
                FinalComplexVisObj[:,ib] = ComplexVisObj[:,ia*NAfile+iap]
                
    else:
        ClosurePhase = np.zeros([NC])
        FinalCoherentIrradiance = np.zeros([NB])*1j
        FinalComplexVisObj = np.zeros([NB])*1j
        for ia in range(NA):
            for iap in range(NA):
                ib = ia*NA+iap
                FinalCoherentIrradiance[ib] = CoherentIrradiance[ia*NAfile+iap]
                FinalComplexVisObj[ib] = ComplexVisObj[ia*NAfile+iap]
                
                        
    if NA &lt; 3:
        return FinalCoherentIrradiance, FinalComplexVisObj
    
    else:
        if NW!=1:
            for ia in range(NA):
                for iap in range(ia+1,NA):
                    for iapp in range(iap+1,NA):
                        ic = poskfai(ia,iap,iapp,NA)
                        ci1 = CoherentIrradiance[:,ia*NAfile+iap]
                        ci2 = CoherentIrradiance[:,iap*NAfile+iapp]
                        ci3 = CoherentIrradiance[:,iapp*NAfile+ia]
                        ClosurePhase[:,ic] = np.angle(ci1*ci2*ci3)
        else:
            for ia in range(NA):
                for iap in range(ia+1,NA):
                    for iapp in range(iap+1,NA):
                        ic = poskfai(ia,iap,iapp,NA)
                        ci1 = CoherentIrradiance[ia*NAfile+iap]
                        ci2 = CoherentIrradiance[iap*NAfile+iapp]
                        ci3 = CoherentIrradiance[iapp*NAfile+ia]
                        ClosurePhase[ic] = np.angle(ci1*ci2*ci3)
        
    return FinalCoherentIrradiance, FinalComplexVisObj, ClosurePhase</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.get_ObsInformation"><code class="name flex">
<span>def <span class="ident">get_ObsInformation</span></span>(<span>ObservationFile, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ObsInformation(ObservationFile,verbose=False):
    
    from .config import ScienceObject, Observation
    from astropy.io import fits
    
    if not os.path.exists(ObservationFile):
        try:
            if verbose:
                print(&#34;Looking for the observation file into the package&#39;s data&#34;)
            ObservationFile = pkg_resources.resource_stream(__name__, ObservationFile)
        except:
            raise Exception(f&#34;{ObservationFile} doesn&#39;t exist.&#34;)
            
    hdul = fits.open(ObservationFile)
    hdr=hdul[&#39;PRIMARY&#39;].header
    
    Target = ScienceObject()
    Obs = Observation()
    
    Objects = list(dict.fromkeys([x[4] for x in hdr.keys() if &#39;Star&#39; in x]))
    for No in Objects:
        currentobject = f&#34;Star{No}&#34;
        attributes = [x.split(&#39;_&#39;)[1] for x in hdr.keys() if currentobject in x]
        StarCharacteristics={}
        for attr in attributes:
            if attr==&#39;alpha&#39;:
                if &#39;Position&#39; not in StarCharacteristics.keys():
                    StarCharacteristics[&#39;Position&#39;]=[0,0]
                StarCharacteristics[&#39;Position&#39;][0]=hdr[currentobject+f&#34;_{attr}&#34;]
            elif attr==&#39;beta&#39;:
                if &#39;Position&#39; not in StarCharacteristics.keys():
                    StarCharacteristics[&#39;Position&#39;]=(0,0)
                StarCharacteristics[&#39;Position&#39;][1]=hdr[currentobject+f&#34;_{attr}&#34;]
            else:
                StarCharacteristics[attr]=hdr[currentobject+f&#34;_{attr}&#34;]
                #setattr(dico,attr,hdr[currentobject+f&#34;_{attr}&#34;])
        setattr(Target, f&#34;Star{No}&#34;,StarCharacteristics)
    
    Target.Name = hdr[&#39;TARGET&#39;]
    Obs.ArrayName = hdr[&#39;ARRAY&#39;]
    Obs.Filepath = hdr[&#39;Filepath&#39;]
    for key,val in hdr.items():
        if key not in [&#39;TARGET&#39;,&#39;ARRAY&#39;]:
            setattr(Obs,key,val)   
        
    return Obs, Target</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.get_array"><code class="name flex">
<span>def <span class="ident">get_array</span></span>(<span>name='', band='H', getcoords=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the coordinates, baselines and base names of a given array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>STRING</code></dt>
<dd>Name of the array.</dd>
<dt><strong><code>getcoords</code></strong> :&ensp;<code>BOOLEAN</code>, optional</dt>
<dd>If True, add the array coordinates to the output.
The default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NameError</code></dt>
<dd>Name must be 'CHARA'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>TelNames</code></strong> :&ensp;<code>[NA] list strings</code></dt>
<dd>Names of the telescopes</dd>
<dt><strong><code>BaseNames</code></strong> :&ensp;<code>[NB] strings</code></dt>
<dd>Name of each baseline.</dd>
<dt><strong><code>BaseNorms</code></strong> :&ensp;<code>[NB] floats [meter]</code></dt>
<dd>Baselines.</dd>
<dt><strong><code>coords</code></strong>, <strong><code>OPTIONAL</code></strong> :&ensp;<code>[NA,3] FLOAT ARRAY [meter]</code></dt>
<dd>Coordinates of the array, following the format:
(XOFFSET,YOFFSET,ZOFFSET) where:
XOFFSET - East offset in microns from S1
YOFFSET - North offset in microns from S1
ZOFFSET - vertical (+ is up) offset in microns from S1,,)
Take S1 as reference.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_array(name=&#39;&#39;,band=&#39;H&#39;,getcoords=False,
              verbose=False):
    &#34;&#34;&#34;
    Returns the coordinates, baselines and base names of a given array

    Parameters
    ----------
    name : STRING
        Name of the array.
    getcoords : BOOLEAN, optional
        If True, add the array coordinates to the output.
        The default is False.

    Raises
    ------
    NameError
        Name must be &#39;CHARA&#39;.

    Returns
    -------
    TelNames : [NA] list strings
        Names of the telescopes
    BaseNames : [NB] strings
        Name of each baseline.
    BaseNorms : [NB] floats [meter]
        Baselines.
    coords, OPTIONAL: [NA,3] FLOAT ARRAY [meter]
        Coordinates of the array, following the format:
            (XOFFSET,YOFFSET,ZOFFSET) where:
                XOFFSET - East offset in microns from S1
                YOFFSET - North offset in microns from S1
                ZOFFSET - vertical (+ is up) offset in microns from S1,,)
        Take S1 as reference.
    
    &#34;&#34;&#34;
    
    class Interferometer:
        def __init__(self):
            pass
    InterfArray = Interferometer()
    
    if &#34;fits&#34; in name:
        filepath = name
        if not os.path.exists(filepath):
            try:
                if verbose:
                    print(&#34;Looking for the interferometer file into the package&#39;s data&#34;)
                filepath = pkg_resources.resource_stream(__name__,filepath)
            except:
                raise Exception(f&#34;{filepath} doesn&#39;t exist.&#34;)

        with fits.open(filepath) as hdu:
            ArrayParams = hdu[0].header
            NA, NIN = ArrayParams[&#39;NA&#39;], ArrayParams[&#39;NIN&#39;]
            InterfArray.NA = NA
            InterfArray.NIN = NIN
            TelData = hdu[1].data
            BaseData = hdu[2].data
        
            InterfArray.TelNames = TelData[&#39;TelNames&#39;]
            InterfArray.TelCoordinates = TelData[&#39;TelCoordinates&#39;]
            InterfArray.TelTransmissions = TelData[&#39;TelTransmissions&#39;]
            InterfArray.TelSurfaces = TelData[&#39;TelSurfaces&#39;]
            InterfArray.BaseNames = BaseData[&#39;BaseNames&#39;]
            InterfArray.BaseCoordinates = BaseData[&#39;BaseCoordinates&#39;]
            
        InterfArray.BaseNorms = np.linalg.norm(InterfArray.BaseCoordinates[:,:2],axis=1)
    
        
    elif name == &#39;CHARA&#39;:         
            
        #official coordinates in [µm]
        TelCoordinates= np.array([[125333989.819,305932632.737,-5909735.735],\
                                 [70396607.118,269713282.258,-2796743.645],\
                                     [0,0,0],\
                                         [-5746854.437,33580641.636,636719.086],\
                                             [-175073332.211,216320434.499,-10791111.235],\
                                                 [-69093582.796,199334733.235,467336.023]])
        TelCoordinates=TelCoordinates*1e-6      # [m]
        
        NA = np.shape(TelCoordinates)[0]
        
        TelNames = [&#39;E1&#39;,&#39;E2&#39;,&#39;S1&#39;,&#39;S2&#39;,&#39;W1&#39;,&#39;W2&#39;]
        BaseNames = []
        BaseCoordinates =[]

        for ia in range(NA):
            for iap in range(ia+1,NA):
                BaseNames.append(str(TelNames[ia]+TelNames[iap]))
                BaseCoordinates.append([TelCoordinates[ia,0]-TelCoordinates[iap,0],
                                        TelCoordinates[ia,1]-TelCoordinates[iap,1],
                                        TelCoordinates[ia,2]-TelCoordinates[iap,2]])
        BaseCoordinates = np.array(BaseCoordinates)        
        BaseNorms = np.linalg.norm(BaseCoordinates[:,:2],axis=1)

        InterfArray.NA = NA
        InterfArray.TelNames=TelNames
        InterfArray.BaseNorms=BaseNorms
        InterfArray.BaseNames = BaseNames
        InterfArray.TelCoordinates = TelCoordinates
        InterfArray.BaseCoordinates = BaseCoordinates
        
        transmission, surface = info_array(name,band)
        InterfArray.TelSurfaces = np.ones(NA)*surface
        InterfArray.TelTransmissions = np.ones(NA)*transmission
        
    else:
        raise Exception(&#34;For defining the array, you must give a file \
or a name (currently only CHARA is available).&#34;)
        
    return InterfArray</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.get_infos"><code class="name flex">
<span>def <span class="ident">get_infos</span></span>(<span>file, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_infos(file,verbose=False):
    
    if not os.path.exists(file):
        try:
            if verbose:
                print(&#34;Looking for the disturbance file into the package&#39;s data&#34;)
            file = pkg_resources.resource_stream(__name__,file)
        except:
            raise Exception(f&#34;{file} doesn&#39;t exist.&#34;)
    
    with fits.open(file) as hdu:
        hdr = hdu[0].header
        dt = hdr[&#39;DT&#39;]
        NT = hdr[&#39;NT&#39;]
        piston = hdu[&#39;Piston&#39;].data
        transmission = hdu[&#39;transmission&#39;].data
        filetimestamps = np.arange(NT)*dt
        filelmbdas = hdu[&#39;LambdaSampling&#39;].data[&#39;lambdas&#39;]
        try:
            PSD = hdu[&#39;Last tel PSD&#39;].data
            Filter = hdu[&#39;Disturbance Filter&#39;].data
            
            df = hdr[&#39;df&#39;]
            NF = len(PSD)
            FreqSampling = np.arange(NF)*df
            
        except:
            FreqSampling = np.zeros(NT); PSD = np.zeros(NT); Filter = np.zeros(NT)

    return filetimestamps,filelmbdas, piston, transmission, FreqSampling, PSD, Filter,hdr</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.get_subarray"><code class="name flex">
<span>def <span class="ident">get_subarray</span></span>(<span>pup_used, dsp_all, TelNames, base)</span>
</code></dt>
<dd>
<div class="desc"><p>From the visibility matrix of the whole array (dependant on the object),
returns the visibility matrix of the array made of the given pupils.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pup_used</code></strong> :&ensp;<code>string LIST [NA]</code></dt>
<dd>Names of the pupils of the subarray.</dd>
<dt><strong><code>dsp_all</code></strong> :&ensp;<code>float [NW,NA0**2]</code></dt>
<dd>The visibility matrix of the whole array.</dd>
<dt><strong><code>TelNames</code></strong> :&ensp;<code>string LIST [NA0]</code></dt>
<dd>Names of the pupils composing the whole array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dsp</code></strong> :&ensp;<code>float [NW,NA**2]</code></dt>
<dd>The visibility matrix of the whole array.</dd>
<dt><strong><code>base</code></strong> :&ensp;<code>string list [NA**2]</code></dt>
<dd>Base names of the subarray.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_subarray(pup_used, dsp_all, TelNames, base):
    &#34;&#34;&#34;
    From the visibility matrix of the whole array (dependant on the object),
    returns the visibility matrix of the array made of the given pupils.

    Parameters
    ----------
    pup_used : string LIST [NA]
        Names of the pupils of the subarray.
    dsp_all : float [NW,NA0**2]
        The visibility matrix of the whole array.
    TelNames : string LIST [NA0]
        Names of the pupils composing the whole array.

    Returns
    -------
    dsp : float [NW,NA**2]
        The visibility matrix of the whole array.
    base : string list [NA**2]
        Base names of the subarray.

    &#34;&#34;&#34;
    
    NA = len(pup_used)
    NA0 = len(TelNames)
    NW = np.shape(dsp_all)[0]
    dsp = np.zeros([NW,NA**2])
    tmp = base
    base=[]
    for ia in range(NA):
        a = TelNames.index(pup_used[ia])
        # dsp[:,ia*(NA+1)] = dsp_all[:,a*(NA0+1)]
        # base.append(tmp[a*(NA0+1)])
        for iap in range(NA):
            k = ia*NA+iap
            ap = TelNames.index(pup_used[iap])
            kp = a*NA0+ap
            dsp[:,k] = dsp_all[:,kp]
            base.append(tmp[kp])
    # import pdb; pdb.set_trace()
   
    return dsp, base, NA</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.get_visibility"><code class="name flex">
<span>def <span class="ident">get_visibility</span></span>(<span>alpha, baseline, spectra, model='disk')</span>
</code></dt>
<dd>
<div class="desc"><p>Using the Bessel expression of the visibility of a centered circular star,
returns the spectral absolute visibility curve of a centered star of
angular diameter alpha as seen with the given baseline distance.
Replaced by VanCittert function that calculates complex visibilities
with a more realistic calculation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float [radian]</code></dt>
<dd>Angular diameter</dd>
<dt><strong><code>base</code></strong> :&ensp;<code>float [meter]</code></dt>
<dd>Baseline</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>[MW] floats [µm]</code></dt>
<dd>Wavelength.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>The model of the object. The default is 'disk'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>[MW]</code></dt>
<dd>Spectral visibilities of the object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_visibility(alpha, baseline, spectra, model=&#39;disk&#39;):
    &#34;&#34;&#34;
    Using the Bessel expression of the visibility of a centered circular star,
    returns the spectral absolute visibility curve of a centered star of 
    angular diameter alpha as seen with the given baseline distance.
    Replaced by VanCittert function that calculates complex visibilities
    with a more realistic calculation.

    Parameters
    ----------
    alpha : float [radian]
        Angular diameter
    base : float [meter]
        Baseline
    spectra : [MW] floats [µm]
        Wavelength.
    model : string, optional
        The model of the object. The default is &#39;disk&#39;.

    Returns
    -------
    V : [MW]
        Spectral visibilities of the object.

    &#34;&#34;&#34;
    spectra = spectra*1e-6
    if model == &#39;disk&#39;:
        if baseline == 0:
            V = 1
        else:
            V = np.abs(2*jv(1, np.pi*alpha*baseline/spectra)/(np.pi*alpha*baseline/spectra))

    return V</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.info_array"><code class="name flex">
<span>def <span class="ident">info_array</span></span>(<span>array, band)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the transmission efficiencies of the CHARA interferometer in the
expected bands: so far, R and H.
Gives the same transmission for all telescopes.
Take into account:
- Telescope mirror transmission
- Injection loss: in fibers
- Strehl ratio:
- Beam splitters - Part of the flux is used for:
- For AO in R band
- For image control in R band
- For photometry calibration in R band</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>STRING</code></dt>
<dd>Array name.</dd>
<dt><strong><code>band</code></strong> :&ensp;<code>STRING</code></dt>
<dd>Observation band: H or R.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If array is not CHARA.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>transmission</code></strong> :&ensp;<code>FLOAT</code></dt>
<dd>Total transmission.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info_array(array, band):
    &#34;&#34;&#34;
    Stores the transmission efficiencies of the CHARA interferometer in the
    expected bands: so far, R and H.
    Gives the same transmission for all telescopes.
    Take into account:
        - Telescope mirror transmission
        - Injection loss: in fibers
        - Strehl ratio: 
        - Beam splitters - Part of the flux is used for:
            - For AO in R band
            - For image control in R band
            - For photometry calibration in R band

    Parameters
    ----------
    array : STRING
        Array name.
    band : STRING
        Observation band: H or R.

    Raises
    ------
    ValueError
        If array is not CHARA.

    Returns
    -------
    transmission : FLOAT
        Total transmission.

    &#34;&#34;&#34;
    if array in [&#39;chara&#39;,&#39;CHARA&#39;]: # information in SPICA JOSAA paper
        if band == &#39;H&#39;:     
            T_tel = 0.1
            T_inj = 0.65
            T_strehl = 0.8
            T_BS = 1            # No beam splitter in H ? OA?
        
        if band == &#39;R&#39;:
            T_tel = 0.03
            T_inj = 0.5
            T_strehl = 0.8
            T_BS = 0.88         # Transmission beam-splitter before injection
        
        # Diameter of a telescope and collecting surface [meter²]
        diameter = 1                            
        surface = np.pi*diameter**2/4            
        
        surface = 0.74 #MAM thesis - diameter=1m and occultation=0.25m
                                
    else:
        raise ValueError(&#39;So far, there is data for &#34;chara&#34; only.&#39;)
        
    transmission = T_tel*T_inj*T_strehl*T_BS

    return transmission, surface</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.makeA2P"><code class="name flex">
<span>def <span class="ident">makeA2P</span></span>(<span>descr, modulator, verbose=False, clean_up=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds an A2P matrix from a high-level description descr of the FTchip.
descr (NIN,2) gives for each baseline (order 01,02,..,12,13,&hellip;) the amplitude ratio for pups 1 &amp; 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeA2P(descr, modulator, verbose=False,clean_up=False):
    &#34;&#34;&#34;Builds an A2P matrix from a high-level description descr of the FTchip.
       descr (NIN,2) gives for each baseline (order 01,02,..,12,13,...) the amplitude ratio for pups 1 &amp; 2&#34;&#34;&#34;
    
    
    descr = np.array(descr) # Make sure it is an array so that the indexation works well
    nb_in=len(descr)
    
    NA=int(round((1+np.sqrt(1+8*nb_in))/2)) # inversion analytique de la ligne suivante
    NIN=NA*(NA-1)//2
    if NIN != nb_in:
        if verbose:
            print(&#39;Taille descr bizarre, attendu=&#39;,NIN)
        
    NQ = np.shape(modulator)[0] ; NP=NIN*NQ
    if NQ==4:
        alphabet = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]
    elif NQ==2:
        alphabet = [&#39;A&#39;,&#39;C&#39;]
    
    conventional_ich = []
    for ia in range(NA):
        for iap in range(ia+1,NA):
            for iq in range(NQ):
                conventional_ich.append((int(f&#34;{ia+1}{iap+1}&#34;),alphabet[iq]))
    
    ich = conventional_ich

    A2Pgen=np.zeros((NIN,NQ,NA),dtype=complex) #(base_out=[ia,iap],ABCD,ia_in)
    active_ich=[1]*NIN
    ib=0
    for ia in range(NA):
        for iap in range(ia+1,NA):
            A2Pgen[ib,:,ia ]=modulator[:,0]*descr[ib,0]
            A2Pgen[ib,:,iap]=modulator[:,1]*descr[ib,1]
            if not descr[ib,0]*descr[ib,1]:
                active_ich[ib]=0        # This baseline is not measured
            ib+=1
            
    A2P=np.reshape(A2Pgen,(NP,NA))
    lightA2P=np.copy(A2P)
    
    if clean_up:
        inc=0
        for ip in range(NP):
            if (A2P[ip,:] == np.zeros(NA)).all():
                lightA2P = np.delete(lightA2P, ip-inc, axis=0) # Remove the line at position ip because it doesn&#39;t receive any flux
                del ich[ip-inc]
                inc+=1

    return lightA2P, ich, active_ich</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.oversample_wv"><code class="name flex">
<span>def <span class="ident">oversample_wv</span></span>(<span>spectra, OW, spectraband=[], mode='linear_sig')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the micro and macro wavenumbers to use for the simulation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spectra</code></strong> :&ensp;<code>vector [MW]</code></dt>
<dd>Wavelengths</dd>
<dt><strong><code>OW</code></strong> :&ensp;<code>int</code></dt>
<dd>Oversampling wavenumbers.</dd>
<dt><strong><code>spectraband</code></strong> :&ensp;<code>vector [MW]</code>, optional</dt>
<dd>Channel bandwidth</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Way of generating the spectras. The default is 'linear_sig'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Mode needs to be in acceptable values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>spectra_os</code></strong> :&ensp;<code>[MW*OW] floats</code></dt>
<dd>Oversampled micro Wavelengths.</dd>
<dt><strong><code>spectra</code></strong> :&ensp;<code>[MW] floats</code></dt>
<dd>Macro Wavelengths.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oversample_wv(spectra, OW, spectraband=[], mode=&#39;linear_sig&#39;):

# def oversample_wv(lmbda1, lmbda2, OW, MW=0, R=0, spectraband=[], mode=&#39;linear_sig&#39;):
    &#34;&#34;&#34;
    Returns the micro and macro wavenumbers to use for the simulation

    Parameters
    ----------
    spectra : vector [MW]
        Wavelengths
    OW : int
        Oversampling wavenumbers.
    spectraband : vector [MW], optional
        Channel bandwidth
    mode : string, optional
        Way of generating the spectras. The default is &#39;linear_sig&#39;.

    Raises
    ------
    ValueError
        Mode needs to be in acceptable values.

    Returns
    -------
    spectra_os : [MW*OW] floats
        Oversampled micro Wavelengths.
    spectra : [MW] floats
        Macro Wavelengths.

    &#34;&#34;&#34;
    possible_modes = [&#39;linear_wl&#39;,&#39;linear_sig&#39;]
    
    
    MW = len(spectra)
    
    spectra = np.sort(spectra)
    sigma = np.sort(1/spectra)
    
    
    if len(spectraband)==0:
        spectraband = np.zeros_like(spectra)
        sigmaband = np.zeros_like(spectra)
        for i in range(1,MW):
            spectraband[i] = spectra[i] - spectra[i-1]
            sigmaband[i] = sigma[i] - sigma[i-1]
        spectraband[0] = spectraband[1]
        sigmaband[0] = sigmaband[1]
    
    if mode == &#39;linear_sig&#39;:
        sigma = np.sort(1/spectra)
        sigmaband = spectraband*spectra**(-2)
        
        sigma_os = np.array([])
        for i in range(MW):
            sigbottom = sigma[i]-sigmaband[i]/2
            sigtop = sigma[i]+sigmaband[i]/2
            sigma_temp = np.linspace(sigbottom, sigtop, OW)
            sigma_os = np.concatenate((sigma_os,sigma_temp))
        spectra_os = np.sort(1/sigma_os)
        
    elif mode == &#39;linear_wl&#39;:
        spectra_os = np.array([])
        for i in range(MW):
            wlbottom = spectra[i]-spectraband[i]/2
            wltop = spectra[i]+spectraband[i]/2
            spectra_temp = np.linspace(wlbottom, wltop, OW)
            spectra_os = np.concatenate((spectra_os,spectra_temp))
    
    else:
        raise ValueError(f&#39;mode={mode}. Unknown mode, needs to be in {possible_modes}.&#39;)
    
    return spectra_os, spectra</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.posk"><code class="name flex">
<span>def <span class="ident">posk</span></span>(<span>ia, iap, N)</span>
</code></dt>
<dd>
<div class="desc"><p>k-Position of the OPD[ia,iap] for non redundant combination of two pupils in
a total of N pupils</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ia</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>iap</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>iapp</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>Integer</code></dt>
<dd>Number of telescopes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Integer</code></dt>
<dd>k-position on the most logical order:
for 6T: 01,02,03,04,05,12,13,14,15,23,24,25,34,35,45</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def posk(ia,iap,N):
    &#34;&#34;&#34;
    k-Position of the OPD[ia,iap] for non redundant combination of two pupils in
    a total of N pupils

    Parameters
    ----------
    ia : TYPE
        DESCRIPTION.
    iap : TYPE
        DESCRIPTION.
    iapp : TYPE
        DESCRIPTION.
    N : Integer
        Number of telescopes

    Returns
    -------
    Integer
        k-position on the most logical order: 
            for 6T: 01,02,03,04,05,12,13,14,15,23,24,25,34,35,45

    &#34;&#34;&#34;
    
    return int(ia*N-ia*(ia+3)/2+iap-1)</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.poskfai"><code class="name flex">
<span>def <span class="ident">poskfai</span></span>(<span>ia, iap, iapp, N)</span>
</code></dt>
<dd>
<div class="desc"><p>k-Position of the PhaseClosure for non redundant combination of three pupils
in a total of N pupils.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ia</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>iap</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>iapp</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>Integer</code></dt>
<dd>Number of telescopes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Integer</code></dt>
<dd>k-position</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poskfai(ia,iap,iapp,N):
    &#34;&#34;&#34;
    k-Position of the PhaseClosure for non redundant combination of three pupils
    in a total of N pupils.

    Parameters
    ----------
    ia : TYPE
        DESCRIPTION.
    iap : TYPE
        DESCRIPTION.
    iapp : TYPE
        DESCRIPTION.
    N : Integer
        Number of telescopes.

    Returns
    -------
    Integer
        k-position

    &#34;&#34;&#34;
    
    from scipy.special import binom
    k0 = np.sum(binom(np.arange(N-ia,N),2))
    k1 = posk(iap-ia-1,iapp-iap,N-ia)
    
    return int(k0+k1)</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.setaxelim"><code class="name flex">
<span>def <span class="ident">setaxelim</span></span>(<span>ax, xdata=[], ydata=[], xmargin=0.1, ymargin=0.1, ylim_min=[0, 0], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setaxelim(ax, xdata=[],ydata=[],xmargin=0.1,ymargin=0.1, ylim_min=[0,0], **kwargs):
    
    if len(xdata):
        xmin = (1+xmargin)*np.min(xdata) ; xmax = (1+xmargin)*np.max(xdata)
        ax.set_xlim([xmin,xmax])
        
    if len(ydata):
        if not &#39;ymin&#39; in kwargs.keys():
            ymin = (1+ymargin)*np.min(ydata)
        else:
            ymin=kwargs[&#39;ymin&#39;]
        
        ymax = (1+ymargin)*np.max(ydata)
        
        ydown_min, yup_min = ylim_min
        if yup_min !=0:
            ymax = np.max([ymax,yup_min])
        if ydown_min !=0:
            ymin = np.min([ymin,ydown_min])
        
        ax.set_ylim([ymin,ymax])</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.simu2GRAV"><code class="name flex">
<span>def <span class="ident">simu2GRAV</span></span>(<span>simumatrix, direction='v2pm')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simu2GRAV(simumatrix, direction=&#39;v2pm&#39;):
    
    Ndim = np.ndim(simumatrix)
    
    if direction==&#39;p2vm&#39;:
        # Invert the second and third axis: for having the same code for both situations
        if Ndim==2:
            simumatrix = np.transpose(simumatrix)
        elif Ndim ==3:
            simumatrix = np.transpose(simumatrix, [0,2,1])  
        
    shape = np.shape(simumatrix)    
    
    if Ndim==3:    # There&#39;s several wavelengths
        NW,NP,NB = shape
        GRAVmatrix = np.zeros([NW,NP,NB])
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            GRAVmatrix[:,:,ia] = np.real(simumatrix[:,:,ksim])
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1
                
                # Direct and Conjugate coherence vectors
                direct = simumatrix[:,:,ia*NA+iap]
                # conj = simumatrix[:,:,iap*NA+ia]
                
                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)                    # Real part location
                GRAVmatrix[:,:,k] = np.real(direct)
                k = int(NA*(NA+1)/2 + kp)           # Imaginary part location
                GRAVmatrix[:,:,k] = np.imag(direct)
        
    else:        # Ndim == 2
        NP,NB = shape
        GRAVmatrix = np.zeros([NP,NB])
        NA = int(np.sqrt(NB))
        for ia in range(NA):
            ksim = ia*(NA+1)
            GRAVmatrix[:,ia] = np.real(simumatrix[:,ksim])
            for iap in range(ia+1,NA):
                kp = ia*NA - ia*(ia+3)/2 + iap-1
                
                # Direct and Conjugate coherence vectors
                direct = simumatrix[:,ia*NA+iap]
                # conj = simumatrix[:,iap*NA+ia]
                
                # Real and Imaginary parts of the coherence vectors
                k = int(NA + kp)                    # Real part location
                GRAVmatrix[:,k] = np.real(direct)
                k = int(NA*(NA+1)/2 + kp)           # Imaginary part location
                GRAVmatrix[:,k] = np.imag(direct)
            
    if direction==&#39;p2vm&#39;:
        # Put back the axis at the right locations
        if Ndim==2:
            GRAVmatrix = np.transpose(GRAVmatrix)
        elif Ndim ==3:
            GRAVmatrix = np.transpose(GRAVmatrix, [0,2,1]) 
        
    return GRAVmatrix</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.sortmatrix"><code class="name flex">
<span>def <span class="ident">sortmatrix</span></span>(<span>matrix, ich, ABCDindex, direction='v2pm')</span>
</code></dt>
<dd>
<div class="desc"><p>From the known sorting of the baselines and modulations, reorder the pixels
to get the conventional ordering: 12, 13, &hellip;,23, &hellip;,46,56</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>[NW,NP,NB]</code> or <code>[NW,NB,NP] ARRAY</code></dt>
<dd>V2PM or P2VM.</dd>
<dt><strong><code>ich</code></strong> :&ensp;<code>[NINx2] INT ARRAY</code></dt>
<dd>INterferometric channels.</dd>
<dt><strong><code>ABCDindex</code></strong> :&ensp;<code>[Nmod] INT ARRAY</code></dt>
<dd>Positions of the ABCD modulations.
For example, if BDAC then ABCDindex=[2,0,3,1]</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>STRING</code>, optional</dt>
<dd>v2pm or p2vm. The default is 'v2pm'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>matrix_sorted</code></strong> :&ensp;<code>FLOAT ARRAY</code></dt>
<dd>Same size as matrix, but reordered.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortmatrix(matrix,ich,ABCDindex,direction=&#39;v2pm&#39;):
    &#34;&#34;&#34;
    From the known sorting of the baselines and modulations, reorder the pixels
    to get the conventional ordering: 12, 13, ...,23, ...,46,56

    Parameters
    ----------
    matrix : [NW,NP,NB] or [NW,NB,NP] ARRAY
        V2PM or P2VM.
    ich : [NINx2] INT ARRAY
        INterferometric channels.
    ABCDindex : [Nmod] INT ARRAY
        Positions of the ABCD modulations. 
        For example, if BDAC then ABCDindex=[2,0,3,1]
    direction : STRING, optional
        v2pm or p2vm. The default is &#39;v2pm&#39;.

    Returns
    -------
    matrix_sorted : FLOAT ARRAY
        Same size as matrix, but reordered.

    &#34;&#34;&#34;
    if direction==&#39;v2pm&#39;:
        NW,NP,NB=np.shape(matrix)
    else:
        NW,NB,NP = np.shape(matrix)
        
    NA=int(np.sqrt(NB))
    Nmod=len(ABCDindex) ; NIN = len(ich)
    baseline_sorted = np.zeros_like(matrix)
    
    if np.ndim(ich) == 1:
        ichtemp = ich
        ich = np.zeros([len(ich), 2])
        for ib in range(len(ichtemp)):
            ich[ib] = [char for char in str(ichtemp[ib])]
    
    for ib in range(NIN):
        # Sort the positions in the conventional order
        detectorpositions = range(ib*Nmod,(ib+1)*Nmod)
        ia, iap = ich[ib]-1
        ibn = posk(ia,iap,NA)
        conventionalpositions = range(ibn*Nmod,(ibn+1)*Nmod)
        
        if direction==&#39;v2pm&#39;:
            baseline_sorted[:,conventionalpositions,:] = matrix[:,detectorpositions,:]
        else:
            baseline_sorted[:,:,conventionalpositions] = matrix[:,:,detectorpositions]
        
    matrix_sorted = np.zeros_like(matrix)
    
    # Sort the ABCD modulations
    for ib in range(NIN):
        for k in range(Nmod):
            if direction==&#39;v2pm&#39;:
                matrix_sorted[:,ib*Nmod+k,:] = baseline_sorted[:,ib*Nmod+ABCDindex[k],:]
            else:
                matrix_sorted[:,:,ib*Nmod+k] = baseline_sorted[:,:,ib*Nmod+ABCDindex[k]]

    return matrix_sorted</code></pre>
</details>
</dd>
<dt id="cophasing.coh_tools.studyP2VM"><code class="name flex">
<span>def <span class="ident">studyP2VM</span></span>(<span>*args, savedir='', ext='pdf', nfig=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the V2PM and the V2PM with grids that enable to see clearly the baselines</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nfig</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def studyP2VM(*args,savedir=&#39;&#39;,ext=&#39;pdf&#39;,nfig=0):
    &#34;&#34;&#34;
    Show the V2PM and the V2PM with grids that enable to see clearly the baselines

    Parameters
    ----------
    nfig : TYPE, optional
        DESCRIPTION. The default is 0.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    # Load data
    v2pm = config.FS[&#39;V2PMgrav&#39;]
    p2vm = config.FS[&#39;P2VMgrav&#39;]
    
    NW,NP,NB = np.shape(v2pm)
    NA = int(np.sqrt(NB))
    NIN = NA*(NA-1)//2
    ich=config.FS[&#39;ich&#39;]
    
    if &#39;NMod&#39; in config.FS.keys():
        pairwise=True
        Modulation = config.FS[&#39;Modulation&#39;]
        ABCDindex = config.FS[&#39;ABCDind&#39;]
        Nmod=config.FS[&#39;NMod&#39;]
        v2pm_sorted = sortmatrix(v2pm, ich, ABCDindex)
        p2vm_sorted = sortmatrix(p2vm, ich, ABCDindex, direction=&#39;p2vm&#39;)
    else:
        pairwise=False
        v2pm_sorted = np.copy(v2pm)
        p2vm_sorted = np.copy(p2vm)
    
    conventionalorder=[]
    for ia in range(1,NA+1):
        for iap in range(ia+1,NA+1):
            conventionalorder.append(f&#34;{ia}{iap}&#34;)
    
    
    &#34;&#34;&#34;Photometries and phaseshifts&#34;&#34;&#34;
    if pairwise:
        photometries = np.zeros([NW,NIN,Nmod,2])
        phases = np.zeros([NW,NIN,Nmod]) ; normphasors = np.zeros([NW,NIN,Nmod])
        for ia in range(NA):
            for iap in range(ia+1,NA):
                ib=posk(ia,iap,NA)
                for k in range(Nmod):
                    photometries[:,ib,k,0] = v2pm_sorted[:,Nmod*ib+k,ia]*100
                    photometries[:,ib,k,1] = v2pm_sorted[:,Nmod*ib+k,iap]*100
                    R = v2pm_sorted[:,Nmod*ib+k,NA+ib] ; I = v2pm_sorted[:,Nmod*ib+k,NA+NIN+ib] 
                    phases[:,ib,k] = np.arctan2(I,R) ; normphasors[:,ib,k] = np.sqrt(R**2+I**2)
        
        ModuleCoherentFlux = normphasors/2
    
    
    &#34;&#34;&#34; Noise propagation&#34;&#34;&#34;
    photons = 1e3
    # Coherent vector of a perfectly coherent pair of fields.
    CoherentFlux = np.zeros([NW,NB])
    CoherentFlux[:,:NA+NIN]=photons # In Cassaing formalism: N=photons ; C=photons ; S=0
    
    DetectionCoherent = np.zeros([NW,NP])
    for iw in range(NW):
        DetectionCoherent[iw] = np.dot(v2pm_sorted[iw], CoherentFlux[iw])
    
    QuadratureCoherentFlux = np.zeros([NW,NB])
    QuadratureCoherentFlux[:,:NA] = photons
    QuadratureCoherentFlux[:,NA+NIN:] = photons # In Cassaing formalism: N=photons ; C=0 ; S=photons
    
    DetectionQuadrature = np.zeros([NW,NP])
    for iw in range(NW):
        DetectionQuadrature[iw] = np.dot(v2pm_sorted[iw], QuadratureCoherentFlux[iw])
    
    # Covariance matrix
    CovMatrixCoherent = np.zeros([NW,NB,NB])
    CovMatrixQuadrature = np.zeros([NW,NB,NB])
    
    for iw in range(NW):
        CovMatrixCoherent[iw] = np.dot(p2vm_sorted[iw], np.dot(np.diag(DetectionCoherent[iw]),np.transpose(p2vm_sorted[iw])))
        CovMatrixQuadrature[iw] = np.dot(p2vm_sorted[iw], np.dot(np.diag(DetectionQuadrature[iw]),np.transpose(p2vm_sorted[iw])))
            
    if pairwise:
        dico = {&#39;v2pm_sorted&#39;:v2pm_sorted, 
                &#39;p2vm_sorted&#39;:p2vm_sorted, 
                &#39;photometries&#39;:photometries, 
                &#39;phases&#39;:phases,
                &#39;CovMatrixCoherent&#39;:CovMatrixCoherent, 
                &#39;CovMatrixQuadrature&#39;:CovMatrixQuadrature}
    else:
        dico = {&#39;v2pm_sorted&#39;:v2pm_sorted, 
                &#39;p2vm_sorted&#39;:p2vm_sorted,
                &#39;CovMatrixCoherent&#39;:CovMatrixCoherent, 
                &#39;CovMatrixQuadrature&#39;:CovMatrixQuadrature}
        
    
    if (&#39;p2vm&#39; in args) or (&#39;displayall&#39; in args):
        mod = v2pm_sorted[0]
        
        newfig=nfig
        fig = plt.figure(&#39;V2PM &amp; P2VM&#39;,clear=True)
        fig.suptitle(&#34;V2PM and P2VM&#34;)
        
        ax1,ax2 = fig.subplots(ncols=2)
        ax1.set_title(&#34;V2PM&#34;)
        ax2.set_title(&#34;P2VM&#34;)
        
        &#34;&#34;&#34;Show the V2PM matrix&#34;&#34;&#34;
        
        ax1.imshow(mod)
        
        xticks=[] ; xticklabels=[]
        xticks.append(NA//2-1) ; xticklabels.append(&#39;Photometries&#39;)
        x = NA-0.5 ; xticks.append(NA+NIN//2-1) ; xticklabels.append(&#39;Real parts&#39;)
        ax1.axvline(x = x, color = &#39;w&#39;, linestyle = &#39;-&#39;)
        x = NA+NIN-0.5 ; xticks.append(NA+3*NIN//2-1) ; xticklabels.append(&#39;Imaginary parts&#39;)
        ax1.axvline(x = NA+NIN-0.5, color = &#39;w&#39;, linestyle = &#39;-&#39;)
    
        for ia in range(1,NA-1):
            ib = posk(ia,ia+1,NA)
            ax1.axvline(x = x, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax1.axvline(x = x, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
        
        if pairwise:
            for ib in range(NIN):
                ax1.axhline(y = ib*Nmod-0.5, color = &#39;w&#39;, linestyle = &#39;-&#39;)
            
            ax1.set_yticks(np.arange(NIN)*Nmod+Nmod//2-.5)
            ax1.set_yticklabels(conventionalorder)
            ax1.set_ylabel(&#39;Pixels sorted in ABCD&#39;)
            
            
        else:
            ax1.axhline(y = NA, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            
            ax1.set_yticks([NA//2, (NA+NP)//2])
            ax1.set_yticklabels([&#39;Photometries&#39;, &#39;Interferogram&#39;])
            
        
        ax1.set_xlabel(&#34;Coherent flux&#34;)
        ax1.set_xticks(xticks)
        ax1.set_xticklabels(xticklabels, rotation=45)
        ax1.xaxis.set_ticks_position(&#39;none&#39;)
    
    
        &#34;&#34;&#34; Show the P2VM &#34;&#34;&#34;
    
        demod = p2vm_sorted[0]
        
        ax2.imshow(demod)
        
        # Create a Rectangle patch
        # rect = Rectangle((-0.5,11.5),1,1,linewidth=1,edgecolor=&#39;r&#39;,facecolor=&#39;none&#39;)
        yticks=[] ; yticklabels=[]
        yticks=[] ; yticklabels=[]
        yticks.append(NA//2) ; yticklabels.append(&#39;Photometries&#39;)
        y = NA-0.5 ; yticks.append(y) ; yticklabels.append(&#39;Real parts&#39;)
        ax2.axhline(y = y, color = &#39;w&#39;, linestyle = &#39;-&#39;)
        y = NA+0.5 ; yticks.append(y) ; yticklabels.append(&#39;B1#&#39;)
        y = NA+NIN-0.5 ; yticks.append(y) ; yticklabels.append(&#39;Imaginary parts&#39;)
        ax2.axhline(y = NA+NIN-0.5, color = &#39;w&#39;, linestyle = &#39;-&#39;)
        y = NA+NIN+0.5 ; yticks.append(y) ; yticklabels.append(&#39;B1#&#39;)
        for ia in range(1,NA-1):
            ib = posk(ia,ia+1,NA)
            y = NA+ib-0.5 ; yticks.append(y+0.5) ; yticklabels.append(f&#39;B{ia+1}#&#39;)
            ax2.axhline(y = y, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            y = NA+NIN+ib-0.5 ; yticks.append(y+0.5) ; yticklabels.append(f&#39;B{ia+1}#&#39;)
            ax2.axhline(y = y, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
        
        
        if pairwise:
            for ib in range(NIN):
                ax2.axvline(x = ib*Nmod-0.5, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
                
            ax2.set_xticks(np.arange(NIN)*Nmod+Nmod//2-.5)
            ax2.set_xticklabels(conventionalorder,rotation=45)
            ax2.set_xlabel(&#39;Pixels sorted in ABCD&#39;)
            
        else:
            ax2.axvline(x = NA, color = &#39;w&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.set_xticks([NA,(NA+NP)//2])
            ax2.set_xticklabels([&#39;Photometries&#39;, &#39;Interferogram&#39;], rotation=45)
        
        ax2.yaxis.tick_right()
        ax2.set_yticks(yticks)
        ax2.set_yticklabels(yticklabels)
        ax1.yaxis.set_ticks_position(&#39;none&#39;)
        ax2.yaxis.set_ticks_position(&#39;none&#39;)
        ax1.xaxis.set_ticks_position(&#39;none&#39;)
        ax2.xaxis.set_ticks_position(&#39;none&#39;)

        ax1.grid(False)
        ax2.grid(False)
    
# =============================================================================
#     Photometry and phaseshifts repartition in the P2VM
# =============================================================================
    
    # colors = tol_cset(&#39;bright&#39;)

    # newfig+=1
    # fig=plt.figure(newfig, clear=True)
    # fig.suptitle(&#34;Photometry repartitions and phaseshift of the beams&#34;)
    # ax1,ax2,ax3,ax4 = fig.subplots(nrows=4,gridspec_kw={&#39;height_ratios&#39;: [.2,1,.2,1]})
    
    # photometries = np.zeros([NW,NIN,Nmod,2])
    # phases = np.zeros([NW,NIN,Nmod])
    # normphasors = np.zeros([NW,NIN,Nmod])
    # for ia in range(NA):
    #     for iap in range(ia+1,NA):
    #         ib=posk(ia,iap,NA)
    #         for k in range(Nmod):
    #             photometries[:,ib,k,0] = v2pm_sorted[:,4*ib+k,ia]*100
    #             photometries[:,ib,k,1] = v2pm_sorted[:,4*ib+k,iap]*100
    #             R = v2pm_sorted[:,4*ib+k,NA+ib] ; I = v2pm_sorted[:,4*ib+k,NA+NIN+ib] 
    #             phases[:,ib,k] = np.arctan2(I,R) ; normphasors = np.sqrt(R**2+I**2)
                
    # NINtemp = NIN//2+1
    # xtop = np.arange(NINtemp)  # the label locations
    # xbot = np.arange(NINtemp,NIN)
    # width=0.8
    # barwidth=width/8
    # bar_patches1=[] ; bar_patches2=[]
    # bar_patches1.append(mpatches.Patch(facecolor=&#39;gray&#39;,edgecolor=&#39;black&#39;,hatch=&#39;///&#39;,label=&#34;First beam&#34;))
    # bar_patches1.append(mpatches.Patch(facecolor=&#39;gray&#39;,edgecolor=&#39;black&#39;, label=&#34;Second beam&#34;))
    # for k in range(Nmod):
        
    #     firstbar_pos = xtop-width/2+barwidth/2
    #     rects1 = ax2.bar(firstbar_pos + 2*k*barwidth, photometries[0,:NINtemp,k,0], 
    #                      barwidth, hatch=&#39;///&#39;,color=colors[k],edgecolor=&#39;black&#39;).patches
    #     rects2 = ax2.bar(firstbar_pos + (2*k+1)*barwidth, photometries[0,:NINtemp,k,1], 
    #                      barwidth, color=colors[k],edgecolor=&#39;black&#39;).patches
    #     rects_moy1 = ax2.bar(firstbar_pos + (2*k+1/2)*barwidth, np.mean(photometries[0,:NINtemp,k,:],axis=-1), 
    #                      barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;--&#39;).patches
    #     rects3 = ax1.bar(firstbar_pos + 2*k*barwidth+barwidth/2, phases[0,:NINtemp,k], 
    #                          barwidth,color=colors[k],edgecolor=&#39;black&#39;)
    #     firstbar_pos = xbot-width/2+barwidth/2
    #     rects4 = ax4.bar(firstbar_pos + 2*k*barwidth, photometries[0,NINtemp:,k,0],
    #                      barwidth, hatch=&#39;///&#39;,color=colors[k],edgecolor=&#39;black&#39;).patches
    #     rects5 = ax4.bar(firstbar_pos + (2*k+1)*barwidth, photometries[0,NINtemp:,k,1],
    #                      barwidth,color=colors[k],edgecolor=&#39;black&#39;).patches
    #     rects_moy2 = ax4.bar(firstbar_pos + (2*k+1/2)*barwidth, np.mean(photometries[0,NINtemp:,k,:],axis=-1), 
    #                      barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;--&#39;).patches
    #     rects6 = ax3.bar(firstbar_pos + 2*k*barwidth+barwidth/2, phases[0,NINtemp:,k], 
    #                          barwidth,color=colors[k],edgecolor=&#39;black&#39;)
        
    #     # rects1 = ax2.patches[:NINtemp] ; rects2 = ax2.patches[NINtemp:2*NINtemp]
    #     # rects_moy = ax2.patches[2*NINtemp:]
        
    #     for rect1,rect2,rect_moy in zip(rects1,rects2,rects_moy1):
    #         height = np.max([rect1.get_height(),rect2.get_height(),rect_moy.get_height()])
    #         ax2.text(rect_moy.get_x() + rect_moy.get_width() / 2, height+0.1, round(height,1),
    #                 ha=&#39;center&#39;, va=&#39;bottom&#39;)
            
    #     for rect1,rect2,rect_moy in zip(rects4,rects5,rects_moy2):
    #         height = np.max([rect1.get_height(),rect2.get_height(),rect_moy.get_height()])
    #         ax4.text(rect_moy.get_x() + rect_moy.get_width() / 2, height+0.1, round(height,1),
    #                 ha=&#39;center&#39;, va=&#39;bottom&#39;)
    #         # ax4.text(rect.get_x() + rect.get_width() / 2, height + 5, height,
    #         #         ha=&#39;center&#39;, va=&#39;bottom&#39;)
            
    #     bar_patches2.append(mpatches.Patch(color=colors[k],label=&#34;ABCD&#34;[k]))
    #     # rects3 = ax1.bar(x - width/2+0.25, photometries[0,:NINtemp,0,0], barwidth, label=&#39;C&#39;,color=&#39;b&#39;)
    #     # rects4 = ax1.bar(x - width/2+0.35, photometries[0,:NINtemp,0,1], barwidth, label=&#39;D&#39;,color=&#39;g&#39;)
    
    # # ax1.bar_label(rects1)
    # # ax1.bar_label(rects2)
    # # xlim = (xtop[0]-width , xtop[-1]+width)
        
    # # ax3.plot(npxtop,0.12*np.ones_like(xtop), color=&#39;black&#39;, label=&#34;Phase&#34;)
    # # ax3.hlines(0.12, xlim[0],xlim[1], color=&#39;black&#39;, label=&#34;Phase&#34;)
    # # ax3.hlines(0.08, xlim[0],xlim[1], color=&#39;black&#39;, label=&#34;Phase&#34;)
    # # ax3.hlines(0.16, xlim[0],xlim[1], color=&#39;black&#39;, label=&#34;Phase&#34;)
    # # ax3.plot(phases[0,NINtemp:,])
    
    
    # xticklabels=[]
    # for ia in range(NA):
    #     for iap in range(ia+1,NA):
    #         xticklabels.append(f&#34;B{ia+1}{iap+1}&#34;)
    
    # ax2.set_xticks(xtop)
    # ax2.set_xticklabels(xticklabels[:NINtemp])
    
    # ax2.set_ylim(0,10)
    # ax4.set_ylim(0,10)
    
    # ax1.set_ylim(-np.pi,np.pi)
    # ax1.grid()

    # ax3.set_ylim(-np.pi,np.pi)
    # ax3.grid()
    # ax4.set_xticks(xbot)
    # ax4.set_xticklabels(xticklabels[NINtemp:])
    
    # first_legend = ax4.legend(handles=bar_patches2, loc=&#39;lower right&#39;)
    # ax4.add_artist(first_legend)
    # ax4.legend(handles=bar_patches1, loc=&#39;upper right&#39;)
    
    
    # ax1.set_ylabel(&#34;Phase [rad]&#34;)
    # ax2.set_ylabel(&#34;Transmission&#34;)
    
    # # ax4.bar_label(rects4, label_type=&#39;center&#39;)
    
    # fig.show()
    
    if (&#39;repartition&#39; in args) or (&#39;displayall&#39; in args):
        
        #plt.rcParams.update(rcParamsForBaselines)
        SS = 12     # Small size
        MS = 14     # Medium size
        BS = 16     # Big size
        figsize = (16,12)
        rcParamsForRepartitions = {&#34;font.size&#34;:SS,
                &#34;axes.titlesize&#34;:SS,
                &#34;axes.labelsize&#34;:SS,
                &#34;axes.grid&#34;:True,
               
                &#34;xtick.labelsize&#34;:SS,
                &#34;ytick.labelsize&#34;:SS,
                &#34;legend.fontsize&#34;:SS,
                &#34;figure.titlesize&#34;:BS,
                # &#34;figure.constrained_layout.use&#34;: False,
                &#34;figure.dpi&#34;:300,
                &#34;figure.figsize&#34;:figsize
                # &#39;figure.subplot.hspace&#39;: 0.05,
                # &#39;figure.subplot.wspace&#39;: 0,
                # &#39;figure.subplot.left&#39;:0.1,
                # &#39;figure.subplot.right&#39;:0.95
                }

        plt.rcParams.update(rcParamsForRepartitions)
        
        if pairwise:
            newfig+=1
            fig=plt.figure(newfig, clear=True)
            fig.suptitle(&#34;Photometry repartitions and phaseshift of the beams&#34;)
            (ax1,ax3),(ax2,ax4) = fig.subplots(nrows=2, ncols=2,gridspec_kw={&#39;width_ratios&#39;: [9,1]})
                        
            NINtemp = NIN//2+1
            xtop = np.arange(NINtemp)  # the label locations
            xbot = np.arange(NINtemp,NIN)
            
            width=0.8
            barwidth=width/8
            
            ax1_firstbar_positions = xtop-width/2+barwidth/2
            ax2_firstbar_positions = xbot-width/2+barwidth/2
            
            bar_patches1=[] ; bar_patches2=[]
            bar_patches1.append(mpatches.Patch(facecolor=&#39;gray&#39;,edgecolor=&#39;black&#39;,hatch=&#39;///&#39;,label=&#34;First beam&#34;))
            bar_patches1.append(mpatches.Patch(facecolor=&#39;gray&#39;,edgecolor=&#39;black&#39;, label=&#34;Second beam&#34;))
            
            linestyles=[]
            linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                            linestyle=&#39;--&#39;,label=&#39;Average flux&#39;))    
            linestyles.append(mlines.Line2D([], [], color=&#39;black&#39;,
                                            linestyle=&#39;:&#39;,label=&#39;Coherent flux&#39;))
                
            for k in range(Nmod):
                
                rects1 = ax1.bar(ax1_firstbar_positions + 2*k*barwidth, photometries[0,:NINtemp,k,0], 
                                 barwidth, hatch=&#39;///&#39;,color=colors[k],edgecolor=&#39;black&#39;).patches
                rects2 = ax1.bar(ax1_firstbar_positions + (2*k+1)*barwidth, photometries[0,:NINtemp,k,1], 
                                 barwidth, color=colors[k],edgecolor=&#39;black&#39;).patches
                rects_moy1 = ax1.bar(ax1_firstbar_positions + (2*k+1/2)*barwidth, np.mean(photometries[0,:NINtemp,k,:],axis=-1), 
                                 barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;--&#39;).patches
                rects_coh1 = ax1.bar(ax1_firstbar_positions + (2*k+1/2)*barwidth, ModuleCoherentFlux[0,:NINtemp,k]*100, 
                                 barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;:&#39;).patches
                
                rects4 = ax2.bar(ax2_firstbar_positions + 2*k*barwidth, photometries[0,NINtemp:,k,0],
                                 barwidth, hatch=&#39;///&#39;,color=colors[k],edgecolor=&#39;black&#39;).patches
                rects5 = ax2.bar(ax2_firstbar_positions + (2*k+1)*barwidth, photometries[0,NINtemp:,k,1],
                                 barwidth,color=colors[k],edgecolor=&#39;black&#39;).patches
                rects_moy2 = ax2.bar(ax2_firstbar_positions + (2*k+1/2)*barwidth, np.mean(photometries[0,NINtemp:,k,:],axis=-1), 
                                 barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;--&#39;).patches
                rects_coh2 = ax2.bar(ax2_firstbar_positions + (2*k+1/2)*barwidth, ModuleCoherentFlux[0,NINtemp:,k]*100, 
                                 barwidth*2, color=colors[k],edgecolor=&#39;black&#39;,fill=False,linestyle=&#39;:&#39;).patches
                
                for rect1,rect2,rect_moy in zip(rects1,rects2,rects_moy1):
                    height = np.max([rect1.get_height(),rect2.get_height(),rect_moy.get_height()])
                    # ax1.text(rect_moy.get_x() + rect_moy.get_width() / 2, height+0.1, round(height,1),
                    #         ha=&#39;center&#39;, va=&#39;bottom&#39;)
                    
                for rect1,rect2,rect_moy in zip(rects4,rects5,rects_moy2):
                    height = np.max([rect1.get_height(),rect2.get_height(),rect_moy.get_height()])
                    # ax2.text(rect_moy.get_x() + rect_moy.get_width() / 2, height+0.1, round(height,1),
                    #         ha=&#39;center&#39;, va=&#39;bottom&#39;)
                    
                bar_patches2.append(mpatches.Patch(color=colors[k],label=&#34;ABCD&#34;[k]))
            
            ax1_xmin,ax1_xmax = ax1.get_xlim() ; ax2_xmin,ax2_xmax = ax2.get_xlim()
            ax1_ymin,ax1_ymax = ax1.get_ylim() ; ax2_ymin,ax2_ymax = ax2.get_ylim()
            ax1_normalised_width = 1/(ax1_ymax-ax1_ymin)*width*.7
            ax1_normalised_height = 1/(ax1_ymax-ax1_ymin)*width
            ax2_normalised_width = 1/(ax1_ymax-ax1_ymin)*width*.7
            ax2_normalised_height = 1/(ax1_ymax-ax1_ymin)*width
            ax1_bottomleft = 1/(ax1_xmax-ax1_xmin)*(ax1_firstbar_positions+barwidth/2-ax1_xmin)
            ax2_bottomleft = 1/(ax2_xmax-ax2_xmin)*(ax2_firstbar_positions+barwidth/2-ax2_xmin)
            
            for ib in range(NINtemp):
                subpos=(ax1_bottomleft[ib],0.75,ax1_normalised_width,ax1_normalised_height)#firstbar_pos[0] + 2*k*barwidth,
                label = True if ib==0 else False
                ax=add_subplot_axes(ax1,subpos,polar=True,label=label)
                if label:
                    ax.xaxis.label.set_size(2)
                    ax.yaxis.label.set_size(2)
                ax.set_ylim(0,1)
                for k in range(Nmod):
                    phase = phases[0,ib,k] ; norm = normphasors[0,ib,k]/np.max(normphasors[0,ib,:])
                    ax.arrow(phase, 0, 0, norm, width = 0.05,
                             edgecolor=colors[k],facecolor = colors[k], lw = 2, zorder = 5,length_includes_head=True)
                    
                # ax.set_thetagrids(phases[0,ib,:]*180/np.pi,labels=np.round(phases[0,ib,:]*180/np.pi))
            for ib in range(NIN-NINtemp):
                subpos=(ax2_bottomleft[ib],0.75,ax2_normalised_width,ax2_normalised_height)#firstbar_pos[0] + 2*k*barwidth,
                label = False
                ax=add_subplot_axes(ax2,subpos,polar=True,label=label)
                ax.set_ylim(0,1)
                
                for k in range(Nmod):
                    phase = phases[0,NINtemp+ib,k] ; norm = normphasors[0,NINtemp+ib,k]/np.max(normphasors[0,NINtemp+ib,:])
                    ax.arrow(phase, 0, 0, norm, width = 0.05,
                             edgecolor=colors[k],facecolor = colors[k], lw = 2, zorder = 5,length_includes_head=True)
            
            xticklabels=[]
            for ia in range(NA):
                for iap in range(ia+1,NA):
                    xticklabels.append(f&#34;B{ia+1}{iap+1}&#34;)
            
            ax1.set_xticks(xtop)
            ax1.set_xticklabels(xticklabels[:NINtemp])
            
            ax1.set_ylim(0,14)
            ax2.set_ylim(0,14)
            
            ax2.set_xticks(xbot)
            ax2.set_xticklabels(xticklabels[NINtemp:])
            
            # Set legend on ax3 and ax4    
            ax3.axis(&#34;off&#34;); ax4.axis(&#34;off&#34;)
            ax3.legend(handles=bar_patches1+bar_patches2+linestyles, loc=&#39;upper left&#39;)
            
            
            # ax1.set_ylabel(&#34;Phase [rad]&#34;)
            ax1.set_ylabel(&#34;Transmission \n[%]&#34;)
            ax2.set_ylabel(&#34;Transmission \n[%]&#34;)
            ax1.grid(False)
            ax2.grid(False)
            
            if len(savedir):
                fig.savefig(savedir+f&#34;PICrepartition.{ext}&#34;)
            
            fig.show()
    
        plt.rcParams.update(plt.rcParamsDefault)
    
    
# =============================================================================
#     Noise propagation through the matrix
# =============================================================================
    
    if (&#39;noise&#39; in args) or (&#39;displayall&#39; in args):

        newfig+=1
        fig = plt.figure(&#39;Noise propagation&#39;, clear=True)
        fig.suptitle(&#34;Covariance matrices in photon noise regime (1000photons)&#34;)
        ax1, ax2 = fig.subplots(ncols=2)
        ax1.set_title(&#39;Covariance matrix when cophased&#39;)
        ax2.set_title(&#39;Covariance matrix when phase in quadrature&#39;)
        
        ax1.imshow(CovMatrixCoherent[0])
        ax2.imshow(CovMatrixQuadrature[0])
        
        xticks=[] ; xticklabels=[]
        xticks.append(NA//2) ; xticklabels.append(&#39;Photometries&#39;)
        x = NA-0.5 ; xticks.append(NA+NIN//2) ; xticklabels.append(&#39;Real parts&#39;)
        ax1.axvline(x = x, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axvline(x = x, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        # x = NA+0.5 ; xticks.append(x) ; xticklabels.append(&#39;B1X&#39;)
        x = NA+NIN-0.5 ; xticks.append(NA+3*NIN//2) ; xticklabels.append(&#39;Imaginary parts&#39;)
        ax1.axvline(x = NA+NIN-0.5, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axvline(x = NA+NIN-0.5, color = &#39;k&#39;, linestyle = &#39;-&#39;)
            
        yticks=[] ; yticklabels=[]
        yticks.append(-0.5) ; yticklabels.append(&#39;Photometries&#39;)
        y = NA-0.5 ; yticks.append(y) ; yticklabels.append(&#39;Real parts&#39;)
        ax1.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax1.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        y = NA+0.5 ; yticks.append(y) ; yticklabels.append(&#39;B1X&#39;)
        y = NA+NIN-0.5 ; yticks.append(y) ; yticklabels.append(&#39;Imaginary parts&#39;)
        ax1.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax1.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        ax2.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;)
        y = NA+NIN+0.5 ; yticks.append(y) ; yticklabels.append(&#39;B1X&#39;)
        for ia in range(1,NA-1):
            ib = posk(ia,ia+1,NA)
            y = NA+ib-0.5 ; yticks.append(y) ; yticklabels.append(f&#39;B{ia+1}X&#39;)
            ax1.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax1.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            y = NA+NIN+ib-0.5 ; yticks.append(y) ; yticklabels.append(f&#39;B{ia+1}X&#39;)
            ax1.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.axhline(y = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax1.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
            ax2.axvline(x = y, color = &#39;k&#39;, linestyle = &#39;-&#39;, linewidth=.5)
    
        ax1.set_yticks(xticks)
        # ax1.set_yticklabels(xticklabels)
        ax1.set_yticks(yticks)
        ax1.set_yticklabels(yticklabels)
    
        ax2.set_yticklabels([])
        # ax2.set_yticks(xticks)
        # ax2.set_yticklabels(xticklabels)
        # ax2.set_yticks(yticks)
        # ax2.set_yticklabels(yticklabels)
    
        ax1.set_xticks(xticks) ; ax1.set_xticklabels(xticklabels)
        ax2.set_xticks(xticks) ; ax2.set_xticklabels(xticklabels)
        ax1.grid(False)
        ax2.grid(False)

        
    return dico</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cophasing.coh_tools.Error"><code class="flex name class">
<span>class <span class="ident">Error</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for exceptions in this module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Error(Exception):
    &#34;&#34;&#34;Base class for exceptions in this module.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cophasing.coh_tools.InputError" href="#cophasing.coh_tools.InputError">InputError</a></li>
</ul>
</dd>
<dt id="cophasing.coh_tools.InputError"><code class="flex name class">
<span>class <span class="ident">InputError</span></span>
<span>(</span><span>expression, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception raised for errors in the input.</p>
<h2 id="attributes">Attributes</h2>
<p>expression &ndash; input expression in which the error occurred
message &ndash; explanation of the error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputError(Error):
    &#34;&#34;&#34;Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    &#34;&#34;&#34;

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cophasing.coh_tools.Error" href="#cophasing.coh_tools.Error">Error</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cophasing" href="index.html">cophasing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="cophasing.coh_tools.BBstar" href="#cophasing.coh_tools.BBstar">BBstar</a></code></li>
<li><code><a title="cophasing.coh_tools.MakeV2PfromA2P" href="#cophasing.coh_tools.MakeV2PfromA2P">MakeV2PfromA2P</a></code></li>
<li><code><a title="cophasing.coh_tools.NB2NIN" href="#cophasing.coh_tools.NB2NIN">NB2NIN</a></code></li>
<li><code><a title="cophasing.coh_tools.VanCittert" href="#cophasing.coh_tools.VanCittert">VanCittert</a></code></li>
<li><code><a title="cophasing.coh_tools.add_subplot_axes" href="#cophasing.coh_tools.add_subplot_axes">add_subplot_axes</a></code></li>
<li><code><a title="cophasing.coh_tools.check_cp" href="#cophasing.coh_tools.check_cp">check_cp</a></code></li>
<li><code><a title="cophasing.coh_tools.check_nrj" href="#cophasing.coh_tools.check_nrj">check_nrj</a></code></li>
<li><code><a title="cophasing.coh_tools.check_semiunitary" href="#cophasing.coh_tools.check_semiunitary">check_semiunitary</a></code></li>
<li><code><a title="cophasing.coh_tools.coh__GRAV2simu" href="#cophasing.coh_tools.coh__GRAV2simu">coh__GRAV2simu</a></code></li>
<li><code><a title="cophasing.coh_tools.create_CfObj" href="#cophasing.coh_tools.create_CfObj">create_CfObj</a></code></li>
<li><code><a title="cophasing.coh_tools.create_obsfile" href="#cophasing.coh_tools.create_obsfile">create_obsfile</a></code></li>
<li><code><a title="cophasing.coh_tools.generate_spectra" href="#cophasing.coh_tools.generate_spectra">generate_spectra</a></code></li>
<li><code><a title="cophasing.coh_tools.generate_spectra0" href="#cophasing.coh_tools.generate_spectra0">generate_spectra0</a></code></li>
<li><code><a title="cophasing.coh_tools.get_Bproj" href="#cophasing.coh_tools.get_Bproj">get_Bproj</a></code></li>
<li><code><a title="cophasing.coh_tools.get_CfDisturbance" href="#cophasing.coh_tools.get_CfDisturbance">get_CfDisturbance</a></code></li>
<li><code><a title="cophasing.coh_tools.get_CfObj" href="#cophasing.coh_tools.get_CfObj">get_CfObj</a></code></li>
<li><code><a title="cophasing.coh_tools.get_ObsInformation" href="#cophasing.coh_tools.get_ObsInformation">get_ObsInformation</a></code></li>
<li><code><a title="cophasing.coh_tools.get_array" href="#cophasing.coh_tools.get_array">get_array</a></code></li>
<li><code><a title="cophasing.coh_tools.get_infos" href="#cophasing.coh_tools.get_infos">get_infos</a></code></li>
<li><code><a title="cophasing.coh_tools.get_subarray" href="#cophasing.coh_tools.get_subarray">get_subarray</a></code></li>
<li><code><a title="cophasing.coh_tools.get_visibility" href="#cophasing.coh_tools.get_visibility">get_visibility</a></code></li>
<li><code><a title="cophasing.coh_tools.info_array" href="#cophasing.coh_tools.info_array">info_array</a></code></li>
<li><code><a title="cophasing.coh_tools.makeA2P" href="#cophasing.coh_tools.makeA2P">makeA2P</a></code></li>
<li><code><a title="cophasing.coh_tools.oversample_wv" href="#cophasing.coh_tools.oversample_wv">oversample_wv</a></code></li>
<li><code><a title="cophasing.coh_tools.posk" href="#cophasing.coh_tools.posk">posk</a></code></li>
<li><code><a title="cophasing.coh_tools.poskfai" href="#cophasing.coh_tools.poskfai">poskfai</a></code></li>
<li><code><a title="cophasing.coh_tools.setaxelim" href="#cophasing.coh_tools.setaxelim">setaxelim</a></code></li>
<li><code><a title="cophasing.coh_tools.simu2GRAV" href="#cophasing.coh_tools.simu2GRAV">simu2GRAV</a></code></li>
<li><code><a title="cophasing.coh_tools.sortmatrix" href="#cophasing.coh_tools.sortmatrix">sortmatrix</a></code></li>
<li><code><a title="cophasing.coh_tools.studyP2VM" href="#cophasing.coh_tools.studyP2VM">studyP2VM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cophasing.coh_tools.Error" href="#cophasing.coh_tools.Error">Error</a></code></h4>
</li>
<li>
<h4><code><a title="cophasing.coh_tools.InputError" href="#cophasing.coh_tools.InputError">InputError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>