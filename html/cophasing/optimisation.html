<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cophasing.optimisation API documentation</title>
<meta name="description" content="Created on Mon Nov 16 13:17:41 2020 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cophasing.optimisation</code></h1>
</header>
<section id="section-intro">
<p>Created on Mon Nov 16 13:17:41 2020</p>
<p>@author: cpannetier</p>
<p>Routines for optimising the fringe tracker</p>
<ul>
<li>
<p>OptimGain: Optimise on gain PD and GD</p>
</li>
<li>
<p>OptimGainMulitprocess: Multiprocessing version of OptimGain.
Doesn't work so far (16-11-2020)</p>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Mon Nov 16 13:17:41 2020

@author: cpannetier

Routines for optimising the fringe tracker

- OptimGain: Optimise on gain PD and GD
    
- OptimGainMulitprocess: Multiprocessing version of OptimGain.
    Doesn&#39;t work so far (16-11-2020)

&#34;&#34;&#34;

import numpy as np
import time

from . import config
import cophasing.skeleton as sk
import cophasing.coh_tools as ct
import glob

from importlib import reload  # Python 3.4+ only.

def OptimGainsTogether(GainsPD=[],GainsGD=[],DITs=np.logspace(0,500,20), 
                        optimCriteria=&#34;FC&#34;,filedir=&#39;&#39;,Nsamples=5,
                        TimeBonds=100, WLOfTrack=1.5,SpectraForScience=np.arange(0.6,0.9,0.005),
                        telescopes=0, save_all=&#39;no&#39;,savepath=&#39;./&#39;,figsave=&#39;&#39;,
                        display=False,verbose=True,verbose2=False):
    &#34;&#34;&#34;
    Estimates the best couple GD and PD gains after calculating the performance 
    (residual phase) of the servo loop on all the files contained in filedir.

    Parameters
    ----------
    GainsPD : TYPE, optional
        DESCRIPTION. The default is [].
    GainsGD : TYPE, optional
        DESCRIPTION. The default is [].
    optim : TYPE, optional
        DESCRIPTION. The default is &#39;opd&#39;.
    filedir : TYPE, optional
        DESCRIPTION. The default is &#39;&#39;.
    TimeBonds : TYPE, optional
        DESCRIPTION. The default is 100.
    WLOfScience : TYPE, optional
        DESCRIPTION. The default is 1.5.
    DIT : TYPE, optional
        DESCRIPTION. The default is 50.
    telescopes : TYPE, optional
        DESCRIPTION. The default is 0.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    
    from . import simu
    from . import config
    import pandas as pd
    
    from .config import NA, NIN, NC
        
    if not (len(GainsPD) and len(GainsPD)):
        raise Exception(&#39;Need GainsPD and GainsGD.&#39;)
    
    NgainsGD = len(GainsGD)
    NgainsPD = len(GainsPD)
    NDIT = len(DITs)
        
    if verbose2:
        print(f&#34;Start optimisation with sample gains GD={GainsGD} and PD={GainsPD}&#34;)
    
    sk.update_config(checkperiod=110,verbose=verbose) # For not seeing the decount.
    
    VarOPD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])         # Phase variances
    VarGDRes = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # GD Phase variances
    VarPDRes = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # PD Phase variances
    VarGDEst = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # GD Phase variances
    VarPDEst = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # PD Phase variances
    InstVarPD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
    InstVarGD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
    InstVarGDUnbiased = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
    VarPDnum = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # Estimated PD variances
    VarGDdenom = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
    VarGDdenomUnbiased = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
    VarPDdenom = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
    VarPiston = np.zeros([NDIT,NgainsGD,NgainsPD,NA])       # Piston variance
    VarPistonGD = np.zeros([NDIT,NgainsGD,NgainsPD,NA])     # Piston GD variance
    VarPistonPD = np.zeros([NDIT,NgainsGD,NgainsPD,NA])     # Piston PD variance
    VarCP = np.zeros([NDIT,NgainsGD,NgainsPD,NC])           # Closure Phase variances
    SNRSI = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Signal-to-noise ratio in the scientific instrument
    FCArray = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])        # Contains the fringe contrasts
    LockedRatio = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])    # Locked ratio
    WLockedRatio = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])   # Weigthed locked ratio
    LR2 = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Locked ratio
    LR3 = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Central fringe ratio
    
    Vmod = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
    Vangle = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
    
    ThresholdGDs = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
    
    minValue = 10000
    
    NumberOfLoops = NgainsGD*NgainsPD
    
    if len(filedir):
        files = [f.replace(&#34;\\&#34;,&#34;/&#34;) for f in glob.glob(filedir+&#39;*.fits&#39;)]
        Nfiles = len(files)
        if verbose2:
            print(f&#34;Found: {Nfiles} files&#34;)
        if Nsamples &lt; Nfiles:
            Nfiles = Nsamples
        if verbose2:
            print(f&#34;Take only the {Nsamples} first files&#34;)
    else:
        files = [config.DisturbanceFile]
        Nfiles = 1
    
    time0 = time.time() ; LoopNumber = 0
    iOptimGD=0; iOptimPD=0 ; IDs=[] ; ThresholdGDmins=[] ; ThresholdGDmaxs=[]

    indWLOfTrack = np.argmin(np.abs(config.spectra-WLOfTrack))
    
    for ig in range(NgainsGD):
        Ggd = GainsGD[ig]    
        if verbose2:
            print(f&#34;-----------Start optimising with gain GD={Ggd}------------&#34;)   
        
        for ip in range(NgainsPD):
            LoopNumber+=1
            igp = ig*NgainsPD + ip  # Position in the tables
            minindcurrentGD = ig*NgainsPD
            maxindcurrentGD = minindcurrentGD + NgainsPD
            
            Gpd = GainsPD[ip]
            
            config.FT[&#39;GainGD&#39;] = Ggd
            config.FT[&#39;GainPD&#39;] = Gpd
            
            if verbose:
                print(&#34;\n----------------------------------&#34;)
                print(f&#39;## Gain GD={Ggd}; GainPD={Gpd} ##&#39;)
                
            for ifile in range(Nfiles):
                
                DisturbanceFile = files[ifile]
                if verbose2:
                    print(f&#39;File {ifile+1}/{Nfiles}&#39;)
                
                sk.update_config(DisturbanceFile=DisturbanceFile, verbose=verbose)
            
                # Launch the simulator
                if save_all==&#39;light&#39;:
                    sk.loop(savepath,LightSave=True,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;yes&#39;:
                    sk.loop(savepath,LightSave=False,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;no&#39;:
                    sk.loop(verbose=verbose,verbose2=verbose2)
                else:
                    raise Exception(&#39;save_all param must be &#34;light&#34;, &#34;yes&#34; or &#34;no&#34;.&#39;)
                    
                if len(figsave):
                    if figsave != &#39;onlyperf&#39;:
                        if isinstance(figsave,str):
                            sk.display(figsave,display=display,savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
                        elif isinstance(figsave,list):
                            if &#39;perfarray&#39; in figsave:
                                figsave.remove(&#39;perfarray&#39;)
                            sk.display(*figsave,display=display,savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
                        
                # Load the performance observables into simu module
                for idit in range(NDIT):
                    DIT=DITs[idit]
                    sk.ShowPerformance(TimeBonds,SpectraForScience,DIT, display=False)
                    
                    # VarOPD, VarCP, SNRSI, FringeContrast, LockedRatio, WLockedRatio = perfs
                    
                    # Initialise the comparison tables
                    VarOPD[idit,ig,ip,:] += simu.VarOPD/Nfiles
                    VarCP[idit,ig,ip,:] += simu.VarCPD/Nfiles
                    VarGDRes[idit,ig,ip,:] += simu.VarGDRes/Nfiles
                    VarPDRes[idit,ig,ip,:] += simu.VarPDRes/Nfiles
                    VarPiston[idit,ig,ip,:] += simu.VarPiston/Nfiles
                    VarPistonGD[idit,ig,ip,:] += simu.VarPistonGD/Nfiles
                    VarPistonPD[idit,ig,ip,:] += simu.VarPistonPD/Nfiles
                    SNRSI[idit,ig,ip,:] += simu.SNR_E/Nfiles
                    FCArray[idit,ig,ip,:] += simu.FringeContrast[0]/Nfiles
                    LockedRatio[idit,ig,ip,:] += simu.LockedRatio/Nfiles
                    WLockedRatio[idit,ig,ip,:] += simu.WLockedRatio/Nfiles
                
                    LR2[idit,ig,ip,:] += simu.LR2/Nfiles # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    LR3[idit,ig,ip,:] += simu.LR3/Nfiles # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
            
                    # Average of the estimated instantaneous variance. (has a 
                    # signification only in open loop)
                    InstVarPD[idit,ig,ip,:] += np.mean(simu.varPD,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    InstVarGD[idit,ig,ip,:] += np.mean(simu.varGD,axis=0)/Nfiles
                    InstVarGDUnbiased[idit,ig,ip,:] += np.mean(simu.varGDUnbiased,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    VarPDnum[idit,ig,ip,:] += np.mean(simu.varPDnum,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    VarPDdenom[idit,ig,ip,:] += np.mean(simu.varPDdenom,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    VarGDdenom[idit,ig,ip,:] += np.mean(simu.varGDdenom,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    VarGDdenomUnbiased[idit,ig,ip,:] += np.mean(simu.varGDdenomUnbiased,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    
                    Vmod[idit,ig,ip,:] = np.real(ct.NB2NIN(np.abs(simu.VisibilityObject[indWLOfTrack])))
                    Vangle[idit,ig,ip,:] = np.real(ct.NB2NIN(np.angle(simu.VisibilityObject[indWLOfTrack])))
            
                    ThresholdGDs[idit,ig,ip,:] = config.FT[&#39;ThresholdGD&#39;] # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    
            IDs.append(config.SimuTimeID)
            ThresholdGDmins.append(np.min(config.FT[&#39;ThresholdGD&#39;]))
            ThresholdGDmaxs.append(np.max(config.FT[&#39;ThresholdGD&#39;]))
            
            if optimCriteria==&#34;VarOPD&#34;:
                criteria = VarOPD
            elif optimCriteria==&#34;FC&#34;:
                criteria = 1-FCArray
            elif optimCriteria == &#34;LR&#34;:
                criteria = 1-LockedRatio
            elif optimCriteria == &#34;LR2&#34;:
                criteria = 1-LR2
            elif optimCriteria == &#34;WLR&#34;:
                criteria = 1-WLockedRatio
            elif optimCriteria == &#34;VarCP&#34;:
                if (not telescopes) and (len(telescopes) != 3):
                    raise Exception(&#39;For defining a closure phase, telescopes must be three.&#39;)
                else:
                    criteria = VarCP
            else:
                raise Exception(f&#39;The chosen criteria must be in this list: &#34;LR&#34;, &#34;LR2&#34;,&#34;WLR&#34;, &#34;FC&#34;, &#34;VarOPD&#34;, &#34;VarCP&#34;&#39;)
                    
                    
            if not telescopes:
                Value = np.max(np.mean(criteria[:,ig,ip,:], axis=1))   # Maximum (over DITs) of the averaged value (over baselines)
                bestDIT = DITs[np.argmax(np.mean(criteria[:,ig,ip,:], axis=1))]
            else:
                itel1,itel2 = telescopes[0]-1, telescopes[1]-1
                ib = ct.posk(itel1, itel2, config.NA)
                Value = np.max(criteria[:,ig,ip,ib])
                bestDIT = DITs[np.argmax(criteria[:,ig,ip,ib])]
            
            if verbose2:
                print(&#34;-------------------------------------------&#34;)
                print(f&#39;\nComputed value={round(Value,5)}&#39;)
            if Value &lt; minValue:    
                if verbose2:
                    print(f&#34;New value={round(Value,5)} lower than minValue={round(minValue,5)} obtained with (GD,PD)=({Ggd},{Gpd})&#34;)
                minValue = Value
                iOptim = igp
                iOptimGD = ig
                iOptimPD = ip
            else:
                if verbose2:
                    print(f&#34;We keep minimal value={round(minValue,5)} obtained with gains (GD,PD)=({GainsGD[iOptimGD]},{GainsPD[iOptimPD]})&#34;)

            Progress = LoopNumber/NumberOfLoops
            PassedTime = time.time() - time0
            RemainingTime = PassedTime/Progress - PassedTime
            
            
            if verbose:
                print(f&#34;Progression current optim: {round(LoopNumber/NumberOfLoops*100)}% ({strtime(PassedTime)}) - \
Remains {strtime(RemainingTime)}&#34;)
                print(&#34;-------------------------------------------\n&#34;)

    bestGains = GainsGD[iOptimGD], GainsPD[iOptimPD]
    
    
    from tabulate import tabulate
    # ich = [12,13,14,15,16,23,24,25,26,34,35,36,45,46,56]
    ichint = [int(&#39;&#39;.join([str(int(ic[0]+1)),str(int(ic[1]+1))])) for ic in config.ich] # Convert list of tuples into list of int
    telint = np.arange(1,NA+1)
    criteriasBase = [&#34;LR&#34;, &#34;LR2&#34;, &#34;LR3&#34;, &#34;WLR&#34;, &#34;FC&#34;, &#34;SNR(|V|Â²)&#34;,&#34;VarOPD [Âµm]&#34;,
                     &#34;VarGDRes&#34;,&#34;VarPDRes&#34;,&#34;InstVarPD&#34;,&#34;InstVarGD&#34;,&#34;InstVarGDUnbiased&#34;,
                     &#34;VarPDnum&#34;, &#34;VarPDdenom&#34;,&#34;VarGDdenom&#34;,&#34;VarGDdenomUnbiased&#34;, 
                     &#34;SNRPD&#34;,&#34;SNRGD&#34;,&#34;ThresholdGDs&#34;,
                     &#39;Vmod&#39;,&#39;Vangle&#39;]
    
    Ncb = len(criteriasBase)
    # A=list(np.repeat(GainsGD, Ncb)) ; B = criteriasBase*Ngains
    
    A = list(np.repeat(DITs, NgainsGD*NgainsPD*Ncb))
    Btemp = list(np.repeat(GainsGD,Ncb*NgainsPD))
    B = Btemp * NDIT
    Ctemp = list(np.repeat(GainsPD,Ncb))
    C = Ctemp * NDIT * NgainsGD
    C2 = list(np.repeat(IDs,Ncb)) * NDIT            # ID of the last simu
    C3 = list(np.repeat(ThresholdGDmins,Ncb)) * NDIT   # ThresholdGD
    C4 = list(np.repeat(ThresholdGDmaxs,Ncb)) * NDIT   # ThresholdGD
    D = criteriasBase * NDIT * NgainsGD * NgainsPD 
    
    base_5d = np.array([LockedRatio,LR2,LR3,WLockedRatio,FCArray,SNRSI,VarOPD,
                        VarGDRes,VarPDRes,InstVarPD,InstVarGD,InstVarGDUnbiased,
                        VarPDnum, VarPDdenom,VarGDdenom,VarGDdenomUnbiased,
                        np.sqrt(1/InstVarPD),np.sqrt(1/InstVarGD),
                        ThresholdGDs, Vmod,Vangle])
    base_5d = np.transpose(base_5d, (0,3,2,1,4))      # Trick to get the levels DIT, GD and PD in this order
    
    base_2d = base_5d.reshape([NDIT*Ncb*NgainsGD*NgainsPD,NIN], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
    
    # Need another dataframe only for Closure Phase (dimension 10)
    
    resultsBasedf = pd.DataFrame(data=base_2d, columns=[A,B,C,C2,C3,C4,D], index=ichint)
    
    CPindexint = [int(&#39;&#39;.join([str(int(cpindex[0]+1)),str(int(cpindex[1]+1)),str(int(cpindex[2]+1))])) for cpindex in config.CPindex]
    
    criteriasClosure = [&#34;VarCP [Âµm]&#34;, &#34;LR&#34;, &#34;WLR&#34;]
    
    Ncc = len(criteriasClosure)
    A = list(np.repeat(DITs, NgainsGD*NgainsPD*Ncc))
    Btemp = list(np.repeat(GainsGD,Ncc*NgainsPD))
    B = Btemp * NDIT
    Ctemp = list(np.repeat(GainsPD,Ncc))
    C = Ctemp * NDIT * NgainsGD
    C2 = list(np.repeat(IDs,Ncc)) * NDIT
    C3 = list(np.repeat(ThresholdGDmins,Ncc)) * NDIT
    C4 = list(np.repeat(ThresholdGDmaxs,Ncc)) * NDIT
    D = criteriasClosure * NDIT * NgainsGD * NgainsPD 
    
    
    # We only have VarCP so far so we populate the missing criteria with NaN values.
    CPLR = np.ones([NDIT,NgainsGD, NgainsPD,NC])*np.nan
    CPWLR = np.ones([NDIT,NgainsGD,NgainsPD,NC])*np.nan
    
    closure_5d = np.array([VarCP,CPLR,CPWLR])
    closure_5d = np.transpose(closure_5d, (0,3,2,1,4))
    
    closure_2d = closure_5d.reshape([NDIT*Ncc*NgainsGD*NgainsPD,NC], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows

    resultsClosuredf = pd.DataFrame(data=closure_2d, columns=[A,B,C,C2,C3,C4,D],index=CPindexint)
    
    &#34;&#34;&#34;
    Residues on Telescopes
    &#34;&#34;&#34;
    criteriasTel = [&#34;VarPiston&#34;,&#34;VarPistonGD&#34;,&#34;VarPistonPD&#34;]
    
    Nct = len(criteriasTel)
    
    A = list(np.repeat(DITs, NgainsGD*NgainsPD*Nct))
    Btemp = list(np.repeat(GainsGD,Nct*NgainsPD))
    B = Btemp * NDIT
    Ctemp = list(np.repeat(GainsPD,Nct))
    C = Ctemp * NDIT * NgainsGD
    C2 = list(np.repeat(IDs,Nct)) * NDIT            # ID of the last simu
    C3 = list(np.repeat(ThresholdGDmins,Nct)) * NDIT   # ThresholdGD
    C4 = list(np.repeat(ThresholdGDmaxs,Nct)) * NDIT   # ThresholdGD
    D = criteriasTel * NDIT * NgainsGD * NgainsPD 
    
    tel_5d = np.array([VarPiston,VarPistonGD,VarPistonPD])
    tel_5d = np.transpose(tel_5d, (0,3,2,1,4))      # Trick to get the levels DIT, GD and PD in this order
    
    tel_2d = tel_5d.reshape([NDIT*Nct*NgainsGD*NgainsPD,NA], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
    
    # Need another dataframe only for Closure Phase (dimension 10)
    
    resultsTeldf = pd.DataFrame(data=tel_2d, columns=[A,B,C,C2,C3,C4,D], index=telint)
    
    
    if not telescopes:
        Base_av = resultsBasedf.mean(axis=0).to_frame(name=&#39;Average&#39;)
        Closure_av = resultsClosuredf.mean(axis=0).to_frame(name=&#39;Average&#39;)
        Tel_av = resultsBasedf.mean(axis=0).to_frame(name=&#39;Average&#39;)
    else:
        itel1,itel2 = telescopes[0]-1, telescopes[1]-1
        ib = ct.posk(itel1, itel2, config.NA)
        ia = telescopes[0]-1  # histoire de mettre un truc, mais Ã  modifier si besoin
        Base_av = resultsBasedf.iloc[ib].to_frame(name=f&#34;{telescopes[0]}{telescopes[1]}&#34;)
        Closure_av = resultsClosuredf.iloc[ib].to_frame(name=f&#34;{telescopes[0]}{telescopes[1]}&#34;)
        Tel_av = resultsTeldf.iloc[ia].to_frame(name=f&#34;{telescopes[0]}&#34;)
        
    if optimCriteria==&#34;VarOPD&#34;:
        criteriaName = &#34;VarOPD [Âµm]&#34; 
    elif optimCriteria==&#34;FC&#34;:
        criteriaName = &#34;FC&#34;
    elif optimCriteria == &#34;LR&#34;:
        criteriaName = &#34;LR&#34;
    elif optimCriteria == &#34;WLR&#34;:
        criteriaName = &#34;WLR&#34;
    elif optimCriteria == &#34;VarCP&#34;:
        criteriaName = &#34;VarCP [Âµm]&#34;
    elif optimCriteria == &#34;VarPiston&#34;:
        criteriaName = &#34;VarPiston&#34;
    
    if criteriaName not in (&#34;VarCP&#34;,&#34;VarPiston&#34;):
        bestCombi = Base_av.loc[(slice(None),slice(None),slice(None),
                                 slice(None),slice(None),slice(None), 
                                 criteriaName)].idxmax(skipna=True)[0]
    elif criteriaName == &#39;VarPiston&#39;:
        bestCombi = Tel_av.loc[(slice(None),slice(None),slice(None),
                                 slice(None),slice(None),slice(None), 
                                 criteriaName)].idxmax(skipna=True)[0]
    else:
        bestCombi = Closure_av.loc[(slice(None),slice(None),slice(None)
                                    ,slice(None),slice(None),slice(None),
                                    criteriaName)].idxmax(skipna=True)[0]
        
    bestDIT, bestGainGD, bestGainPD = bestCombi[:3]

    if verbose2:
        print(f&#34;Best performances OPD reached with gains\
(GD,PD)={(bestGainGD, bestGainPD)} and DIT={bestDIT}ms&#34;)
        print(tabulate(resultsBasedf[bestCombi], headers=&#34;keys&#34;))
        
        print(f&#34;Same for closure phases with gain={bestGains}&#34;)
        print(tabulate(resultsClosuredf[bestCombi], headers=&#34;keys&#34;))
        
        print(f&#34;Same for telescopes with gain={bestGains}&#34;)
        print(tabulate(resultsTeldf[bestCombi], headers=&#34;keys&#34;))
   
    if display or len(figsave):
        if verbose2:
            print(&#34;We launch again the simulation with these gains on the last\
disturbance file to show the results.&#34;)
        
        config.FT[&#39;GainGD&#39;] = bestGainGD
        config.FT[&#39;GainPD&#39;] = bestGainPD
        sk.update_config(DisturbanceFile=DisturbanceFile,checkperiod=40, verbose=verbose)
        
        # Launch the simulator
        sk.loop(verbose=verbose,verbose2=verbose2)
        sk.display(&#39;perfarray&#39;,WLOfScience=np.median(SpectraForScience),display=display,
                   savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
    
    return bestCombi, resultsBasedf,  resultsClosuredf, resultsTeldf


def OptimGainsTogether_multiDITs(GainsPD=[],GainsGD=[],DITs=np.logspace(0,500,20), 
                        optimCriteria=&#34;FC&#34;,filedir=&#39;&#39;,Nsamples=5,
                        TimeBonds=100, WLOfTrack=1.5,SpectraForScience=np.arange(0.6,0.9,0.005),
                        FileInterferometer=&#39;&#39;,MagnitudeInScienceBand=-1,telescopes=0, 
                        save_all=&#39;no&#39;,onlySNR=False,ComputeAllPerf=True,
                        savepath=&#39;./&#39;,figsave=&#39;&#39;,
                        display=False,verbose=False,verbose2=False, criterias=&#39;light&#39;):
    &#34;&#34;&#34;
    Estimates the best couple GD and PD gains after calculating the performance 
    (residual phase) of the servo loop on all the files contained in filedir.

    Parameters
    ----------
    GainsPD : TYPE, optional
        DESCRIPTION. The default is [].
    GainsGD : TYPE, optional
        DESCRIPTION. The default is [].
    optim : TYPE, optional
        DESCRIPTION. The default is &#39;opd&#39;.
    filedir : TYPE, optional
        DESCRIPTION. The default is &#39;&#39;.
    TimeBonds : TYPE, optional
        DESCRIPTION. The default is 100.
    WLOfScience : TYPE, optional
        DESCRIPTION. The default is 1.5.
    DIT : TYPE, optional
        DESCRIPTION. The default is 50.
    telescopes : TYPE, optional
        DESCRIPTION. The default is 0.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    
    from . import simu
    from . import config
    import pandas as pd
    
    from .config import NA, NIN, NC, NT, dt
        
    if not (len(GainsPD) and len(GainsPD)):
        raise Exception(&#39;Need GainsPD and GainsGD.&#39;)
    
    NgainsGD = len(GainsGD)
    NgainsPD = len(GainsPD)
        
    if verbose2:
        print(f&#34;Start optimisation with sample gains GD={GainsGD} and PD={GainsPD}&#34;)
    
    sk.update_config(checkperiod=110,verbose=verbose) # For not seeing the decount.
    
    if not len(FileInterferometer):
        FileInterferometer = &#34;data/interferometers/CHARAinterferometerR.fits&#34;
    
    if MagnitudeInScienceBand&lt;0:
        if &#39;SImag&#39; not in config.Target.Star1.keys():
            config.Target.Star1[&#39;SImag&#39;] = config.Target.Star1[&#39;Hmag&#39;]
    else:
        config.Target.Star1[&#39;SImag&#39;] = MagnitudeInScienceBand
    
    
    # The interferometer is &#34;not the same&#34; as for simulation, because not the same band.
    # In the future, both bands could be integrated in the same Interf class object.
    InterfArray = ct.get_array(name=FileInterferometer)
    
    CoherentFluxObject = ct.create_CfObj(SpectraForScience,
                                         config.Obs,config.Target,InterfArray)
    
    CoherentFluxObject = CoherentFluxObject*dt*1e-3
    
    minValue = 10000
    if len(filedir):
        files = [f.replace(&#34;\\&#34;,&#34;/&#34;) for f in glob.glob(filedir+&#39;*.fits&#39;)]
        Nfiles = len(files)
        if verbose2:
            print(f&#34;Found: {Nfiles} files&#34;)
        if Nsamples &lt; Nfiles:
            Nfiles = Nsamples
        if verbose2:
            print(f&#34;Take only the {Nsamples} first files&#34;)
    else:
        files = [config.DisturbanceFile]
        Nfiles = 1
    
    
    &#34;&#34;&#34; RECOMPUTATION OF THE INTEGRATION TIMES TO AVOID LOSS OF FRAMES&#34;&#34;&#34;
    
    if isinstance(TimeBonds,(float,int)):
        Period = int(NT - TimeBonds/dt)
        InFrame = round(TimeBonds/dt)
    elif isinstance(TimeBonds,(np.ndarray,list)):
        Period = int((TimeBonds[1]-TimeBonds[0])/dt)
        InFrame = round(TimeBonds[0]/dt)
    else:
        raise &#39;&#34;TimeBonds&#34; must be instance of (float,int,np.ndarray,list)&#39;


    DITf=DITs/dt
    #IntegrationTimes = IntegrationTimes//dt * dt
    Ndit=len(DITf)
    
    ObservingTime = Period*dt

    NewDITf=[]#DITf.copy()
    kbefore=[]
    for idit in range(Ndit):
        k = Period//DITf[idit]
        if k in kbefore: 
            k=np.min(kbefore)-1  # Avoid that two DITs be the same
        if k == -1:
            break # Stop if we reached the unique frame.
        r = Period%DITf[idit]
        if r &gt; 0.05*DITf[idit]:
            NewDITf.append(Period//(k+1))
        kbefore.append(k)
        
    NewDITf = np.array(NewDITf)
    newDITs = NewDITf*dt
    ListNframes = Period//NewDITf
    ThrownFrames = Period%NewDITf
    LengthOfKeptSequence = ListNframes * Period
    
    if verbose:
        print(f&#34;ObservingTimes:{ObservingTime}&#34;)
        print(f&#34;Proposed DITs:{DITs}&#34;)
        print(f&#34;ListNframes :{ListNframes}&#34;)
        print(f&#34;ThrownFrames :{ThrownFrames}&#34;)
        print(f&#34;New DITs:{newDITs}&#34;)
        print(f&#34;Percentage of loss: {np.round(ThrownFrames/LengthOfKeptSequence*100,2)}&#34;)
    # if ThrownFrames[idit] &gt; 0.05*LengthOfKeptSequence[idit]:
    #     NewIntegrationTimes.remove(IntegrationTimes[idit])
            
    simu.DITsForPerformance = newDITs
    Ndit = len(newDITs)
    
    time0 = time.time() ; LoopNumber = 0
    iOptimGD=0; iOptimPD=0 ; IDs=[] ; ThresholdGDmins=[] ; ThresholdGDmaxs=[]

    indWLOfTrack = np.argmin(np.abs(config.spectra-WLOfTrack))
    NumberOfLoops = NgainsGD*NgainsPD*Nfiles
    for ig in range(NgainsGD):
        Ggd = GainsGD[ig]    
        if verbose2:
            print(f&#34;-----------Start optimising with gain GD={Ggd}------------&#34;)   
        
        for ip in range(NgainsPD):
            igp = ig*NgainsPD + ip  # Position in the tables
            minindcurrentGD = ig*NgainsPD
            maxindcurrentGD = minindcurrentGD + NgainsPD
            
            Gpd = GainsPD[ip]
            
            config.FT[&#39;GainGD&#39;] = Ggd
            config.FT[&#39;GainPD&#39;] = Gpd
            
            if verbose:
                print(&#34;\n----------------------------------&#34;)
                print(f&#39;## Gain GD={Ggd}; GainPD={Gpd} ##&#39;)
                
            for ifile in range(Nfiles):
                LoopNumber+=1
                DisturbanceFile = files[ifile]
                if verbose2:
                    print(f&#39;File {ifile+1}/{Nfiles}&#39;)
                
                sk.update_config(DisturbanceFile=DisturbanceFile, verbose=verbose)
            
                # Launch the simulator
                if save_all==&#39;light&#39;:
                    sk.loop(savepath,LightSave=True,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;OPDTrue&#39;:
                    sk.loop(savepath,LightSave=&#39;OPDTrue&#39;,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;yes&#39;:
                    sk.loop(savepath,LightSave=False,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;no&#39;:
                    sk.loop(verbose=verbose,verbose2=verbose2)
                else:
                    raise Exception(&#39;save_all param must be &#34;light&#34;, &#34;yes&#34; or &#34;no&#34;.&#39;)
                    
                if len(figsave):
                    if figsave != &#39;onlyperf&#39;:
                        if isinstance(figsave,str):
                            sk.display(figsave,display=display,savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
                        elif isinstance(figsave,list):
                            if &#39;perfarray&#39; in figsave:
                                figsave.remove(&#39;perfarray&#39;)
                            sk.display(*figsave,display=display,savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
                        

                if ComputeAllPerf:
    
                    # Load the performance observables into simu module
                    _ = sk.ShowPerformance_multiDITs(TimeBonds,SpectraForScience,newDITs,
                                                 CoherentFluxObject=CoherentFluxObject,
                                                 display=False,verbose=verbose, onlySNR=onlySNR, criterias=criterias)
                    
                    if LoopNumber==1:
                        NDIT=len(newDITs) ; DITs = newDITs
                        
                        VarOPD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])         # Phase variances
                        VarGDRes = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # GD Phase variances after Igd dot
                        VarPDRes = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # PD Phase variances after Ipd dot
                        VarGDEst = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # GD estimator variances 
                        VarPDEst = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # PD estimator variances
                        
                        FCArray = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])        # Contains the fringe contrasts
                        LockedRatio = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])    # Locked ratio
                        LR2 = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Locked ratio
                        LR3 = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Central fringe ratio
                        
                        
                        VarCP = np.zeros([NDIT,NgainsGD,NgainsPD,NC])           # Closure Phase variances
                        SNRSI = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])          # Signal-to-noise ratio in the scientific instrument
                        
                        Vmod = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
                        Vangle = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
                        
                        ThresholdGDs = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
                        InstVarPD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
                        InstVarGD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated GD variances
                        VarPiston = np.zeros([NDIT,NgainsGD,NgainsPD,NA])       # Piston variance
                        VarPistonGD = np.zeros([NDIT,NgainsGD,NgainsPD,NA])     # Piston GD variance
                        VarPistonPD = np.zeros([NDIT,NgainsGD,NgainsPD,NA])     # Piston PD variance
                        
                        if criterias!=&#39;light&#39;:
                        
                            InstVarGDUnbiased = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
                            VarPDnum = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # Estimated PD variances
                            VarGDdenom = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
                            VarGDdenomUnbiased = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
                            VarPDdenom = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
    
                            WLockedRatio = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])   # Weigthed locked ratio
                            
                    
                    # Initialise the comparison tables
                    VarOPD[:,ig,ip,:] += simu.VarOPD/Nfiles
                    VarCP[:,ig,ip,:] += simu.VarCPD/Nfiles
                    VarGDRes[:,ig,ip,:] += simu.VarGDRes/Nfiles
                    VarPDRes[:,ig,ip,:] += simu.VarPDRes/Nfiles
                    VarGDEst[:,ig,ip,:] += simu.VarGDEst/Nfiles
                    VarPDEst[:,ig,ip,:] += simu.VarPDEst/Nfiles
    
                    SNRSI[:,ig,ip,:] += simu.SNR_E/Nfiles
                    FCArray[:,ig,ip,:] += np.mean(simu.FringeContrast,axis=1)/Nfiles
                    LockedRatio[:,ig,ip,:] += simu.LockedRatio/Nfiles
    
                    LR2[:,ig,ip,:] += simu.LR2/Nfiles # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    LR3[:,ig,ip,:] += simu.LR3/Nfiles # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                
                    Vmod[:,ig,ip,:] = np.repeat(np.real(ct.NB2NIN(np.abs(simu.VisibilityObject[indWLOfTrack])))[np.newaxis,:],NDIT,0)
                    Vangle[:,ig,ip,:] = np.repeat(np.real(ct.NB2NIN(np.angle(simu.VisibilityObject[indWLOfTrack])))[np.newaxis,:],NDIT,0)
            
                    ThresholdGDs[:,ig,ip,:] = np.repeat(config.FT[&#39;ThresholdGD&#39;][np.newaxis,:],NDIT,0) # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    InstVarPD[:,ig,ip,:] += np.repeat(np.mean(simu.varPD,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    InstVarGD[:,ig,ip,:] += np.repeat(np.mean(simu.varGD,axis=0)[np.newaxis,:],NDIT,0)/Nfiles
    
                    VarPiston[:,ig,ip,:] += simu.VarPiston/Nfiles
                    VarPistonGD[:,ig,ip,:] += simu.VarPistonGD/Nfiles
                    VarPistonPD[:,ig,ip,:] += simu.VarPistonPD/Nfiles
    
                    if criterias!=&#39;light&#39;:
                        
                        WLockedRatio[:,ig,ip,:] += simu.WLockedRatio/Nfiles
                
                        # These values don&#39;t have DIT dimension, so we must repeat it over
                        # this dimension for inserting it in dataframe.
                        
                        # Average of the estimated instantaneous variance. (has a 
                        # signification only in open loop)
                        InstVarGDUnbiased[:,ig,ip,:] += np.repeat(np.mean(simu.varGDUnbiased,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                        VarPDnum[:,ig,ip,:] += np.repeat(np.mean(simu.varPDnum,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                        VarPDdenom[:,ig,ip,:] += np.repeat(np.mean(simu.varPDdenom,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                        VarGDdenom[:,ig,ip,:] += np.repeat(np.mean(simu.varGDdenom,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                        VarGDdenomUnbiased[:,ig,ip,:] += np.repeat(np.mean(simu.varGDdenomUnbiased,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    
                        
            IDs.append(config.SimuTimeID)
            ThresholdGDmins.append(np.min(config.FT[&#39;ThresholdGD&#39;]))
            ThresholdGDmaxs.append(np.max(config.FT[&#39;ThresholdGD&#39;]))
            
            if optimCriteria==&#34;VarOPD&#34;:
                criteria = VarOPD
            elif optimCriteria==&#34;FC&#34;:
                criteria = 1-FCArray
            elif optimCriteria==&#34;SNRSI&#34;:
                criteria = 1/SNRSI
            elif optimCriteria == &#34;LR&#34;:
                criteria = 1-LockedRatio
            elif optimCriteria == &#34;LR2&#34;:
                criteria = 1-LR2
            elif optimCriteria == &#34;WLR&#34;:
                criteria = 1-WLockedRatio
            elif optimCriteria == &#34;VarCP&#34;:
                if (not telescopes) and (len(telescopes) != 3):
                    raise Exception(&#39;For defining a closure phase, telescopes must be three.&#39;)
                else:
                    criteria = VarCP
            else:
                raise Exception(f&#39;The chosen criteria must be in this list: &#34;LR&#34;, &#34;LR2&#34;,&#34;WLR&#34;, &#34;FC&#34;, &#34;VarOPD&#34;, &#34;VarCP&#34;&#39;)
                    
                    
            if not telescopes:
                Value = np.max(np.mean(criteria[:,ig,ip,:], axis=-1))   # Maximum (over DITs) of the averaged value (over baselines)
                bestDIT = DITs[np.argmax(np.mean(criteria[:,ig,ip,:], axis=-1))]
            else:
                itel1,itel2 = telescopes[0]-1, telescopes[1]-1
                ib = ct.posk(itel1, itel2, config.NA)
                Value = np.max(criteria[:,ig,ip,ib])
                bestDIT = DITs[np.argmax(criteria[:,ig,ip,ib])]
            
            if verbose2:
                print(&#34;-------------------------------------------&#34;)
                print(f&#39;\nComputed value={round(Value,5)}&#39;)
            if Value &lt; minValue:    
                if verbose2:
                    print(f&#34;New value={round(Value,5)} lower than minValue={round(minValue,5)} obtained with (GD,PD)=({Ggd},{Gpd})&#34;)
                minValue = Value
                iOptim = igp
                iOptimGD = ig
                iOptimPD = ip
            else:
                if verbose2:
                    print(f&#34;We keep minimal value={round(minValue,5)} obtained with gains (GD,PD)=({GainsGD[iOptimGD]},{GainsPD[iOptimPD]})&#34;)

            Progress = LoopNumber/NumberOfLoops
            PassedTime = time.time() - time0
            RemainingTime = PassedTime/Progress - PassedTime
            
            
            if verbose:
                print(f&#34;Progression current optim: {round(LoopNumber/NumberOfLoops*100)}% ({strtime(PassedTime)}) - \
    Remains {strtime(RemainingTime)}&#34;)
                print(&#34;-------------------------------------------\n&#34;)

    if not ComputeAllPerf:
        return
    
    else:
        
        bestGains = GainsGD[iOptimGD], GainsPD[iOptimPD]
        
        from tabulate import tabulate
        # ich = [12,13,14,15,16,23,24,25,26,34,35,36,45,46,56]
        ichint = [int(&#39;&#39;.join([str(int(ic[0]+1)),str(int(ic[1]+1))])) for ic in config.ich] # Convert list of tuples into list of int
        telint = np.arange(1,NA+1)
        
        if criterias==&#39;light&#39;:
            criteriasBase = [&#34;LR&#34;, &#34;LR2&#34;, &#34;LR3&#34;, &#34;FC&#34;, &#34;SNR(|V|Â²)&#34;,&#34;VarOPD [Âµm]&#34;,
                             &#34;SNRPD&#34;,&#34;SNRGD&#34;,&#34;ThresholdGDs&#34;,
                             &#39;Vmod&#39;,&#39;Vangle&#39;]
        
        else:
            criteriasBase = [&#34;LR&#34;, &#34;LR2&#34;, &#34;LR3&#34;, &#34;WLR&#34;, &#34;FC&#34;, &#34;SNR(|V|Â²)&#34;,&#34;VarOPD [Âµm]&#34;,
                             &#34;VarGDRes&#34;,&#34;VarPDRes&#34;,&#34;VarGDEst&#34;,&#34;VarPDEst&#34;,&#34;InstVarPD&#34;,&#34;InstVarGD&#34;,&#34;InstVarGDUnbiased&#34;,
                             &#34;VarPDnum&#34;, &#34;VarPDdenom&#34;,&#34;VarGDdenom&#34;,&#34;VarGDdenomUnbiased&#34;, 
                             &#34;SNRPD&#34;,&#34;SNRGD&#34;,&#34;ThresholdGDs&#34;,
                               &#39;Vmod&#39;,&#39;Vangle&#39;]  
        
        Ncb = len(criteriasBase)
        # A=list(np.repeat(GainsGD, Ncb)) ; B = criteriasBase*Ngains
        
        A = list(np.repeat(DITs, NgainsGD*NgainsPD*Ncb))
        Btemp = list(np.repeat(GainsGD,Ncb*NgainsPD))
        B = Btemp * NDIT
        Ctemp = list(np.repeat(GainsPD,Ncb))
        C = Ctemp * NDIT * NgainsGD
        C2 = list(np.repeat(IDs,Ncb)) * NDIT            # ID of the last simu
        C3 = list(np.repeat(ThresholdGDmins,Ncb)) * NDIT   # ThresholdGD
        C4 = list(np.repeat(ThresholdGDmaxs,Ncb)) * NDIT   # ThresholdGD
        D = criteriasBase * NDIT * NgainsGD * NgainsPD 
        
        if criterias==&#39;light&#39;:
            base_5d = np.array([LockedRatio,LR2,LR3,FCArray,SNRSI,VarOPD,
                                np.sqrt(1/InstVarPD),np.sqrt(1/InstVarGD),
                                ThresholdGDs, Vmod,Vangle])
        else:
            base_5d = np.array([LockedRatio,LR2,LR3,WLockedRatio,FCArray,SNRSI,VarOPD,
                                VarGDRes,VarPDRes,VarGDEst,VarPDEst,InstVarPD,InstVarGD,InstVarGDUnbiased,
                                VarPDnum, VarPDdenom,VarGDdenom,VarGDdenomUnbiased,
                                np.sqrt(1/InstVarPD),np.sqrt(1/InstVarGD),
                                ThresholdGDs, Vmod,Vangle])
            
        base_5d = np.transpose(base_5d, (0,3,2,1,4))      # Trick to get the levels DIT, GD and PD in this order
        
        base_2d = base_5d.reshape([NDIT*Ncb*NgainsGD*NgainsPD,NIN], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
        
        resultsBasedf = pd.DataFrame(data=base_2d, columns=[A,B,C,C2,C3,C4,D], index=ichint)
        
        CPindexint = [int(&#39;&#39;.join([str(int(cpindex[0]+1)),str(int(cpindex[1]+1)),str(int(cpindex[2]+1))])) for cpindex in config.CPindex]
        
        criteriasClosure = [&#34;VarCP [Âµm]&#34;, &#34;LR&#34;, &#34;WLR&#34;]
        
        Ncc = len(criteriasClosure)
        A = list(np.repeat(DITs, NgainsGD*NgainsPD*Ncc))
        Btemp = list(np.repeat(GainsGD,Ncc*NgainsPD))
        B = Btemp * NDIT
        Ctemp = list(np.repeat(GainsPD,Ncc))
        C = Ctemp * NDIT * NgainsGD
        C2 = list(np.repeat(IDs,Ncc)) * NDIT
        C3 = list(np.repeat(ThresholdGDmins,Ncc)) * NDIT
        C4 = list(np.repeat(ThresholdGDmaxs,Ncc)) * NDIT
        D = criteriasClosure * NDIT * NgainsGD * NgainsPD 
        
        
        # We only have VarCP so far so we populate the missing criteria with NaN values.
        CPLR = np.ones([NDIT,NgainsGD, NgainsPD,NC])*np.nan
        CPWLR = np.ones([NDIT,NgainsGD,NgainsPD,NC])*np.nan
        
        closure_5d = np.array([VarCP,CPLR,CPWLR])
        closure_5d = np.transpose(closure_5d, (0,3,2,1,4))
        
        closure_2d = closure_5d.reshape([NDIT*Ncc*NgainsGD*NgainsPD,NC], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
    
        resultsClosuredf = pd.DataFrame(data=closure_2d, columns=[A,B,C,C2,C3,C4,D],index=CPindexint)
        
        &#34;&#34;&#34;
        Residues on Telescopes
        &#34;&#34;&#34;
        criteriasTel = [&#34;VarPiston&#34;,&#34;VarPistonGD&#34;,&#34;VarPistonPD&#34;]
        
        Nct = len(criteriasTel)
        # A=list(np.repeat(GainsGD, Ncb)) ; B = criteriasBase*Ngains
        
        A = list(np.repeat(DITs, NgainsGD*NgainsPD*Nct))
        Btemp = list(np.repeat(GainsGD,Nct*NgainsPD))
        B = Btemp * NDIT
        Ctemp = list(np.repeat(GainsPD,Nct))
        C = Ctemp * NDIT * NgainsGD
        C2 = list(np.repeat(IDs,Nct)) * NDIT            # ID of the last simu
        C3 = list(np.repeat(ThresholdGDmins,Nct)) * NDIT   # ThresholdGD
        C4 = list(np.repeat(ThresholdGDmaxs,Nct)) * NDIT   # ThresholdGD
        D = criteriasTel * NDIT * NgainsGD * NgainsPD 
        
        tel_5d = np.array([VarPiston,VarPistonGD,VarPistonPD])
        tel_5d = np.transpose(tel_5d, (0,3,2,1,4))      # Trick to get the levels DIT, GD and PD in this order
        
        tel_2d = tel_5d.reshape([NDIT*Nct*NgainsGD*NgainsPD,NA], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
        
        # Need another dataframe only for Closure Phase (dimension 10)
        
        resultsTeldf = pd.DataFrame(data=tel_2d, columns=[A,B,C,C2,C3,C4,D], index=telint)
        
        if not telescopes:
            Base_av = resultsBasedf.mean(axis=0).to_frame(name=&#39;Average&#39;)
            Closure_av = resultsClosuredf.mean(axis=0).to_frame(name=&#39;Average&#39;)
            Tel_av = resultsBasedf.mean(axis=0).to_frame(name=&#39;Average&#39;)
        else:
            itel1,itel2 = telescopes[0]-1, telescopes[1]-1
            ib = ct.posk(itel1, itel2, config.NA)
            ia = telescopes[0]-1  # histoire de mettre un truc, mais Ã  modifier si besoin
            Base_av = resultsBasedf.iloc[ib].to_frame(name=f&#34;{telescopes[0]}{telescopes[1]}&#34;)
            Closure_av = resultsClosuredf.iloc[ib].to_frame(name=f&#34;{telescopes[0]}{telescopes[1]}&#34;)
            Tel_av = resultsTeldf.iloc[ia].to_frame(name=f&#34;{telescopes[0]}&#34;)
            
        if optimCriteria==&#34;VarOPD&#34;:
            criteriaName = &#34;VarOPD [Âµm]&#34; 
        elif optimCriteria==&#34;FC&#34;:
            criteriaName = &#34;FC&#34;
        elif optimCriteria==&#34;SNRSI&#34;:
            criteriaName= &#34;SNR(|V|Â²)&#34;
        elif optimCriteria == &#34;LR&#34;:
            criteriaName = &#34;LR&#34;
        elif optimCriteria == &#34;WLR&#34;:
            criteriaName = &#34;WLR&#34;
        elif optimCriteria == &#34;VarCP&#34;:
            criteriaName = &#34;VarCP [Âµm]&#34;
        elif optimCriteria == &#34;VarPiston&#34;:
            criteriaName = &#34;VarPiston&#34;
        
        if criteriaName not in (&#34;VarCP&#34;,&#34;VarPiston&#34;):
            bestCombi = Base_av.loc(axis=0)[:,:,:,:,:,:,
                                            criteriaName].idxmax(skipna=True)[0]
        elif criteriaName == &#39;VarPiston&#39;:
            bestCombi = Tel_av.loc(axis=0)[:,:,:,:,:,:,
                                           criteriaName].idxmax(skipna=True)[0]
        else:
            bestCombi = Closure_av.loc(axis=0)[:,:,:,:,:,:,
                                               criteriaName].idxmax(skipna=True)[0]
        
        bestDIT, bestGainGD, bestGainPD = bestCombi[:3]
        
        if verbose2:
            print(f&#34;Best performances OPD reached with gains\
    (GD,PD)={(bestGainGD, bestGainPD)} and DIT={bestDIT}ms&#34;)
            print(tabulate(resultsBasedf[bestCombi], headers=&#34;keys&#34;))
            
            print(f&#34;Same for closure phases with gain={bestGains}&#34;)
            print(tabulate(resultsClosuredf[bestCombi], headers=&#34;keys&#34;))
            
            print(f&#34;Same for telescopes with gain={bestGains}&#34;)
            print(tabulate(resultsTeldf[bestCombi], headers=&#34;keys&#34;))
       
        if display or len(figsave):
            if verbose2:
                print(&#34;We launch again the simulation with these gains on the last\
    disturbance file to show the results.&#34;)
            
            config.FT[&#39;GainGD&#39;] = bestGainGD
            config.FT[&#39;GainPD&#39;] = bestGainPD
            sk.update_config(DisturbanceFile=DisturbanceFile,checkperiod=40, verbose=verbose)
            
            # Launch the simulator
            sk.loop(verbose=verbose, verbose2=verbose2)
            # sk.display(&#39;perfarray&#39;,WLOfScience=np.median(SpectraForScience),display=display,
            #            savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
    
        return bestCombi, resultsBasedf,  resultsClosuredf, resultsTeldf




def calcRMS(startframe):
    &#34;&#34;&#34;
    Calculates the Standard Deviation of the OPD in micrometers.
        

    Parameters
    ----------
    startframe : integer
        Starting time in the loop. An integer, not in ms for the moment.

    Returns
    -------
    varOPD : float
        .
    varOGD : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    from .simu import OPDTrue
    
    rmsOPD = np.std(OPDTrue[startframe:,:],axis=0)
    
    return rmsOPD


def strtime(time_to_write):
    &#34;&#34;&#34;
    Write a a time given in second on the format ##h##m##s

    Parameters
    ----------
    time_to_write : INT
        SECONDS.

    Returns
    -------
    str
        ##h##m##s.

    &#34;&#34;&#34;
    
    return f&#34;{int(time_to_write//3600)}h{int(time_to_write%3600/60)}m{int((time_to_write%3600)%60)}s&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cophasing.optimisation.OptimGainsTogether"><code class="name flex">
<span>def <span class="ident">OptimGainsTogether</span></span>(<span>GainsPD=[], GainsGD=[], DITs=array([1.00000000e+000, 2.06913808e+026, 4.28133240e+052, 8.85866790e+078,
1.83298071e+105, 3.79269019e+131, 7.84759970e+157, 1.62377674e+184,
3.35981829e+210, 6.95192796e+236, 1.43844989e+263, 2.97635144e+289,
inf,
inf,
inf,
inf,
inf,
inf,
inf,
inf]), optimCriteria='FC', filedir='', Nsamples=5, TimeBonds=100, WLOfTrack=1.5, SpectraForScience=array([0.6
, 0.605, 0.61 , 0.615, 0.62 , 0.625, 0.63 , 0.635, 0.64 ,
0.645, 0.65 , 0.655, 0.66 , 0.665, 0.67 , 0.675, 0.68 , 0.685,
0.69 , 0.695, 0.7
, 0.705, 0.71 , 0.715, 0.72 , 0.725, 0.73 ,
0.735, 0.74 , 0.745, 0.75 , 0.755, 0.76 , 0.765, 0.77 , 0.775,
0.78 , 0.785, 0.79 , 0.795, 0.8
, 0.805, 0.81 , 0.815, 0.82 ,
0.825, 0.83 , 0.835, 0.84 , 0.845, 0.85 , 0.855, 0.86 , 0.865,
0.87 , 0.875, 0.88 , 0.885, 0.89 , 0.895, 0.9
]), telescopes=0, save_all='no', savepath='./', figsave='', display=False, verbose=True, verbose2=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimates the best couple GD and PD gains after calculating the performance
(residual phase) of the servo loop on all the files contained in filedir.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>GainsPD</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is [].</dd>
<dt><strong><code>GainsGD</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is [].</dd>
<dt><strong><code>optim</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 'opd'.</dd>
<dt><strong><code>filedir</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is ''.</dd>
<dt><strong><code>TimeBonds</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 100.</dd>
<dt><strong><code>WLOfScience</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 1.5.</dd>
<dt><strong><code>DIT</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 50.</dd>
<dt><strong><code>telescopes</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 0.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OptimGainsTogether(GainsPD=[],GainsGD=[],DITs=np.logspace(0,500,20), 
                        optimCriteria=&#34;FC&#34;,filedir=&#39;&#39;,Nsamples=5,
                        TimeBonds=100, WLOfTrack=1.5,SpectraForScience=np.arange(0.6,0.9,0.005),
                        telescopes=0, save_all=&#39;no&#39;,savepath=&#39;./&#39;,figsave=&#39;&#39;,
                        display=False,verbose=True,verbose2=False):
    &#34;&#34;&#34;
    Estimates the best couple GD and PD gains after calculating the performance 
    (residual phase) of the servo loop on all the files contained in filedir.

    Parameters
    ----------
    GainsPD : TYPE, optional
        DESCRIPTION. The default is [].
    GainsGD : TYPE, optional
        DESCRIPTION. The default is [].
    optim : TYPE, optional
        DESCRIPTION. The default is &#39;opd&#39;.
    filedir : TYPE, optional
        DESCRIPTION. The default is &#39;&#39;.
    TimeBonds : TYPE, optional
        DESCRIPTION. The default is 100.
    WLOfScience : TYPE, optional
        DESCRIPTION. The default is 1.5.
    DIT : TYPE, optional
        DESCRIPTION. The default is 50.
    telescopes : TYPE, optional
        DESCRIPTION. The default is 0.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    
    from . import simu
    from . import config
    import pandas as pd
    
    from .config import NA, NIN, NC
        
    if not (len(GainsPD) and len(GainsPD)):
        raise Exception(&#39;Need GainsPD and GainsGD.&#39;)
    
    NgainsGD = len(GainsGD)
    NgainsPD = len(GainsPD)
    NDIT = len(DITs)
        
    if verbose2:
        print(f&#34;Start optimisation with sample gains GD={GainsGD} and PD={GainsPD}&#34;)
    
    sk.update_config(checkperiod=110,verbose=verbose) # For not seeing the decount.
    
    VarOPD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])         # Phase variances
    VarGDRes = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # GD Phase variances
    VarPDRes = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # PD Phase variances
    VarGDEst = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # GD Phase variances
    VarPDEst = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # PD Phase variances
    InstVarPD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
    InstVarGD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
    InstVarGDUnbiased = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
    VarPDnum = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # Estimated PD variances
    VarGDdenom = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
    VarGDdenomUnbiased = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
    VarPDdenom = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
    VarPiston = np.zeros([NDIT,NgainsGD,NgainsPD,NA])       # Piston variance
    VarPistonGD = np.zeros([NDIT,NgainsGD,NgainsPD,NA])     # Piston GD variance
    VarPistonPD = np.zeros([NDIT,NgainsGD,NgainsPD,NA])     # Piston PD variance
    VarCP = np.zeros([NDIT,NgainsGD,NgainsPD,NC])           # Closure Phase variances
    SNRSI = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Signal-to-noise ratio in the scientific instrument
    FCArray = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])        # Contains the fringe contrasts
    LockedRatio = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])    # Locked ratio
    WLockedRatio = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])   # Weigthed locked ratio
    LR2 = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Locked ratio
    LR3 = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Central fringe ratio
    
    Vmod = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
    Vangle = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
    
    ThresholdGDs = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
    
    minValue = 10000
    
    NumberOfLoops = NgainsGD*NgainsPD
    
    if len(filedir):
        files = [f.replace(&#34;\\&#34;,&#34;/&#34;) for f in glob.glob(filedir+&#39;*.fits&#39;)]
        Nfiles = len(files)
        if verbose2:
            print(f&#34;Found: {Nfiles} files&#34;)
        if Nsamples &lt; Nfiles:
            Nfiles = Nsamples
        if verbose2:
            print(f&#34;Take only the {Nsamples} first files&#34;)
    else:
        files = [config.DisturbanceFile]
        Nfiles = 1
    
    time0 = time.time() ; LoopNumber = 0
    iOptimGD=0; iOptimPD=0 ; IDs=[] ; ThresholdGDmins=[] ; ThresholdGDmaxs=[]

    indWLOfTrack = np.argmin(np.abs(config.spectra-WLOfTrack))
    
    for ig in range(NgainsGD):
        Ggd = GainsGD[ig]    
        if verbose2:
            print(f&#34;-----------Start optimising with gain GD={Ggd}------------&#34;)   
        
        for ip in range(NgainsPD):
            LoopNumber+=1
            igp = ig*NgainsPD + ip  # Position in the tables
            minindcurrentGD = ig*NgainsPD
            maxindcurrentGD = minindcurrentGD + NgainsPD
            
            Gpd = GainsPD[ip]
            
            config.FT[&#39;GainGD&#39;] = Ggd
            config.FT[&#39;GainPD&#39;] = Gpd
            
            if verbose:
                print(&#34;\n----------------------------------&#34;)
                print(f&#39;## Gain GD={Ggd}; GainPD={Gpd} ##&#39;)
                
            for ifile in range(Nfiles):
                
                DisturbanceFile = files[ifile]
                if verbose2:
                    print(f&#39;File {ifile+1}/{Nfiles}&#39;)
                
                sk.update_config(DisturbanceFile=DisturbanceFile, verbose=verbose)
            
                # Launch the simulator
                if save_all==&#39;light&#39;:
                    sk.loop(savepath,LightSave=True,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;yes&#39;:
                    sk.loop(savepath,LightSave=False,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;no&#39;:
                    sk.loop(verbose=verbose,verbose2=verbose2)
                else:
                    raise Exception(&#39;save_all param must be &#34;light&#34;, &#34;yes&#34; or &#34;no&#34;.&#39;)
                    
                if len(figsave):
                    if figsave != &#39;onlyperf&#39;:
                        if isinstance(figsave,str):
                            sk.display(figsave,display=display,savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
                        elif isinstance(figsave,list):
                            if &#39;perfarray&#39; in figsave:
                                figsave.remove(&#39;perfarray&#39;)
                            sk.display(*figsave,display=display,savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
                        
                # Load the performance observables into simu module
                for idit in range(NDIT):
                    DIT=DITs[idit]
                    sk.ShowPerformance(TimeBonds,SpectraForScience,DIT, display=False)
                    
                    # VarOPD, VarCP, SNRSI, FringeContrast, LockedRatio, WLockedRatio = perfs
                    
                    # Initialise the comparison tables
                    VarOPD[idit,ig,ip,:] += simu.VarOPD/Nfiles
                    VarCP[idit,ig,ip,:] += simu.VarCPD/Nfiles
                    VarGDRes[idit,ig,ip,:] += simu.VarGDRes/Nfiles
                    VarPDRes[idit,ig,ip,:] += simu.VarPDRes/Nfiles
                    VarPiston[idit,ig,ip,:] += simu.VarPiston/Nfiles
                    VarPistonGD[idit,ig,ip,:] += simu.VarPistonGD/Nfiles
                    VarPistonPD[idit,ig,ip,:] += simu.VarPistonPD/Nfiles
                    SNRSI[idit,ig,ip,:] += simu.SNR_E/Nfiles
                    FCArray[idit,ig,ip,:] += simu.FringeContrast[0]/Nfiles
                    LockedRatio[idit,ig,ip,:] += simu.LockedRatio/Nfiles
                    WLockedRatio[idit,ig,ip,:] += simu.WLockedRatio/Nfiles
                
                    LR2[idit,ig,ip,:] += simu.LR2/Nfiles # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    LR3[idit,ig,ip,:] += simu.LR3/Nfiles # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
            
                    # Average of the estimated instantaneous variance. (has a 
                    # signification only in open loop)
                    InstVarPD[idit,ig,ip,:] += np.mean(simu.varPD,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    InstVarGD[idit,ig,ip,:] += np.mean(simu.varGD,axis=0)/Nfiles
                    InstVarGDUnbiased[idit,ig,ip,:] += np.mean(simu.varGDUnbiased,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    VarPDnum[idit,ig,ip,:] += np.mean(simu.varPDnum,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    VarPDdenom[idit,ig,ip,:] += np.mean(simu.varPDdenom,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    VarGDdenom[idit,ig,ip,:] += np.mean(simu.varGDdenom,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    VarGDdenomUnbiased[idit,ig,ip,:] += np.mean(simu.varGDdenomUnbiased,axis=0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    
                    Vmod[idit,ig,ip,:] = np.real(ct.NB2NIN(np.abs(simu.VisibilityObject[indWLOfTrack])))
                    Vangle[idit,ig,ip,:] = np.real(ct.NB2NIN(np.angle(simu.VisibilityObject[indWLOfTrack])))
            
                    ThresholdGDs[idit,ig,ip,:] = config.FT[&#39;ThresholdGD&#39;] # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    
            IDs.append(config.SimuTimeID)
            ThresholdGDmins.append(np.min(config.FT[&#39;ThresholdGD&#39;]))
            ThresholdGDmaxs.append(np.max(config.FT[&#39;ThresholdGD&#39;]))
            
            if optimCriteria==&#34;VarOPD&#34;:
                criteria = VarOPD
            elif optimCriteria==&#34;FC&#34;:
                criteria = 1-FCArray
            elif optimCriteria == &#34;LR&#34;:
                criteria = 1-LockedRatio
            elif optimCriteria == &#34;LR2&#34;:
                criteria = 1-LR2
            elif optimCriteria == &#34;WLR&#34;:
                criteria = 1-WLockedRatio
            elif optimCriteria == &#34;VarCP&#34;:
                if (not telescopes) and (len(telescopes) != 3):
                    raise Exception(&#39;For defining a closure phase, telescopes must be three.&#39;)
                else:
                    criteria = VarCP
            else:
                raise Exception(f&#39;The chosen criteria must be in this list: &#34;LR&#34;, &#34;LR2&#34;,&#34;WLR&#34;, &#34;FC&#34;, &#34;VarOPD&#34;, &#34;VarCP&#34;&#39;)
                    
                    
            if not telescopes:
                Value = np.max(np.mean(criteria[:,ig,ip,:], axis=1))   # Maximum (over DITs) of the averaged value (over baselines)
                bestDIT = DITs[np.argmax(np.mean(criteria[:,ig,ip,:], axis=1))]
            else:
                itel1,itel2 = telescopes[0]-1, telescopes[1]-1
                ib = ct.posk(itel1, itel2, config.NA)
                Value = np.max(criteria[:,ig,ip,ib])
                bestDIT = DITs[np.argmax(criteria[:,ig,ip,ib])]
            
            if verbose2:
                print(&#34;-------------------------------------------&#34;)
                print(f&#39;\nComputed value={round(Value,5)}&#39;)
            if Value &lt; minValue:    
                if verbose2:
                    print(f&#34;New value={round(Value,5)} lower than minValue={round(minValue,5)} obtained with (GD,PD)=({Ggd},{Gpd})&#34;)
                minValue = Value
                iOptim = igp
                iOptimGD = ig
                iOptimPD = ip
            else:
                if verbose2:
                    print(f&#34;We keep minimal value={round(minValue,5)} obtained with gains (GD,PD)=({GainsGD[iOptimGD]},{GainsPD[iOptimPD]})&#34;)

            Progress = LoopNumber/NumberOfLoops
            PassedTime = time.time() - time0
            RemainingTime = PassedTime/Progress - PassedTime
            
            
            if verbose:
                print(f&#34;Progression current optim: {round(LoopNumber/NumberOfLoops*100)}% ({strtime(PassedTime)}) - \
Remains {strtime(RemainingTime)}&#34;)
                print(&#34;-------------------------------------------\n&#34;)

    bestGains = GainsGD[iOptimGD], GainsPD[iOptimPD]
    
    
    from tabulate import tabulate
    # ich = [12,13,14,15,16,23,24,25,26,34,35,36,45,46,56]
    ichint = [int(&#39;&#39;.join([str(int(ic[0]+1)),str(int(ic[1]+1))])) for ic in config.ich] # Convert list of tuples into list of int
    telint = np.arange(1,NA+1)
    criteriasBase = [&#34;LR&#34;, &#34;LR2&#34;, &#34;LR3&#34;, &#34;WLR&#34;, &#34;FC&#34;, &#34;SNR(|V|Â²)&#34;,&#34;VarOPD [Âµm]&#34;,
                     &#34;VarGDRes&#34;,&#34;VarPDRes&#34;,&#34;InstVarPD&#34;,&#34;InstVarGD&#34;,&#34;InstVarGDUnbiased&#34;,
                     &#34;VarPDnum&#34;, &#34;VarPDdenom&#34;,&#34;VarGDdenom&#34;,&#34;VarGDdenomUnbiased&#34;, 
                     &#34;SNRPD&#34;,&#34;SNRGD&#34;,&#34;ThresholdGDs&#34;,
                     &#39;Vmod&#39;,&#39;Vangle&#39;]
    
    Ncb = len(criteriasBase)
    # A=list(np.repeat(GainsGD, Ncb)) ; B = criteriasBase*Ngains
    
    A = list(np.repeat(DITs, NgainsGD*NgainsPD*Ncb))
    Btemp = list(np.repeat(GainsGD,Ncb*NgainsPD))
    B = Btemp * NDIT
    Ctemp = list(np.repeat(GainsPD,Ncb))
    C = Ctemp * NDIT * NgainsGD
    C2 = list(np.repeat(IDs,Ncb)) * NDIT            # ID of the last simu
    C3 = list(np.repeat(ThresholdGDmins,Ncb)) * NDIT   # ThresholdGD
    C4 = list(np.repeat(ThresholdGDmaxs,Ncb)) * NDIT   # ThresholdGD
    D = criteriasBase * NDIT * NgainsGD * NgainsPD 
    
    base_5d = np.array([LockedRatio,LR2,LR3,WLockedRatio,FCArray,SNRSI,VarOPD,
                        VarGDRes,VarPDRes,InstVarPD,InstVarGD,InstVarGDUnbiased,
                        VarPDnum, VarPDdenom,VarGDdenom,VarGDdenomUnbiased,
                        np.sqrt(1/InstVarPD),np.sqrt(1/InstVarGD),
                        ThresholdGDs, Vmod,Vangle])
    base_5d = np.transpose(base_5d, (0,3,2,1,4))      # Trick to get the levels DIT, GD and PD in this order
    
    base_2d = base_5d.reshape([NDIT*Ncb*NgainsGD*NgainsPD,NIN], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
    
    # Need another dataframe only for Closure Phase (dimension 10)
    
    resultsBasedf = pd.DataFrame(data=base_2d, columns=[A,B,C,C2,C3,C4,D], index=ichint)
    
    CPindexint = [int(&#39;&#39;.join([str(int(cpindex[0]+1)),str(int(cpindex[1]+1)),str(int(cpindex[2]+1))])) for cpindex in config.CPindex]
    
    criteriasClosure = [&#34;VarCP [Âµm]&#34;, &#34;LR&#34;, &#34;WLR&#34;]
    
    Ncc = len(criteriasClosure)
    A = list(np.repeat(DITs, NgainsGD*NgainsPD*Ncc))
    Btemp = list(np.repeat(GainsGD,Ncc*NgainsPD))
    B = Btemp * NDIT
    Ctemp = list(np.repeat(GainsPD,Ncc))
    C = Ctemp * NDIT * NgainsGD
    C2 = list(np.repeat(IDs,Ncc)) * NDIT
    C3 = list(np.repeat(ThresholdGDmins,Ncc)) * NDIT
    C4 = list(np.repeat(ThresholdGDmaxs,Ncc)) * NDIT
    D = criteriasClosure * NDIT * NgainsGD * NgainsPD 
    
    
    # We only have VarCP so far so we populate the missing criteria with NaN values.
    CPLR = np.ones([NDIT,NgainsGD, NgainsPD,NC])*np.nan
    CPWLR = np.ones([NDIT,NgainsGD,NgainsPD,NC])*np.nan
    
    closure_5d = np.array([VarCP,CPLR,CPWLR])
    closure_5d = np.transpose(closure_5d, (0,3,2,1,4))
    
    closure_2d = closure_5d.reshape([NDIT*Ncc*NgainsGD*NgainsPD,NC], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows

    resultsClosuredf = pd.DataFrame(data=closure_2d, columns=[A,B,C,C2,C3,C4,D],index=CPindexint)
    
    &#34;&#34;&#34;
    Residues on Telescopes
    &#34;&#34;&#34;
    criteriasTel = [&#34;VarPiston&#34;,&#34;VarPistonGD&#34;,&#34;VarPistonPD&#34;]
    
    Nct = len(criteriasTel)
    
    A = list(np.repeat(DITs, NgainsGD*NgainsPD*Nct))
    Btemp = list(np.repeat(GainsGD,Nct*NgainsPD))
    B = Btemp * NDIT
    Ctemp = list(np.repeat(GainsPD,Nct))
    C = Ctemp * NDIT * NgainsGD
    C2 = list(np.repeat(IDs,Nct)) * NDIT            # ID of the last simu
    C3 = list(np.repeat(ThresholdGDmins,Nct)) * NDIT   # ThresholdGD
    C4 = list(np.repeat(ThresholdGDmaxs,Nct)) * NDIT   # ThresholdGD
    D = criteriasTel * NDIT * NgainsGD * NgainsPD 
    
    tel_5d = np.array([VarPiston,VarPistonGD,VarPistonPD])
    tel_5d = np.transpose(tel_5d, (0,3,2,1,4))      # Trick to get the levels DIT, GD and PD in this order
    
    tel_2d = tel_5d.reshape([NDIT*Nct*NgainsGD*NgainsPD,NA], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
    
    # Need another dataframe only for Closure Phase (dimension 10)
    
    resultsTeldf = pd.DataFrame(data=tel_2d, columns=[A,B,C,C2,C3,C4,D], index=telint)
    
    
    if not telescopes:
        Base_av = resultsBasedf.mean(axis=0).to_frame(name=&#39;Average&#39;)
        Closure_av = resultsClosuredf.mean(axis=0).to_frame(name=&#39;Average&#39;)
        Tel_av = resultsBasedf.mean(axis=0).to_frame(name=&#39;Average&#39;)
    else:
        itel1,itel2 = telescopes[0]-1, telescopes[1]-1
        ib = ct.posk(itel1, itel2, config.NA)
        ia = telescopes[0]-1  # histoire de mettre un truc, mais Ã  modifier si besoin
        Base_av = resultsBasedf.iloc[ib].to_frame(name=f&#34;{telescopes[0]}{telescopes[1]}&#34;)
        Closure_av = resultsClosuredf.iloc[ib].to_frame(name=f&#34;{telescopes[0]}{telescopes[1]}&#34;)
        Tel_av = resultsTeldf.iloc[ia].to_frame(name=f&#34;{telescopes[0]}&#34;)
        
    if optimCriteria==&#34;VarOPD&#34;:
        criteriaName = &#34;VarOPD [Âµm]&#34; 
    elif optimCriteria==&#34;FC&#34;:
        criteriaName = &#34;FC&#34;
    elif optimCriteria == &#34;LR&#34;:
        criteriaName = &#34;LR&#34;
    elif optimCriteria == &#34;WLR&#34;:
        criteriaName = &#34;WLR&#34;
    elif optimCriteria == &#34;VarCP&#34;:
        criteriaName = &#34;VarCP [Âµm]&#34;
    elif optimCriteria == &#34;VarPiston&#34;:
        criteriaName = &#34;VarPiston&#34;
    
    if criteriaName not in (&#34;VarCP&#34;,&#34;VarPiston&#34;):
        bestCombi = Base_av.loc[(slice(None),slice(None),slice(None),
                                 slice(None),slice(None),slice(None), 
                                 criteriaName)].idxmax(skipna=True)[0]
    elif criteriaName == &#39;VarPiston&#39;:
        bestCombi = Tel_av.loc[(slice(None),slice(None),slice(None),
                                 slice(None),slice(None),slice(None), 
                                 criteriaName)].idxmax(skipna=True)[0]
    else:
        bestCombi = Closure_av.loc[(slice(None),slice(None),slice(None)
                                    ,slice(None),slice(None),slice(None),
                                    criteriaName)].idxmax(skipna=True)[0]
        
    bestDIT, bestGainGD, bestGainPD = bestCombi[:3]

    if verbose2:
        print(f&#34;Best performances OPD reached with gains\
(GD,PD)={(bestGainGD, bestGainPD)} and DIT={bestDIT}ms&#34;)
        print(tabulate(resultsBasedf[bestCombi], headers=&#34;keys&#34;))
        
        print(f&#34;Same for closure phases with gain={bestGains}&#34;)
        print(tabulate(resultsClosuredf[bestCombi], headers=&#34;keys&#34;))
        
        print(f&#34;Same for telescopes with gain={bestGains}&#34;)
        print(tabulate(resultsTeldf[bestCombi], headers=&#34;keys&#34;))
   
    if display or len(figsave):
        if verbose2:
            print(&#34;We launch again the simulation with these gains on the last\
disturbance file to show the results.&#34;)
        
        config.FT[&#39;GainGD&#39;] = bestGainGD
        config.FT[&#39;GainPD&#39;] = bestGainPD
        sk.update_config(DisturbanceFile=DisturbanceFile,checkperiod=40, verbose=verbose)
        
        # Launch the simulator
        sk.loop(verbose=verbose,verbose2=verbose2)
        sk.display(&#39;perfarray&#39;,WLOfScience=np.median(SpectraForScience),display=display,
                   savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
    
    return bestCombi, resultsBasedf,  resultsClosuredf, resultsTeldf</code></pre>
</details>
</dd>
<dt id="cophasing.optimisation.OptimGainsTogether_multiDITs"><code class="name flex">
<span>def <span class="ident">OptimGainsTogether_multiDITs</span></span>(<span>GainsPD=[], GainsGD=[], DITs=array([1.00000000e+000, 2.06913808e+026, 4.28133240e+052, 8.85866790e+078,
1.83298071e+105, 3.79269019e+131, 7.84759970e+157, 1.62377674e+184,
3.35981829e+210, 6.95192796e+236, 1.43844989e+263, 2.97635144e+289,
inf,
inf,
inf,
inf,
inf,
inf,
inf,
inf]), optimCriteria='FC', filedir='', Nsamples=5, TimeBonds=100, WLOfTrack=1.5, SpectraForScience=array([0.6
, 0.605, 0.61 , 0.615, 0.62 , 0.625, 0.63 , 0.635, 0.64 ,
0.645, 0.65 , 0.655, 0.66 , 0.665, 0.67 , 0.675, 0.68 , 0.685,
0.69 , 0.695, 0.7
, 0.705, 0.71 , 0.715, 0.72 , 0.725, 0.73 ,
0.735, 0.74 , 0.745, 0.75 , 0.755, 0.76 , 0.765, 0.77 , 0.775,
0.78 , 0.785, 0.79 , 0.795, 0.8
, 0.805, 0.81 , 0.815, 0.82 ,
0.825, 0.83 , 0.835, 0.84 , 0.845, 0.85 , 0.855, 0.86 , 0.865,
0.87 , 0.875, 0.88 , 0.885, 0.89 , 0.895, 0.9
]), FileInterferometer='', MagnitudeInScienceBand=-1, telescopes=0, save_all='no', onlySNR=False, ComputeAllPerf=True, savepath='./', figsave='', display=False, verbose=False, verbose2=False, criterias='light')</span>
</code></dt>
<dd>
<div class="desc"><p>Estimates the best couple GD and PD gains after calculating the performance
(residual phase) of the servo loop on all the files contained in filedir.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>GainsPD</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is [].</dd>
<dt><strong><code>GainsGD</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is [].</dd>
<dt><strong><code>optim</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 'opd'.</dd>
<dt><strong><code>filedir</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is ''.</dd>
<dt><strong><code>TimeBonds</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 100.</dd>
<dt><strong><code>WLOfScience</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 1.5.</dd>
<dt><strong><code>DIT</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 50.</dd>
<dt><strong><code>telescopes</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 0.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OptimGainsTogether_multiDITs(GainsPD=[],GainsGD=[],DITs=np.logspace(0,500,20), 
                        optimCriteria=&#34;FC&#34;,filedir=&#39;&#39;,Nsamples=5,
                        TimeBonds=100, WLOfTrack=1.5,SpectraForScience=np.arange(0.6,0.9,0.005),
                        FileInterferometer=&#39;&#39;,MagnitudeInScienceBand=-1,telescopes=0, 
                        save_all=&#39;no&#39;,onlySNR=False,ComputeAllPerf=True,
                        savepath=&#39;./&#39;,figsave=&#39;&#39;,
                        display=False,verbose=False,verbose2=False, criterias=&#39;light&#39;):
    &#34;&#34;&#34;
    Estimates the best couple GD and PD gains after calculating the performance 
    (residual phase) of the servo loop on all the files contained in filedir.

    Parameters
    ----------
    GainsPD : TYPE, optional
        DESCRIPTION. The default is [].
    GainsGD : TYPE, optional
        DESCRIPTION. The default is [].
    optim : TYPE, optional
        DESCRIPTION. The default is &#39;opd&#39;.
    filedir : TYPE, optional
        DESCRIPTION. The default is &#39;&#39;.
    TimeBonds : TYPE, optional
        DESCRIPTION. The default is 100.
    WLOfScience : TYPE, optional
        DESCRIPTION. The default is 1.5.
    DIT : TYPE, optional
        DESCRIPTION. The default is 50.
    telescopes : TYPE, optional
        DESCRIPTION. The default is 0.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    
    from . import simu
    from . import config
    import pandas as pd
    
    from .config import NA, NIN, NC, NT, dt
        
    if not (len(GainsPD) and len(GainsPD)):
        raise Exception(&#39;Need GainsPD and GainsGD.&#39;)
    
    NgainsGD = len(GainsGD)
    NgainsPD = len(GainsPD)
        
    if verbose2:
        print(f&#34;Start optimisation with sample gains GD={GainsGD} and PD={GainsPD}&#34;)
    
    sk.update_config(checkperiod=110,verbose=verbose) # For not seeing the decount.
    
    if not len(FileInterferometer):
        FileInterferometer = &#34;data/interferometers/CHARAinterferometerR.fits&#34;
    
    if MagnitudeInScienceBand&lt;0:
        if &#39;SImag&#39; not in config.Target.Star1.keys():
            config.Target.Star1[&#39;SImag&#39;] = config.Target.Star1[&#39;Hmag&#39;]
    else:
        config.Target.Star1[&#39;SImag&#39;] = MagnitudeInScienceBand
    
    
    # The interferometer is &#34;not the same&#34; as for simulation, because not the same band.
    # In the future, both bands could be integrated in the same Interf class object.
    InterfArray = ct.get_array(name=FileInterferometer)
    
    CoherentFluxObject = ct.create_CfObj(SpectraForScience,
                                         config.Obs,config.Target,InterfArray)
    
    CoherentFluxObject = CoherentFluxObject*dt*1e-3
    
    minValue = 10000
    if len(filedir):
        files = [f.replace(&#34;\\&#34;,&#34;/&#34;) for f in glob.glob(filedir+&#39;*.fits&#39;)]
        Nfiles = len(files)
        if verbose2:
            print(f&#34;Found: {Nfiles} files&#34;)
        if Nsamples &lt; Nfiles:
            Nfiles = Nsamples
        if verbose2:
            print(f&#34;Take only the {Nsamples} first files&#34;)
    else:
        files = [config.DisturbanceFile]
        Nfiles = 1
    
    
    &#34;&#34;&#34; RECOMPUTATION OF THE INTEGRATION TIMES TO AVOID LOSS OF FRAMES&#34;&#34;&#34;
    
    if isinstance(TimeBonds,(float,int)):
        Period = int(NT - TimeBonds/dt)
        InFrame = round(TimeBonds/dt)
    elif isinstance(TimeBonds,(np.ndarray,list)):
        Period = int((TimeBonds[1]-TimeBonds[0])/dt)
        InFrame = round(TimeBonds[0]/dt)
    else:
        raise &#39;&#34;TimeBonds&#34; must be instance of (float,int,np.ndarray,list)&#39;


    DITf=DITs/dt
    #IntegrationTimes = IntegrationTimes//dt * dt
    Ndit=len(DITf)
    
    ObservingTime = Period*dt

    NewDITf=[]#DITf.copy()
    kbefore=[]
    for idit in range(Ndit):
        k = Period//DITf[idit]
        if k in kbefore: 
            k=np.min(kbefore)-1  # Avoid that two DITs be the same
        if k == -1:
            break # Stop if we reached the unique frame.
        r = Period%DITf[idit]
        if r &gt; 0.05*DITf[idit]:
            NewDITf.append(Period//(k+1))
        kbefore.append(k)
        
    NewDITf = np.array(NewDITf)
    newDITs = NewDITf*dt
    ListNframes = Period//NewDITf
    ThrownFrames = Period%NewDITf
    LengthOfKeptSequence = ListNframes * Period
    
    if verbose:
        print(f&#34;ObservingTimes:{ObservingTime}&#34;)
        print(f&#34;Proposed DITs:{DITs}&#34;)
        print(f&#34;ListNframes :{ListNframes}&#34;)
        print(f&#34;ThrownFrames :{ThrownFrames}&#34;)
        print(f&#34;New DITs:{newDITs}&#34;)
        print(f&#34;Percentage of loss: {np.round(ThrownFrames/LengthOfKeptSequence*100,2)}&#34;)
    # if ThrownFrames[idit] &gt; 0.05*LengthOfKeptSequence[idit]:
    #     NewIntegrationTimes.remove(IntegrationTimes[idit])
            
    simu.DITsForPerformance = newDITs
    Ndit = len(newDITs)
    
    time0 = time.time() ; LoopNumber = 0
    iOptimGD=0; iOptimPD=0 ; IDs=[] ; ThresholdGDmins=[] ; ThresholdGDmaxs=[]

    indWLOfTrack = np.argmin(np.abs(config.spectra-WLOfTrack))
    NumberOfLoops = NgainsGD*NgainsPD*Nfiles
    for ig in range(NgainsGD):
        Ggd = GainsGD[ig]    
        if verbose2:
            print(f&#34;-----------Start optimising with gain GD={Ggd}------------&#34;)   
        
        for ip in range(NgainsPD):
            igp = ig*NgainsPD + ip  # Position in the tables
            minindcurrentGD = ig*NgainsPD
            maxindcurrentGD = minindcurrentGD + NgainsPD
            
            Gpd = GainsPD[ip]
            
            config.FT[&#39;GainGD&#39;] = Ggd
            config.FT[&#39;GainPD&#39;] = Gpd
            
            if verbose:
                print(&#34;\n----------------------------------&#34;)
                print(f&#39;## Gain GD={Ggd}; GainPD={Gpd} ##&#39;)
                
            for ifile in range(Nfiles):
                LoopNumber+=1
                DisturbanceFile = files[ifile]
                if verbose2:
                    print(f&#39;File {ifile+1}/{Nfiles}&#39;)
                
                sk.update_config(DisturbanceFile=DisturbanceFile, verbose=verbose)
            
                # Launch the simulator
                if save_all==&#39;light&#39;:
                    sk.loop(savepath,LightSave=True,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;OPDTrue&#39;:
                    sk.loop(savepath,LightSave=&#39;OPDTrue&#39;,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;yes&#39;:
                    sk.loop(savepath,LightSave=False,verbose=verbose,verbose2=verbose2)
                elif save_all==&#39;no&#39;:
                    sk.loop(verbose=verbose,verbose2=verbose2)
                else:
                    raise Exception(&#39;save_all param must be &#34;light&#34;, &#34;yes&#34; or &#34;no&#34;.&#39;)
                    
                if len(figsave):
                    if figsave != &#39;onlyperf&#39;:
                        if isinstance(figsave,str):
                            sk.display(figsave,display=display,savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
                        elif isinstance(figsave,list):
                            if &#39;perfarray&#39; in figsave:
                                figsave.remove(&#39;perfarray&#39;)
                            sk.display(*figsave,display=display,savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
                        

                if ComputeAllPerf:
    
                    # Load the performance observables into simu module
                    _ = sk.ShowPerformance_multiDITs(TimeBonds,SpectraForScience,newDITs,
                                                 CoherentFluxObject=CoherentFluxObject,
                                                 display=False,verbose=verbose, onlySNR=onlySNR, criterias=criterias)
                    
                    if LoopNumber==1:
                        NDIT=len(newDITs) ; DITs = newDITs
                        
                        VarOPD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])         # Phase variances
                        VarGDRes = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # GD Phase variances after Igd dot
                        VarPDRes = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # PD Phase variances after Ipd dot
                        VarGDEst = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # GD estimator variances 
                        VarPDEst = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # PD estimator variances
                        
                        FCArray = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])        # Contains the fringe contrasts
                        LockedRatio = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])    # Locked ratio
                        LR2 = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Locked ratio
                        LR3 = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])            # Central fringe ratio
                        
                        
                        VarCP = np.zeros([NDIT,NgainsGD,NgainsPD,NC])           # Closure Phase variances
                        SNRSI = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])          # Signal-to-noise ratio in the scientific instrument
                        
                        Vmod = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
                        Vangle = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
                        
                        ThresholdGDs = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])
                        InstVarPD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
                        InstVarGD = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated GD variances
                        VarPiston = np.zeros([NDIT,NgainsGD,NgainsPD,NA])       # Piston variance
                        VarPistonGD = np.zeros([NDIT,NgainsGD,NgainsPD,NA])     # Piston GD variance
                        VarPistonPD = np.zeros([NDIT,NgainsGD,NgainsPD,NA])     # Piston PD variance
                        
                        if criterias!=&#39;light&#39;:
                        
                            InstVarGDUnbiased = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])      # Estimated PD variances
                            VarPDnum = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])       # Estimated PD variances
                            VarGDdenom = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
                            VarGDdenomUnbiased = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
                            VarPDdenom = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])     # Estimated PD variances
    
                            WLockedRatio = np.zeros([NDIT,NgainsGD,NgainsPD,NIN])   # Weigthed locked ratio
                            
                    
                    # Initialise the comparison tables
                    VarOPD[:,ig,ip,:] += simu.VarOPD/Nfiles
                    VarCP[:,ig,ip,:] += simu.VarCPD/Nfiles
                    VarGDRes[:,ig,ip,:] += simu.VarGDRes/Nfiles
                    VarPDRes[:,ig,ip,:] += simu.VarPDRes/Nfiles
                    VarGDEst[:,ig,ip,:] += simu.VarGDEst/Nfiles
                    VarPDEst[:,ig,ip,:] += simu.VarPDEst/Nfiles
    
                    SNRSI[:,ig,ip,:] += simu.SNR_E/Nfiles
                    FCArray[:,ig,ip,:] += np.mean(simu.FringeContrast,axis=1)/Nfiles
                    LockedRatio[:,ig,ip,:] += simu.LockedRatio/Nfiles
    
                    LR2[:,ig,ip,:] += simu.LR2/Nfiles # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    LR3[:,ig,ip,:] += simu.LR3/Nfiles # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                
                    Vmod[:,ig,ip,:] = np.repeat(np.real(ct.NB2NIN(np.abs(simu.VisibilityObject[indWLOfTrack])))[np.newaxis,:],NDIT,0)
                    Vangle[:,ig,ip,:] = np.repeat(np.real(ct.NB2NIN(np.angle(simu.VisibilityObject[indWLOfTrack])))[np.newaxis,:],NDIT,0)
            
                    ThresholdGDs[:,ig,ip,:] = np.repeat(config.FT[&#39;ThresholdGD&#39;][np.newaxis,:],NDIT,0) # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    InstVarPD[:,ig,ip,:] += np.repeat(np.mean(simu.varPD,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    InstVarGD[:,ig,ip,:] += np.repeat(np.mean(simu.varGD,axis=0)[np.newaxis,:],NDIT,0)/Nfiles
    
                    VarPiston[:,ig,ip,:] += simu.VarPiston/Nfiles
                    VarPistonGD[:,ig,ip,:] += simu.VarPistonGD/Nfiles
                    VarPistonPD[:,ig,ip,:] += simu.VarPistonPD/Nfiles
    
                    if criterias!=&#39;light&#39;:
                        
                        WLockedRatio[:,ig,ip,:] += simu.WLockedRatio/Nfiles
                
                        # These values don&#39;t have DIT dimension, so we must repeat it over
                        # this dimension for inserting it in dataframe.
                        
                        # Average of the estimated instantaneous variance. (has a 
                        # signification only in open loop)
                        InstVarGDUnbiased[:,ig,ip,:] += np.repeat(np.mean(simu.varGDUnbiased,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                        VarPDnum[:,ig,ip,:] += np.repeat(np.mean(simu.varPDnum,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                        VarPDdenom[:,ig,ip,:] += np.repeat(np.mean(simu.varPDdenom,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                        VarGDdenom[:,ig,ip,:] += np.repeat(np.mean(simu.varGDdenom,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                        VarGDdenomUnbiased[:,ig,ip,:] += np.repeat(np.mean(simu.varGDdenomUnbiased,axis=0)[np.newaxis,:],NDIT,0)/Nfiles  # Doesn&#39;t depend on the integration time but need DIT dimension for dataframe
                    
                        
            IDs.append(config.SimuTimeID)
            ThresholdGDmins.append(np.min(config.FT[&#39;ThresholdGD&#39;]))
            ThresholdGDmaxs.append(np.max(config.FT[&#39;ThresholdGD&#39;]))
            
            if optimCriteria==&#34;VarOPD&#34;:
                criteria = VarOPD
            elif optimCriteria==&#34;FC&#34;:
                criteria = 1-FCArray
            elif optimCriteria==&#34;SNRSI&#34;:
                criteria = 1/SNRSI
            elif optimCriteria == &#34;LR&#34;:
                criteria = 1-LockedRatio
            elif optimCriteria == &#34;LR2&#34;:
                criteria = 1-LR2
            elif optimCriteria == &#34;WLR&#34;:
                criteria = 1-WLockedRatio
            elif optimCriteria == &#34;VarCP&#34;:
                if (not telescopes) and (len(telescopes) != 3):
                    raise Exception(&#39;For defining a closure phase, telescopes must be three.&#39;)
                else:
                    criteria = VarCP
            else:
                raise Exception(f&#39;The chosen criteria must be in this list: &#34;LR&#34;, &#34;LR2&#34;,&#34;WLR&#34;, &#34;FC&#34;, &#34;VarOPD&#34;, &#34;VarCP&#34;&#39;)
                    
                    
            if not telescopes:
                Value = np.max(np.mean(criteria[:,ig,ip,:], axis=-1))   # Maximum (over DITs) of the averaged value (over baselines)
                bestDIT = DITs[np.argmax(np.mean(criteria[:,ig,ip,:], axis=-1))]
            else:
                itel1,itel2 = telescopes[0]-1, telescopes[1]-1
                ib = ct.posk(itel1, itel2, config.NA)
                Value = np.max(criteria[:,ig,ip,ib])
                bestDIT = DITs[np.argmax(criteria[:,ig,ip,ib])]
            
            if verbose2:
                print(&#34;-------------------------------------------&#34;)
                print(f&#39;\nComputed value={round(Value,5)}&#39;)
            if Value &lt; minValue:    
                if verbose2:
                    print(f&#34;New value={round(Value,5)} lower than minValue={round(minValue,5)} obtained with (GD,PD)=({Ggd},{Gpd})&#34;)
                minValue = Value
                iOptim = igp
                iOptimGD = ig
                iOptimPD = ip
            else:
                if verbose2:
                    print(f&#34;We keep minimal value={round(minValue,5)} obtained with gains (GD,PD)=({GainsGD[iOptimGD]},{GainsPD[iOptimPD]})&#34;)

            Progress = LoopNumber/NumberOfLoops
            PassedTime = time.time() - time0
            RemainingTime = PassedTime/Progress - PassedTime
            
            
            if verbose:
                print(f&#34;Progression current optim: {round(LoopNumber/NumberOfLoops*100)}% ({strtime(PassedTime)}) - \
    Remains {strtime(RemainingTime)}&#34;)
                print(&#34;-------------------------------------------\n&#34;)

    if not ComputeAllPerf:
        return
    
    else:
        
        bestGains = GainsGD[iOptimGD], GainsPD[iOptimPD]
        
        from tabulate import tabulate
        # ich = [12,13,14,15,16,23,24,25,26,34,35,36,45,46,56]
        ichint = [int(&#39;&#39;.join([str(int(ic[0]+1)),str(int(ic[1]+1))])) for ic in config.ich] # Convert list of tuples into list of int
        telint = np.arange(1,NA+1)
        
        if criterias==&#39;light&#39;:
            criteriasBase = [&#34;LR&#34;, &#34;LR2&#34;, &#34;LR3&#34;, &#34;FC&#34;, &#34;SNR(|V|Â²)&#34;,&#34;VarOPD [Âµm]&#34;,
                             &#34;SNRPD&#34;,&#34;SNRGD&#34;,&#34;ThresholdGDs&#34;,
                             &#39;Vmod&#39;,&#39;Vangle&#39;]
        
        else:
            criteriasBase = [&#34;LR&#34;, &#34;LR2&#34;, &#34;LR3&#34;, &#34;WLR&#34;, &#34;FC&#34;, &#34;SNR(|V|Â²)&#34;,&#34;VarOPD [Âµm]&#34;,
                             &#34;VarGDRes&#34;,&#34;VarPDRes&#34;,&#34;VarGDEst&#34;,&#34;VarPDEst&#34;,&#34;InstVarPD&#34;,&#34;InstVarGD&#34;,&#34;InstVarGDUnbiased&#34;,
                             &#34;VarPDnum&#34;, &#34;VarPDdenom&#34;,&#34;VarGDdenom&#34;,&#34;VarGDdenomUnbiased&#34;, 
                             &#34;SNRPD&#34;,&#34;SNRGD&#34;,&#34;ThresholdGDs&#34;,
                               &#39;Vmod&#39;,&#39;Vangle&#39;]  
        
        Ncb = len(criteriasBase)
        # A=list(np.repeat(GainsGD, Ncb)) ; B = criteriasBase*Ngains
        
        A = list(np.repeat(DITs, NgainsGD*NgainsPD*Ncb))
        Btemp = list(np.repeat(GainsGD,Ncb*NgainsPD))
        B = Btemp * NDIT
        Ctemp = list(np.repeat(GainsPD,Ncb))
        C = Ctemp * NDIT * NgainsGD
        C2 = list(np.repeat(IDs,Ncb)) * NDIT            # ID of the last simu
        C3 = list(np.repeat(ThresholdGDmins,Ncb)) * NDIT   # ThresholdGD
        C4 = list(np.repeat(ThresholdGDmaxs,Ncb)) * NDIT   # ThresholdGD
        D = criteriasBase * NDIT * NgainsGD * NgainsPD 
        
        if criterias==&#39;light&#39;:
            base_5d = np.array([LockedRatio,LR2,LR3,FCArray,SNRSI,VarOPD,
                                np.sqrt(1/InstVarPD),np.sqrt(1/InstVarGD),
                                ThresholdGDs, Vmod,Vangle])
        else:
            base_5d = np.array([LockedRatio,LR2,LR3,WLockedRatio,FCArray,SNRSI,VarOPD,
                                VarGDRes,VarPDRes,VarGDEst,VarPDEst,InstVarPD,InstVarGD,InstVarGDUnbiased,
                                VarPDnum, VarPDdenom,VarGDdenom,VarGDdenomUnbiased,
                                np.sqrt(1/InstVarPD),np.sqrt(1/InstVarGD),
                                ThresholdGDs, Vmod,Vangle])
            
        base_5d = np.transpose(base_5d, (0,3,2,1,4))      # Trick to get the levels DIT, GD and PD in this order
        
        base_2d = base_5d.reshape([NDIT*Ncb*NgainsGD*NgainsPD,NIN], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
        
        resultsBasedf = pd.DataFrame(data=base_2d, columns=[A,B,C,C2,C3,C4,D], index=ichint)
        
        CPindexint = [int(&#39;&#39;.join([str(int(cpindex[0]+1)),str(int(cpindex[1]+1)),str(int(cpindex[2]+1))])) for cpindex in config.CPindex]
        
        criteriasClosure = [&#34;VarCP [Âµm]&#34;, &#34;LR&#34;, &#34;WLR&#34;]
        
        Ncc = len(criteriasClosure)
        A = list(np.repeat(DITs, NgainsGD*NgainsPD*Ncc))
        Btemp = list(np.repeat(GainsGD,Ncc*NgainsPD))
        B = Btemp * NDIT
        Ctemp = list(np.repeat(GainsPD,Ncc))
        C = Ctemp * NDIT * NgainsGD
        C2 = list(np.repeat(IDs,Ncc)) * NDIT
        C3 = list(np.repeat(ThresholdGDmins,Ncc)) * NDIT
        C4 = list(np.repeat(ThresholdGDmaxs,Ncc)) * NDIT
        D = criteriasClosure * NDIT * NgainsGD * NgainsPD 
        
        
        # We only have VarCP so far so we populate the missing criteria with NaN values.
        CPLR = np.ones([NDIT,NgainsGD, NgainsPD,NC])*np.nan
        CPWLR = np.ones([NDIT,NgainsGD,NgainsPD,NC])*np.nan
        
        closure_5d = np.array([VarCP,CPLR,CPWLR])
        closure_5d = np.transpose(closure_5d, (0,3,2,1,4))
        
        closure_2d = closure_5d.reshape([NDIT*Ncc*NgainsGD*NgainsPD,NC], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
    
        resultsClosuredf = pd.DataFrame(data=closure_2d, columns=[A,B,C,C2,C3,C4,D],index=CPindexint)
        
        &#34;&#34;&#34;
        Residues on Telescopes
        &#34;&#34;&#34;
        criteriasTel = [&#34;VarPiston&#34;,&#34;VarPistonGD&#34;,&#34;VarPistonPD&#34;]
        
        Nct = len(criteriasTel)
        # A=list(np.repeat(GainsGD, Ncb)) ; B = criteriasBase*Ngains
        
        A = list(np.repeat(DITs, NgainsGD*NgainsPD*Nct))
        Btemp = list(np.repeat(GainsGD,Nct*NgainsPD))
        B = Btemp * NDIT
        Ctemp = list(np.repeat(GainsPD,Nct))
        C = Ctemp * NDIT * NgainsGD
        C2 = list(np.repeat(IDs,Nct)) * NDIT            # ID of the last simu
        C3 = list(np.repeat(ThresholdGDmins,Nct)) * NDIT   # ThresholdGD
        C4 = list(np.repeat(ThresholdGDmaxs,Nct)) * NDIT   # ThresholdGD
        D = criteriasTel * NDIT * NgainsGD * NgainsPD 
        
        tel_5d = np.array([VarPiston,VarPistonGD,VarPistonPD])
        tel_5d = np.transpose(tel_5d, (0,3,2,1,4))      # Trick to get the levels DIT, GD and PD in this order
        
        tel_2d = tel_5d.reshape([NDIT*Nct*NgainsGD*NgainsPD,NA], order=&#39;F&#39;).T  # The first index (criterias) changing fastest, then transpose for having baselines in rows
        
        # Need another dataframe only for Closure Phase (dimension 10)
        
        resultsTeldf = pd.DataFrame(data=tel_2d, columns=[A,B,C,C2,C3,C4,D], index=telint)
        
        if not telescopes:
            Base_av = resultsBasedf.mean(axis=0).to_frame(name=&#39;Average&#39;)
            Closure_av = resultsClosuredf.mean(axis=0).to_frame(name=&#39;Average&#39;)
            Tel_av = resultsBasedf.mean(axis=0).to_frame(name=&#39;Average&#39;)
        else:
            itel1,itel2 = telescopes[0]-1, telescopes[1]-1
            ib = ct.posk(itel1, itel2, config.NA)
            ia = telescopes[0]-1  # histoire de mettre un truc, mais Ã  modifier si besoin
            Base_av = resultsBasedf.iloc[ib].to_frame(name=f&#34;{telescopes[0]}{telescopes[1]}&#34;)
            Closure_av = resultsClosuredf.iloc[ib].to_frame(name=f&#34;{telescopes[0]}{telescopes[1]}&#34;)
            Tel_av = resultsTeldf.iloc[ia].to_frame(name=f&#34;{telescopes[0]}&#34;)
            
        if optimCriteria==&#34;VarOPD&#34;:
            criteriaName = &#34;VarOPD [Âµm]&#34; 
        elif optimCriteria==&#34;FC&#34;:
            criteriaName = &#34;FC&#34;
        elif optimCriteria==&#34;SNRSI&#34;:
            criteriaName= &#34;SNR(|V|Â²)&#34;
        elif optimCriteria == &#34;LR&#34;:
            criteriaName = &#34;LR&#34;
        elif optimCriteria == &#34;WLR&#34;:
            criteriaName = &#34;WLR&#34;
        elif optimCriteria == &#34;VarCP&#34;:
            criteriaName = &#34;VarCP [Âµm]&#34;
        elif optimCriteria == &#34;VarPiston&#34;:
            criteriaName = &#34;VarPiston&#34;
        
        if criteriaName not in (&#34;VarCP&#34;,&#34;VarPiston&#34;):
            bestCombi = Base_av.loc(axis=0)[:,:,:,:,:,:,
                                            criteriaName].idxmax(skipna=True)[0]
        elif criteriaName == &#39;VarPiston&#39;:
            bestCombi = Tel_av.loc(axis=0)[:,:,:,:,:,:,
                                           criteriaName].idxmax(skipna=True)[0]
        else:
            bestCombi = Closure_av.loc(axis=0)[:,:,:,:,:,:,
                                               criteriaName].idxmax(skipna=True)[0]
        
        bestDIT, bestGainGD, bestGainPD = bestCombi[:3]
        
        if verbose2:
            print(f&#34;Best performances OPD reached with gains\
    (GD,PD)={(bestGainGD, bestGainPD)} and DIT={bestDIT}ms&#34;)
            print(tabulate(resultsBasedf[bestCombi], headers=&#34;keys&#34;))
            
            print(f&#34;Same for closure phases with gain={bestGains}&#34;)
            print(tabulate(resultsClosuredf[bestCombi], headers=&#34;keys&#34;))
            
            print(f&#34;Same for telescopes with gain={bestGains}&#34;)
            print(tabulate(resultsTeldf[bestCombi], headers=&#34;keys&#34;))
       
        if display or len(figsave):
            if verbose2:
                print(&#34;We launch again the simulation with these gains on the last\
    disturbance file to show the results.&#34;)
            
            config.FT[&#39;GainGD&#39;] = bestGainGD
            config.FT[&#39;GainPD&#39;] = bestGainPD
            sk.update_config(DisturbanceFile=DisturbanceFile,checkperiod=40, verbose=verbose)
            
            # Launch the simulator
            sk.loop(verbose=verbose, verbose2=verbose2)
            # sk.display(&#39;perfarray&#39;,WLOfScience=np.median(SpectraForScience),display=display,
            #            savedir=savepath,ext=&#39;pdf&#39;,verbose=verbose2)
    
        return bestCombi, resultsBasedf,  resultsClosuredf, resultsTeldf</code></pre>
</details>
</dd>
<dt id="cophasing.optimisation.calcRMS"><code class="name flex">
<span>def <span class="ident">calcRMS</span></span>(<span>startframe)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the Standard Deviation of the OPD in micrometers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>startframe</code></strong> :&ensp;<code>integer</code></dt>
<dd>Starting time in the loop. An integer, not in ms for the moment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>varOPD</code></strong> :&ensp;<code>float</code></dt>
<dd>.</dd>
<dt><strong><code>varOGD</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcRMS(startframe):
    &#34;&#34;&#34;
    Calculates the Standard Deviation of the OPD in micrometers.
        

    Parameters
    ----------
    startframe : integer
        Starting time in the loop. An integer, not in ms for the moment.

    Returns
    -------
    varOPD : float
        .
    varOGD : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    from .simu import OPDTrue
    
    rmsOPD = np.std(OPDTrue[startframe:,:],axis=0)
    
    return rmsOPD</code></pre>
</details>
</dd>
<dt id="cophasing.optimisation.strtime"><code class="name flex">
<span>def <span class="ident">strtime</span></span>(<span>time_to_write)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a a time given in second on the format ##h##m##s</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time_to_write</code></strong> :&ensp;<code>INT</code></dt>
<dd>SECONDS.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>
<h2 id="hms">h##m##s.</h2>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strtime(time_to_write):
    &#34;&#34;&#34;
    Write a a time given in second on the format ##h##m##s

    Parameters
    ----------
    time_to_write : INT
        SECONDS.

    Returns
    -------
    str
        ##h##m##s.

    &#34;&#34;&#34;
    
    return f&#34;{int(time_to_write//3600)}h{int(time_to_write%3600/60)}m{int((time_to_write%3600)%60)}s&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cophasing" href="index.html">cophasing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cophasing.optimisation.OptimGainsTogether" href="#cophasing.optimisation.OptimGainsTogether">OptimGainsTogether</a></code></li>
<li><code><a title="cophasing.optimisation.OptimGainsTogether_multiDITs" href="#cophasing.optimisation.OptimGainsTogether_multiDITs">OptimGainsTogether_multiDITs</a></code></li>
<li><code><a title="cophasing.optimisation.calcRMS" href="#cophasing.optimisation.calcRMS">calcRMS</a></code></li>
<li><code><a title="cophasing.optimisation.strtime" href="#cophasing.optimisation.strtime">strtime</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>